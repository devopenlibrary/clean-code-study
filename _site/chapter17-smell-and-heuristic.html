<!DOCTYPE html> <html lang="en"> <head> <meta charset="UTF-8"> <meta http-equiv="X-UA-Compatible" content="IE=Edge"> <link rel="stylesheet" href="/assets/css/just-the-docs-default.css"> <link rel="stylesheet" href="/assets/css/just-the-docs-head-nav.css" id="jtd-head-nav-stylesheet"> <style id="jtd-nav-activation"> .site-nav > ul.nav-list:first-child > li:not(:nth-child(18)) > a, .site-nav > ul.nav-list:first-child > li > ul > li a { background-image: none; } .site-nav > ul.nav-list:not(:first-child) a, .site-nav li.external a { background-image: none; } .site-nav > ul.nav-list:first-child > li:nth-child(18) > a { font-weight: 600; text-decoration: none; }.site-nav > ul.nav-list:first-child > li:nth-child(18) > button svg { transform: rotate(-90deg); }.site-nav > ul.nav-list:first-child > li.nav-list-item:nth-child(18) > ul.nav-list { display: block; } </style> <script src="/assets/js/vendor/lunr.min.js"></script> <script src="/assets/js/just-the-docs.js"></script> <meta name="viewport" content="width=device-width, initial-scale=1"> <!-- Begin Jekyll SEO tag v2.8.0 --> <title>17장 냄새와 휴리스틱 | Dev Open Library</title> <meta name="generator" content="Jekyll v3.10.0" /> <meta property="og:title" content="17장 냄새와 휴리스틱" /> <meta property="og:locale" content="en" /> <meta name="description" content="A minimal, responsive and feature-rich Jekyll theme for technical writing." /> <meta property="og:description" content="A minimal, responsive and feature-rich Jekyll theme for technical writing." /> <link rel="canonical" href="http://localhost:4000/chapter17-smell-and-heuristic.html" /> <meta property="og:url" content="http://localhost:4000/chapter17-smell-and-heuristic.html" /> <meta property="og:site_name" content="Dev Open Library" /> <meta property="og:type" content="website" /> <meta name="twitter:card" content="summary" /> <meta property="twitter:title" content="17장 냄새와 휴리스틱" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"WebPage","description":"A minimal, responsive and feature-rich Jekyll theme for technical writing.","headline":"17장 냄새와 휴리스틱","url":"http://localhost:4000/chapter17-smell-and-heuristic.html"}</script> <!-- End Jekyll SEO tag --> </head> <body> <a class="skip-to-main" href="#main-content">Skip to main content</a> <svg xmlns="http://www.w3.org/2000/svg" class="d-none"> <symbol id="svg-link" viewBox="0 0 24 24"> <title>Link</title> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-link"> <path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path> </svg> </symbol> <symbol id="svg-menu" viewBox="0 0 24 24"> <title>Menu</title> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-menu"> <line x1="3" y1="12" x2="21" y2="12"></line><line x1="3" y1="6" x2="21" y2="6"></line><line x1="3" y1="18" x2="21" y2="18"></line> </svg> </symbol> <symbol id="svg-arrow-right" viewBox="0 0 24 24"> <title>Expand</title> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-chevron-right"> <polyline points="9 18 15 12 9 6"></polyline> </svg> </symbol> <!-- Feather. MIT License: https://github.com/feathericons/feather/blob/master/LICENSE --> <symbol id="svg-external-link" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-external-link"> <title id="svg-external-link-title">(external link)</title> <path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path><polyline points="15 3 21 3 21 9"></polyline><line x1="10" y1="14" x2="21" y2="3"></line> </symbol> <symbol id="svg-doc" viewBox="0 0 24 24"> <title>Document</title> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-file"> <path d="M13 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V9z"></path><polyline points="13 2 13 9 20 9"></polyline> </svg> </symbol> <symbol id="svg-search" viewBox="0 0 24 24"> <title>Search</title> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-search"> <circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"></line> </svg> </symbol> <!-- Bootstrap Icons. MIT License: https://github.com/twbs/icons/blob/main/LICENSE.md --> <symbol id="svg-copy" viewBox="0 0 16 16"> <title>Copy</title> <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-clipboard" viewBox="0 0 16 16"> <path d="M4 1.5H3a2 2 0 0 0-2 2V14a2 2 0 0 0 2 2h10a2 2 0 0 0 2-2V3.5a2 2 0 0 0-2-2h-1v1h1a1 1 0 0 1 1 1V14a1 1 0 0 1-1 1H3a1 1 0 0 1-1-1V3.5a1 1 0 0 1 1-1h1v-1z"/> <path d="M9.5 1a.5.5 0 0 1 .5.5v1a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5v-1a.5.5 0 0 1 .5-.5h3zm-3-1A1.5 1.5 0 0 0 5 1.5v1A1.5 1.5 0 0 0 6.5 4h3A1.5 1.5 0 0 0 11 2.5v-1A1.5 1.5 0 0 0 9.5 0h-3z"/> </svg> </symbol> <symbol id="svg-copied" viewBox="0 0 16 16"> <title>Copied</title> <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-clipboard-check-fill" viewBox="0 0 16 16"> <path d="M6.5 0A1.5 1.5 0 0 0 5 1.5v1A1.5 1.5 0 0 0 6.5 4h3A1.5 1.5 0 0 0 11 2.5v-1A1.5 1.5 0 0 0 9.5 0h-3Zm3 1a.5.5 0 0 1 .5.5v1a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5v-1a.5.5 0 0 1 .5-.5h3Z"/> <path d="M4 1.5H3a2 2 0 0 0-2 2V14a2 2 0 0 0 2 2h10a2 2 0 0 0 2-2V3.5a2 2 0 0 0-2-2h-1v1A2.5 2.5 0 0 1 9.5 5h-3A2.5 2.5 0 0 1 4 2.5v-1Zm6.854 7.354-3 3a.5.5 0 0 1-.708 0l-1.5-1.5a.5.5 0 0 1 .708-.708L7.5 10.793l2.646-2.647a.5.5 0 0 1 .708.708Z"/> </svg> </symbol> </svg> <div class="side-bar"> <div class="site-header" role="banner"> <a href="/" class="site-title lh-tight"> Dev Open Library </a> <button id="menu-button" class="site-button btn-reset" aria-label="Toggle menu" aria-pressed="false"> <svg viewBox="0 0 24 24" class="icon" aria-hidden="true"><use xlink:href="#svg-menu"></use></svg> </button> </div> <nav aria-label="Main" id="site-nav" class="site-nav"> <ul class="nav-list"><li class="nav-list-item"><a href="/" class="nav-list-link">Clean Code Study</a></li><li class="nav-list-item"><a href="/chapter1-clean-code.html" class="nav-list-link">1장 깨끗한 코드</a></li><li class="nav-list-item"><a href="/chapter2-meaningful-names.html" class="nav-list-link">2장 의미 있는 이름</a></li><li class="nav-list-item"><a href="/chapter3-function.html" class="nav-list-link">3장 함수</a></li><li class="nav-list-item"><a href="/chapter4-annotation.html" class="nav-list-link">4장 주석</a></li><li class="nav-list-item"><a href="/chapter5-consistent-formatting%20.html" class="nav-list-link">5장 형식 맞추기</a></li><li class="nav-list-item"><a href="/chpater6-obejct-and-data-structure.html" class="nav-list-link">6장 객체와 자료구조</a></li><li class="nav-list-item"><a href="/chapter7-error-handling.html" class="nav-list-link">7장 오류 처리</a></li><li class="nav-list-item"><a href="/chapter8-boundary.html" class="nav-list-link">8장 경계</a></li><li class="nav-list-item"><a href="/chapter9-unit-test.html" class="nav-list-link">9장 단위 테스트</a></li><li class="nav-list-item"><a href="/chapter10-class.html" class="nav-list-link">10장 클래스</a></li><li class="nav-list-item"><a href="/chapter11-system.html" class="nav-list-link">11장 시스템</a></li><li class="nav-list-item"><a href="/chapter12-emergence.html" class="nav-list-link">12장 창발성</a></li><li class="nav-list-item"><a href="/chapter13-concurrency.html" class="nav-list-link">13장 동시성</a></li><li class="nav-list-item"><a href="/chapter14-incremental-improvement.html" class="nav-list-link">14장 점진적인 개선</a></li><li class="nav-list-item"><a href="/chapter15-junit.html" class="nav-list-link">15장 JUnit</a></li><li class="nav-list-item"><a href="/chapter16-SerialDate-refactoring.html" class="nav-list-link">16장 SerialDate 리팩토링</a></li><li class="nav-list-item"><a href="/chapter17-smell-and-heuristic.html" class="nav-list-link">17장 냄새와 휴리스틱</a></li><li class="nav-list-item"><a href="/appendix-concurrency.html" class="nav-list-link">동시성</a></li></ul> </nav> <footer class="site-footer"> This site uses <a href="https://github.com/just-the-docs/just-the-docs">Just the Docs</a>, a documentation theme for Jekyll. </footer> </div> <div class="main" id="top"> <div id="main-header" class="main-header"> <div class="search" role="search"> <div class="search-input-wrap"> <input type="text" id="search-input" class="search-input" tabindex="0" placeholder="Search Dev Open Library" aria-label="Search Dev Open Library" autocomplete="off"> <label for="search-input" class="search-label"><svg viewBox="0 0 24 24" class="search-icon"><use xlink:href="#svg-search"></use></svg></label> </div> <div id="search-results" class="search-results"></div> </div> </div> <div class="main-content-wrap"> <div id="main-content" class="main-content"> <main> <h1 id="17장-냄새와-휴리스틱"> <a href="#17장-냄새와-휴리스틱" class="anchor-heading" aria-labelledby="17장-냄새와-휴리스틱"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 17장 냄새와 휴리스틱 </h1> <p>아래 목록들은 다양한 프로그램을 리팩터링하는 과정에서, 수정할 때마다 “왜?”라고 자문하고 그 답을 기록한 결과이다.</p> <p><em>즉 아래 목록들은 코드를 수정해야 하는 이유인 냄새(나쁜 냄새)를 풍기는 요소들이며, <strong>지양해야 하는</strong> 요소들이다.</em></p> <h2 id="주석"> <a href="#주석" class="anchor-heading" aria-labelledby="주석"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 주석 </h2> <h3 id="c1-부적절한-정보"> <a href="#c1-부적절한-정보" class="anchor-heading" aria-labelledby="c1-부적절한-정보"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> <em>C1: 부적절한 정보</em> </h3> <ul> <li>다른 시스템(e.g. 소스 코드 관리 시스템, 이슈 추적 시스템 등)에 저장할 정보는 주석으로 적절치 못하다.</li> <li><strong>주석은 코드와 설계에 기술적인 설명을 부연하는 수단</strong>이다.</li> </ul> <h3 id="c2-쓸모없는-주석"> <a href="#c2-쓸모없는-주석" class="anchor-heading" aria-labelledby="c2-쓸모없는-주석"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> <em>C2: 쓸모없는 주석</em> </h3> <ul> <li>오래된, 엉뚱한, 잘못된 주석은 쓸모없다.</li> <li>쓸모없는 주석은 아예 달지 않거나, 발견하는 즉시 삭제하는 편이 좋다.</li> </ul> <h3 id="c3-중복된-주석"> <a href="#c3-중복된-주석" class="anchor-heading" aria-labelledby="c3-중복된-주석"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> <em>C3: 중복된 주석</em> </h3> <ul> <li>중복된 주석은 코드만으로 충분한데 구구절절 설명하는 주석이다.</li> <li> <p>다음은 중복된 주석의 예이다.</p> <ul> <li> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="n">i</span><span class="o">++;</span> <span class="c1">// i 증가</span>
</code></pre></div> </div> <p>혹은, 함수 서명만 달랑 기술하는 <code class="language-plaintext highlighter-rouge">Javadoc</code>이다.</p> </li> <li>```java /** <ul> <li>@param sellRequest</li> <li>@return</li> <li>@throws ManagedComponentException */ public SellResponse beginSellItem(SellRequest sellRequest) throws ManagedComponentException ```</li> </ul> </li> </ul> </li> <li>다시 한 번, <strong>주석은 코드만으로 다하지 못하는 설명을 부연하는 역할이다.</strong></li> </ul> <h3 id="c4-성의-없는-주석"> <a href="#c4-성의-없는-주석" class="anchor-heading" aria-labelledby="c4-성의-없는-주석"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> <em>C4: 성의 없는 주석</em> </h3> <ul> <li>주석을 작성하려면, 공을 들여서 작성해야 한다.</li> <li>단어는 신중하게 선택하고, 당연한 소리를 반복하지 않는다.</li> <li>간결하고 명료하게 작성한다.</li> </ul> <h3 id="c5-주석-처리된-코드"> <a href="#c5-주석-처리된-코드" class="anchor-heading" aria-labelledby="c5-주석-처리된-코드"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> <em>C5: 주석 처리된 코드</em> </h3> <ul> <li>주석 처리된 코드는 흉물 그 자체다. 그러니 발견 즉시 지워버려라.</li> <li>소스 코드 관리 시스템이 기억한다.</li> <li>주석 처리된 코드는 얼마나 오래되었는지, 사용하는 코드인지 아무도 알 수가 없다.</li> </ul> <h2 id="환경"> <a href="#환경" class="anchor-heading" aria-labelledby="환경"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 환경 </h2> <h3 id="e1-여러-단계로-빌드해야-한다"> <a href="#e1-여러-단계로-빌드해야-한다" class="anchor-heading" aria-labelledby="e1-여러-단계로-빌드해야-한다"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> <em>E1: 여러 단계로 빌드해야 한다</em> </h3> <ul> <li>빌드는 간단히 한 단계로 끝나야 한다.</li> <li>소스 코드 관리 시스템에서 이것저것 체크아웃할 필요가 없어야 한다.</li> <li>또한 불가해한 명령이나 스크립트를 잇달아 실행해 각 요소를 따로 빌드할 필요가 없어야 한다.</li> </ul> <h3 id="e2-여러-단계로-테스트해야-한다"> <a href="#e2-여러-단계로-테스트해야-한다" class="anchor-heading" aria-labelledby="e2-여러-단계로-테스트해야-한다"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> <em>E2: 여러 단계로 테스트해야 한다</em> </h3> <ul> <li>모든 단위 테스트는 한 명령으로 돌려야 한다.</li> <li>IDE에서 버튼 하나로 모든 테스트를 돌린다면 가장 이상적이다.</li> </ul> <h2 id="함수"> <a href="#함수" class="anchor-heading" aria-labelledby="함수"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 함수 </h2> <h3 id="f1-너무-많은-인수"> <a href="#f1-너무-많은-인수" class="anchor-heading" aria-labelledby="f1-너무-많은-인수"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> <em>F1: 너무 많은 인수</em> </h3> <ul> <li><strong>함수에서 인수 개수는 작을수록 좋다.</strong></li> <li>인수가 넷 이상이라면 의심하고 최대한 피한다.</li> </ul> <h3 id="f2-출력-인수"> <a href="#f2-출력-인수" class="anchor-heading" aria-labelledby="f2-출력-인수"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> <em>F2: 출력 인수</em> </h3> <ul> <li>일반적으로 인수는 입력으로 간주된다. 따라서 출력 인수는 직관적으로 이해하기 매우 어렵다.</li> <li>함수에서 뭔가의 상태를 변경해야 한다면, 함수가 속한 객체의 상태를 변경한다.</li> </ul> <h3 id="f3-플래그-인수"> <a href="#f3-플래그-인수" class="anchor-heading" aria-labelledby="f3-플래그-인수"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> <em>F3: 플래그 인수</em> </h3> <ul> <li>플래그 인수는 그 함수가 둘 이상의 일을 수행한다는 명백한 증거이므로 피해야 한다.</li> </ul> <h3 id="f4-죽은-함수"> <a href="#f4-죽은-함수" class="anchor-heading" aria-labelledby="f4-죽은-함수"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> <em>F4: 죽은 함수</em> </h3> <ul> <li>아무도 호출하지 않는 함수는 과감히 삭제하라.</li> </ul> <h2 id="일반"> <a href="#일반" class="anchor-heading" aria-labelledby="일반"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 일반 </h2> <h3 id="g1-한-소스-파일에-여러-언어를-사용한다"> <a href="#g1-한-소스-파일에-여러-언어를-사용한다" class="anchor-heading" aria-labelledby="g1-한-소스-파일에-여러-언어를-사용한다"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> <em>G1: 한 소스 파일에 여러 언어를 사용한다</em> </h3> <ul> <li>오늘날 프로그래밍 환경은 한 소스 파일 내에서 다양한 언어를 지원한다.</li> <li>가능한 소스 파일 하나에 언어 하나만 사용하는 방식이 가장 좋다.</li> <li>현실적으로 여러 언어가 불가피하지만 각별한 노력을 기울여 최대한 줄이도록 노력한다.</li> </ul> <h3 id="g2-당연한-동작을-구현하지-않는다"> <a href="#g2-당연한-동작을-구현하지-않는다" class="anchor-heading" aria-labelledby="g2-당연한-동작을-구현하지-않는다"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> <em>G2: 당연한 동작을 구현하지 않는다</em> </h3> <ul> <li>최소 놀람의 원칙에 의거해 함수나 클래스는 다른 프로그래머가 당연하게 여길 만한 동작과 기능을 제공해야 한다. <ul> <li> <blockquote> <p>소프트웨어 설계에서 시스템이 사용자의 예상에 최대한 부합하도록 설계해야 한다는 원칙</p> </blockquote> </li> </ul> </li> <li>예를 들어, 요일 문자열에서 요일을 나타내는 <code class="language-plaintext highlighter-rouge">enum</code>으로 변환하는 함수를 살펴보자. <ul> <li> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="nc">Day</span> <span class="n">day</span> <span class="o">=</span> <span class="nc">DayDate</span><span class="o">.</span><span class="na">StringToDay</span><span class="o">(</span><span class="nc">String</span> <span class="n">dayName</span><span class="o">);</span>
</code></pre></div> </div> </li> <li>우리는 함수가 ‘Monday’를 Day.MONDAY로 변환하리라 기대한다. 또한 일반적으로 쓰는 요일 약어도 올바로 변환하리라 기대한다.</li> </ul> </li> <li>당연한 동작을 구현하지 않으면 독자는 더 이상 함수 이름만으로 기능을 직관적으로 예상하기 어려워진다.</li> </ul> <h3 id="g3-경계를-올바로-처리하지-않는다"> <a href="#g3-경계를-올바로-처리하지-않는다" class="anchor-heading" aria-labelledby="g3-경계를-올바로-처리하지-않는다"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> <em>G3: 경계를 올바로 처리하지 않는다</em> </h3> <ul> <li>자신의 직관에 의존하지 말고, 부지런히 모든 경계 조건, 모든 예외를 살펴보자.</li> <li><strong>모든 경계 조건을 찾아내고, 그것들을 테스트하는 테스트 케이스를 작성하라.</strong></li> </ul> <h3 id="g4-안전-절차-무시"> <a href="#g4-안전-절차-무시" class="anchor-heading" aria-labelledby="g4-안전-절차-무시"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> <em>G4: 안전 절차 무시</em> </h3> <ul> <li>예를 들어 컴파일러 경고 일부를 꺼버리면 빌드가 쉬워질지 모르지만, 자칫하면 끝없는 디버깅에 시달릴 수 있다.</li> <li>실패하는 테스트 케이스를 일단 제쳐두고 나중에 미루는 태도는 아주 위험하다.</li> </ul> <h3 id="g5-중복"> <a href="#g5-중복" class="anchor-heading" aria-labelledby="g5-중복"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> <em>G5: 중복</em> </h3> <ul> <li><strong>이 책에 나오는 가장 중요한 규칙 중 하나이므로 심각하게 숙고해야 한다.</strong></li> <li>코드에서 중복을 발견할 때마다 추상화할 기회로 간주하라. 중복된 코드를 하위 루틴이나 다른 클래스로 분리하라.</li> <li> <h2 id="어디서든-중복을-발견하면-없애라"> <a href="#어디서든-중복을-발견하면-없애라" class="anchor-heading" aria-labelledby="어디서든-중복을-발견하면-없애라"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> <strong>어디서든 중복을 발견하면 없애라.</strong> </h2> </li> <li><em>유형 1:</em> 똑같은 코드가 여러 차례 나온다. 이런 중복은 간단한 함수로 교체한다.</li> <li><em>유형 2:</em> 여러 모듈에서 분기문으로 똑같은 조건을 거듭 확인하는 중복이다. 이런 중복은 다형성으로 대체해야 한다.</li> <li> <h2 id="유형-3-알고리즘이-유사하나-코드가-서로-다른-중복이다-이는-template-method-패턴이나-strategy-패턴으로-중복을-제거한다"> <a href="#유형-3-알고리즘이-유사하나-코드가-서로-다른-중복이다-이는-template-method-패턴이나-strategy-패턴으로-중복을-제거한다" class="anchor-heading" aria-labelledby="유형-3-알고리즘이-유사하나-코드가-서로-다른-중복이다-이는-template-method-패턴이나-strategy-패턴으로-중복을-제거한다"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> <em>유형 3:</em> 알고리즘이 유사하나 코드가 서로 다른 중복이다. 이는 TEMPLATE METHOD 패턴이나, STRATEGY 패턴으로 중복을 제거한다. </h2> </li> </ul> <h3 id="g6-추상화-수준이-올바르지-못하다"> <a href="#g6-추상화-수준이-올바르지-못하다" class="anchor-heading" aria-labelledby="g6-추상화-수준이-올바르지-못하다"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> <em>G6: 추상화 수준이 올바르지 못하다</em> </h3> <ul> <li>추상화로 개념을 분리할 때는 철저해야 한다. 모든 저차원 개념은 파생 클래스에 넣고, 모든 고차원 개념은 기초 클래스에 넣는다.</li> <li><strong>기초 클래스는 구현 정보에 무지해야 한다.</strong> 예를 들어, 세부 구현과 관련한 상수, 변수, 유틸리티 함수 등은 기초 클래스에 넣으면 안 된다.</li> </ul> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">Stack</span> <span class="o">{</span>
    <span class="nc">Object</span> <span class="nf">pop</span><span class="o">()</span> <span class="kd">throws</span> <span class="nc">EmptyException</span><span class="o">;</span>
    <span class="cm">/* ... */</span>
    <span class="kt">double</span> <span class="nf">percentFull</span><span class="o">();</span>
    <span class="cm">/* ... */</span>
<span class="o">}</span>
</code></pre></div></div> <ul> <li><code class="language-plaintext highlighter-rouge">percentFull()</code>은 추상화 수준이 올바르지 못하다. 이유는 Stack을 구현하는 방법은 다양해, percent full(백분율)이라는 개념은 구현하는 방식에 따라 적합할 수도, 그렇지 않을 수도 있다. <strong>따라서 해당 개념은 특정한 파생 인터페이스에 넣어야 마땅하다.</strong></li> </ul> <h3 id="g7-기초-클래스가-파생-클래스에-의존한다"> <a href="#g7-기초-클래스가-파생-클래스에-의존한다" class="anchor-heading" aria-labelledby="g7-기초-클래스가-파생-클래스에-의존한다"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> <em>G7: 기초 클래스가 파생 클래스에 의존한다</em> </h3> <ul> <li>일반적으로 기초 클래스는 파생 클래스를 아예 몰라야 마땅하다. 고차원 개념을 저차원 개념으로부터 분리하는 것이 기초/파생 클래스를 나누는 이유이기 때문이다.</li> <li>하지만 예외는 있다. 예를 들어 파생 클래스 개수가 확실히 고정되었다면 기초 클래스에 <strong>파생 클래스를 선택하는 코드</strong>가 들어간다. <ul> <li>이러한 경우 기초 클래스와 파생 클래스를 각기 다른 파일로 배포하는 편이 좋다.</li> <li>각기 다른 파일로 배포될 경우, 시스템에서 각기 개별 컴포넌트 단위로 배치할 수 있기 때문이다.</li> </ul> </li> </ul> <h3 id="g8-과도한-정보"> <a href="#g8-과도한-정보" class="anchor-heading" aria-labelledby="g8-과도한-정보"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> <em>G8: 과도한 정보</em> </h3> <ul> <li><strong>잘 정의된 모듈은 인터페이스가 아주 작다.</strong> <strong>부실한 모듈은 구질구질하다.</strong></li> <li>잘 정의된 인터페이스는 많은 함수를 제공하지 않아 결합도가 낮다. 부실한 인터페이스는 <strong>반드시 호출해야 하는 함수들을 제공한다.</strong></li> <li><strong>정보를 제한해 인터페이스를 매우 작게 만들어라. 결합도를 낮추어라.</strong> <ul> <li>자료와 유틸리티 함수를 숨겨라. 상수와 임시 변수를 숨겨라.</li> </ul> </li> </ul> <h3 id="g9-죽은-코드"> <a href="#g9-죽은-코드" class="anchor-heading" aria-labelledby="g9-죽은-코드"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> <em>G9: 죽은 코드</em> </h3> <ul> <li>실행되지 않는 코드를 가리킨다.</li> <li>예를 들어, <ul> <li>불가능한 조건을 확인하는 if, switch/case 문</li> <li>throw 문이 없는 try 문에서 catch 블록</li> </ul> </li> <li>죽은 코드는 설계가 변하거나, 새로운 규칙이나 표기법이 생겨도 제대로 수정되지 않는다.</li> <li>발견 시 제거하라.</li> </ul> <h3 id="g10-수직-분리"> <a href="#g10-수직-분리" class="anchor-heading" aria-labelledby="g10-수직-분리"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> <em>G10: 수직 분리</em> </h3> <ul> <li>변수와 함수는 사용되는 위치에 가깝게 정의한다. 선언한 위치로부터 몇백 줄 아래에서 사용하면 안 된다.</li> <li>비공개 함수는 처음으로 호출한 직후에 정의한다.</li> </ul> <h3 id="g11-일관성-부족"> <a href="#g11-일관성-부족" class="anchor-heading" aria-labelledby="g11-일관성-부족"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> <em>G11: 일관성 부족</em> </h3> <ul> <li>어떤 개념을 특정 방식으로 구현했다면 유사한 개념도 같은 방식으로 구현한다.</li> </ul> <h3 id="g12-잡동사니"> <a href="#g12-잡동사니" class="anchor-heading" aria-labelledby="g12-잡동사니"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> <em>G12: 잡동사니</em> </h3> <ul> <li>아무도 사용하지 않는 변수, 아무도 호출하지 않는 함수, 정보를 제공하지 못하는 주석. 모두 잡동사니이다. 제거해라.</li> </ul> <h3 id="g13-인위적-결합"> <a href="#g13-인위적-결합" class="anchor-heading" aria-labelledby="g13-인위적-결합"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> <em>G13: 인위적 결합</em> </h3> <ul> <li><strong>서로 무관한 개념을 인위적으로 결합하지 않는다.</strong></li> <li><strong>뚜렷한 목적 없이 변수, 상수, 함수를 당장 편한 위치에 넣어버린 결과이다.</strong> 올바른 위치를 고민하자.</li> </ul> <h3 id="g14-기능-욕심"> <a href="#g14-기능-욕심" class="anchor-heading" aria-labelledby="g14-기능-욕심"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> <em>G14: 기능 욕심</em> </h3> <ul> <li>클래스 메서드는 자기 클래스의 변수와 함수에 관심을 가져야지 다른 클래스의 변수와 함수에 관심을 가져서는 안 된다.</li> <li>메서드가 다른 객체의 내용을 조작하는 것은, 그 객체 클래스의 범위를 욕심내는 것이다.</li> <li> <p>기능 욕심은 한 클래스의 속사정을 다른 클래스에 노출하므로, 별다른 문제가 없다면 제거하는 편이 좋다.</p> </li> <li>다음은 기능 욕심에 관한 예제이다.</li> </ul> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">HourlyPayCalculator</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">Money</span> <span class="nf">calculateWeeklyPay</span><span class="o">(</span><span class="nc">HourlyEmployee</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">tenthRate</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="na">getTenthRate</span><span class="o">().</span><span class="na">getPennies</span><span class="o">();</span>
        <span class="kt">int</span> <span class="n">tenthsWorked</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="na">getTenthsWorked</span><span class="o">();</span>

        <span class="kt">int</span> <span class="n">straightTime</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="mi">400</span><span class="o">,</span> <span class="n">tenthsWorked</span><span class="o">);</span>
        <span class="kt">int</span> <span class="n">overTime</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="n">tenthsWorked</span> <span class="o">-</span> <span class="n">straightTime</span><span class="o">);</span>
        <span class="kt">int</span> <span class="n">straightPay</span> <span class="o">=</span> <span class="n">straightTime</span> <span class="o">*</span> <span class="n">tenthRate</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">overtimePay</span> <span class="o">=</span> <span class="o">(</span><span class="kt">int</span><span class="o">)</span> <span class="nc">Math</span><span class="o">.</span><span class="na">round</span><span class="o">(</span><span class="n">overTime</span> <span class="o">*</span> <span class="n">tenthRate</span> <span class="o">*</span> <span class="mf">1.5</span><span class="o">);</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">Money</span><span class="o">(</span><span class="n">straightPay</span> <span class="o">+</span> <span class="n">overtimePay</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">calculateWeeklyPay</code> 메서드는 <code class="language-plaintext highlighter-rouge">HourlyEmployee</code> 객체에서 온갖 정보를 가져온다. 즉, <code class="language-plaintext highlighter-rouge">calculateWeeklyPay</code> 메서드는 <code class="language-plaintext highlighter-rouge">HourlyEmployee</code> 클래스의 범위를 욕심 낸다.</p> <h3 id="g15-선택자-인수"> <a href="#g15-선택자-인수" class="anchor-heading" aria-labelledby="g15-선택자-인수"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> <em>G15: 선택자 인수</em> </h3> <ul> <li>선택자 인수는 큰 함수를 작은 함수 여럿으로 쪼개지 않으려는 게으름의 소산이다. 다음 코드를 살펴보자.</li> </ul> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kt">int</span> <span class="nf">calculateWeeklyPay</span><span class="o">(</span><span class="kt">boolean</span> <span class="n">overtime</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">tenthRate</span> <span class="o">=</span> <span class="n">getTenthRate</span><span class="o">();</span>
    <span class="kt">int</span> <span class="n">tenthsWorked</span> <span class="o">=</span> <span class="n">getTenthsWorked</span><span class="o">();</span>
    <span class="kt">int</span> <span class="n">straightTime</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="mi">400</span><span class="o">,</span> <span class="n">tenthsWorked</span><span class="o">);</span>
    <span class="kt">int</span> <span class="n">overTime</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="n">tenthsWorked</span> <span class="o">-</span> <span class="n">straightTime</span><span class="o">);</span>
    <span class="kt">int</span> <span class="n">straightPay</span> <span class="o">=</span> <span class="n">straightTime</span> <span class="o">*</span> <span class="n">tenthRate</span><span class="o">;</span>
    <span class="kt">double</span> <span class="n">overtimeRate</span> <span class="o">=</span> <span class="n">overtime</span> <span class="o">?</span> <span class="mf">1.5</span> <span class="o">:</span> <span class="mf">1.0</span> <span class="o">*</span> <span class="n">tenthRate</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">overtimePay</span> <span class="o">=</span> <span class="o">(</span><span class="kt">int</span><span class="o">)</span> <span class="nc">Math</span><span class="o">.</span><span class="na">round</span><span class="o">(</span><span class="n">overTime</span> <span class="o">*</span> <span class="n">overtimeRate</span><span class="o">);</span>
    <span class="k">return</span> <span class="n">straightPay</span> <span class="o">+</span> <span class="n">overtimePay</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div> <ul> <li> <p>독자는 <code class="language-plaintext highlighter-rouge">calculateWeeklyPay(false)</code>라는 코드를 발견할 때마다 인수의 의미를 떠올리느라 골치를 앓는다.</p> </li> <li>enum, int 등 함수 동작을 제어하려는 인수 또한 바람직 하지 않다.</li> <li><strong>인수를 넘겨 동작을 선택하는 대신, 새로운 함수를 만드는 편이 좋다.</strong></li> </ul> <h3 id="g16-모호한-의도"> <a href="#g16-모호한-의도" class="anchor-heading" aria-labelledby="g16-모호한-의도"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> <em>G16: 모호한 의도</em> </h3> <ul> <li>코드를 짤 때는 의도르르 최대한 분명히 밝힌다.</li> <li>행을 바꾸지 않는 수식, 헝가리식 표기법, 매직 번호 등은 모두 저자의 의도를 흐린다.</li> </ul> <h3 id="g17-잘못-지운-책임"> <a href="#g17-잘못-지운-책임" class="anchor-heading" aria-labelledby="g17-잘못-지운-책임"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> <em>G17: 잘못 지운 책임</em> </h3> <ul> <li>코드를 배치하는 기준은 <strong>독자가 자연스럽게 기대할 만한 곳이다.</strong> 이는 역시 최소 놀람의 원칙을 적용한다.</li> </ul> <h3 id="g18-부적절한-static-함수"> <a href="#g18-부적절한-static-함수" class="anchor-heading" aria-labelledby="g18-부적절한-static-함수"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> <em>G18: 부적절한 static 함수</em> </h3> <ul> <li><code class="language-plaintext highlighter-rouge">Math.max()</code> 는 좋은 <code class="language-plaintext highlighter-rouge">static</code> 메서드다. <strong>메서드를 소유하는 객체에서 가져오는 정보가 아니며, 해당 메서드를 재정의할 가능성이 없기 때문이다.</strong></li> <li>하지만 다음 예를 살펴보자. <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="nc">HourlyPayCalculator</span><span class="o">.</span><span class="na">calculatePay</span><span class="o">(</span><span class="n">employee</span><span class="o">,</span> <span class="n">overtimeRate</span><span class="o">);</span>
</code></pre></div> </div> <p>언뜻보면 적절해보이지만, 함수를 재정의할 가능성이 존재한다. 혹은 수당을 계산하는 알고리즘이 여러 개일 수도 있다.</p> </li> <li>일반적으로 <code class="language-plaintext highlighter-rouge">static</code> 함수보다 인스턴스 함수가 더 좋다. <code class="language-plaintext highlighter-rouge">static</code> 함수를 정의해야 할 때는 재정의할 가능성이 없는지 살펴보자.</li> </ul><hr /> <p><em>다음 목록부터는 휴리스틱을 중점적으로 다룬다.</em></p> <blockquote> <p>휴리스틱은 복잡하거나 불확실한 문제 상황에서, 제한된 시간이나 정보로 인해 합리적이고 체계적인 판단이 어렵거나 굳이 필요하지 않을 때 사용하는 간편하고 실용적인 문제 해결 방법 또는 추론 전략 이다.</p> </blockquote> <h3 id="g19-서술적-변수"> <a href="#g19-서술적-변수" class="anchor-heading" aria-labelledby="g19-서술적-변수"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> <em>G19: 서술적 변수</em> </h3> <ul> <li>프로그램 가독성을 높이는 가장 효과적인 방법 중 하나가 계산을 여러 단계로 나누고 중간 값으로 서술적인 변수 이름을 사용하는 방법이다. <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Matcher</span> <span class="n">match</span> <span class="o">=</span> <span class="n">headerPattern</span><span class="o">.</span><span class="na">matcher</span><span class="o">(</span><span class="n">line</span><span class="o">);</span>
<span class="k">if</span><span class="o">(</span><span class="n">match</span><span class="o">.</span><span class="na">find</span><span class="o">())</span>
<span class="o">{</span>
  <span class="nc">String</span> <span class="n">key</span> <span class="o">=</span> <span class="n">match</span><span class="o">.</span><span class="na">group</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>
  <span class="nc">String</span> <span class="n">value</span> <span class="o">=</span> <span class="n">match</span><span class="o">.</span><span class="na">group</span><span class="o">(</span><span class="mi">2</span><span class="o">);</span>
  <span class="n">headers</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">key</span><span class="o">.</span><span class="na">toLowerCase</span><span class="o">(),</span> <span class="n">value</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div> </div> </li> <li>서술적인 이름을 사용한 탓에 <code class="language-plaintext highlighter-rouge">key</code> 와 <code class="language-plaintext highlighter-rouge">value</code> 로 원하는 정보가 명확하게 드러난다.</li> </ul> <h3 id="g20-이름과-기능이-일치하는-함수"> <a href="#g20-이름과-기능이-일치하는-함수" class="anchor-heading" aria-labelledby="g20-이름과-기능이-일치하는-함수"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> <em>G20: 이름과 기능이 일치하는 함수</em> </h3> <ul> <li>이름만으로 분명하지 않은 함수는 구현을 살펴보거나 문서를 뒤적여야 한다.</li> <li>기능을 정확하게 표현하는 이름을 짓는다.</li> </ul> <h3 id="g21-알고리즘을-이해하라"> <a href="#g21-알고리즘을-이해하라" class="anchor-heading" aria-labelledby="g21-알고리즘을-이해하라"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> <em>G21: 알고리즘을 이해하라</em> </h3> <ul> <li><strong>구현이 끝났다고 선언하기 전에 함수가 돌아가는 방식을 확실히 이해하는 지 확인하라.</strong> 이것은 테스트 케이스를 모두 통과하는 것과는 별개의 이야기이다. <h3 id="g22-논리적-의존성은-물리적으로-드러내라"> <a href="#g22-논리적-의존성은-물리적으로-드러내라" class="anchor-heading" aria-labelledby="g22-논리적-의존성은-물리적으로-드러내라"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> <em>G22: 논리적 의존성은 물리적으로 드러내라</em> </h3> </li> <li> <p>의존하는 모듈이 상대 모듈에 대해 뭔가를 가정하면 안된다. 의존하는 모든 정보를 명시적으로 요청하는 편이 좋다.</p> </li> <li>예를 들어, 근무시간 보고서를 가공되지 않은 상태로 출력하는 함수를 구현한다고 가정하자. <code class="language-plaintext highlighter-rouge">HourlyReporter</code>라는 클래스는 모든 정보를 모아 <code class="language-plaintext highlighter-rouge">HourlyReportFormatter</code>에 적당한 형태를 넘긴다. <code class="language-plaintext highlighter-rouge">HourlyReportFormatter</code>는 넘어온 정보를 출력한다.</li> </ul> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">HourlyReporter</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">HourlyReportFormatter</span> <span class="n">formatter</span><span class="o">;</span>
    <span class="kd">private</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">LineItem</span><span class="o">&gt;</span> <span class="n">page</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="kt">int</span> <span class="no">PAGE_SIZE</span> <span class="o">=</span> <span class="mi">55</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">HourlyReporter</span><span class="o">(</span><span class="nc">HourlyReportFormatter</span> <span class="n">formatter</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">formatter</span> <span class="o">=</span> <span class="n">formatter</span><span class="o">;</span>
        <span class="n">page</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">LineItem</span><span class="o">&gt;();</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">generateReport</span><span class="o">(</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">HourlyEmployee</span><span class="o">&gt;</span> <span class="n">employees</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">for</span> <span class="o">(</span><span class="nc">HourlyEmployee</span> <span class="n">e</span> <span class="o">:</span> <span class="n">employees</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">addLineItemToPage</span><span class="o">(</span><span class="n">e</span><span class="o">);</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">page</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">==</span> <span class="no">PAGE_SIZE</span><span class="o">)</span>
                <span class="n">printAndClearItemList</span><span class="o">();</span>
        <span class="o">}</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">page</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span>
            <span class="n">printAndClearItemList</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">printAndClearItemList</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">formatter</span><span class="o">.</span><span class="na">format</span><span class="o">(</span><span class="n">page</span><span class="o">);</span>
        <span class="n">page</span><span class="o">.</span><span class="na">clear</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">addLineItemToPage</span><span class="o">(</span><span class="nc">HourlyEmployee</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">LineItem</span> <span class="n">item</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LineItem</span><span class="o">();</span>
        <span class="n">item</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="na">getName</span><span class="o">();</span>
        <span class="n">item</span><span class="o">.</span><span class="na">hours</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="na">getTenthsWorked</span><span class="o">()</span> <span class="o">/</span> <span class="mi">10</span><span class="o">;</span>
        <span class="n">item</span><span class="o">.</span><span class="na">tenths</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="na">getTenthsWorked</span><span class="o">()</span> <span class="o">%</span> <span class="mi">10</span><span class="o">;</span>
        <span class="n">page</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">item</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">class</span> <span class="nc">LineItem</span> <span class="o">{</span>
        <span class="kd">public</span> <span class="nc">String</span> <span class="n">name</span><span class="o">;</span>
        <span class="kd">public</span> <span class="kt">int</span> <span class="n">hours</span><span class="o">;</span>
        <span class="kd">public</span> <span class="kt">int</span> <span class="n">tenths</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div> <p>위에서 논리적인 의존성은 <code class="language-plaintext highlighter-rouge">PAGE_SIZE</code> 이다. <code class="language-plaintext highlighter-rouge">HourlyReporter</code>가 페이지의 크기를 알 필요는 없다. 페이지 크기는 <code class="language-plaintext highlighter-rouge">HourlyReportFormatter</code>가 책임질 정보다. 이는 잘못 지운 책임에 해당된다.</p> <p><code class="language-plaintext highlighter-rouge">HourlyReportFormatter</code> 에 <code class="language-plaintext highlighter-rouge">getMaxPageSize()</code> 라는 메서드를 추가하면 논리적인 의존성이 물리적인 의존성으로 변한다.</p> <h3 id="g23-ifelse-혹은-switchcase-문보다-다형성을-사용하라"> <a href="#g23-ifelse-혹은-switchcase-문보다-다형성을-사용하라" class="anchor-heading" aria-labelledby="g23-ifelse-혹은-switchcase-문보다-다형성을-사용하라"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> <em>G23: If/Else 혹은 Switch/Case 문보다 다형성을 사용하라</em> </h3> <ul> <li>대부분 <code class="language-plaintext highlighter-rouge">switch/case</code> 문을 선택하는 이유는 <strong>당장 가장 손쉬운 선택이기 때문</strong> 이다. 그러므로 먼저 다형성을 고려해보자.</li> <li>선택 유형 하나에는 <code class="language-plaintext highlighter-rouge">switch</code> 문을 한번만 사용한다.</li> <li>같은 선택을 수행하는 다른 코드에서는 다형성 객체를 생성해 <code class="language-plaintext highlighter-rouge">switch</code> 문을 대신한다.</li> </ul> <h3 id="g24-표준-표기법을-따르라"> <a href="#g24-표준-표기법을-따르라" class="anchor-heading" aria-labelledby="g24-표준-표기법을-따르라"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> <em>G24: 표준 표기법을 따르라</em> </h3> <ul> <li>팀은 업계 표준에 기반한 구현 표준을 따라야 한다.</li> <li>팀이 정한 표준은 팀원들 모두가 따라야 한다.</li> </ul> <h3 id="g25-매직-숫자는-명명된-상수로-교체하라"> <a href="#g25-매직-숫자는-명명된-상수로-교체하라" class="anchor-heading" aria-labelledby="g25-매직-숫자는-명명된-상수로-교체하라"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> <em>G25: 매직 숫자는 명명된 상수로 교체하라</em> </h3> <ul> <li>이미 오래된 규칙이다. 코드에서 숫자를 사용하지 말라는 규칙이다.</li> <li>매직 숫자는 단순히 숫자만 의미하지 않는다. 의미가 분명하지 않은 토큰을 모두 가리킨다. <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="n">assertEquals</span><span class="o">(</span><span class="mi">7777</span><span class="o">,</span> <span class="nc">Employee</span><span class="o">.</span><span class="na">find</span><span class="o">(</span><span class="s">"John Doe"</span><span class="o">).</span><span class="na">employeeNumber</span><span class="o">());</span>
</code></pre></div> </div> <p>위 코드에서 매직 숫자는 “7777”, “John Doe” 이다. 둘 다 의미가 분명하지 않기 때문이다. 다음과 같이 수정해보자.</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="n">assertEqulas</span><span class="o">(</span><span class="no">HOURLY_EMPLOYEE_ID</span><span class="o">,</span> <span class="nc">Employee</span><span class="o">.</span><span class="na">find</span><span class="o">(</span><span class="no">HOURLY_EMPLOYEE_NAME</span><span class="o">).</span><span class="na">employeeNumber</span><span class="o">());</span>
</code></pre></div> </div> </li> </ul> <h3 id="g26-정확하라"> <a href="#g26-정확하라" class="anchor-heading" aria-labelledby="g26-정확하라"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> <em>G26: 정확하라</em> </h3> <ul> <li><strong>코드에서 뭔가를 결정할 때는 정확히 결정한다. 결정을 내리는 이유와 예외를 처리할 방법을 분명히 알아야 한다.</strong></li> <li>예를 들어, <ul> <li>호출하는 함수가 null 을 반환할지 모른다면 null 을 반드시 점검한다.</li> <li>조회 결과가 하나뿐이라고 짐작한다면 하나인지 확실히 확인한다.</li> <li>동시에 갱신할 가능성이 있다면 적절한 잠금 매커니즘을 구현한다.</li> </ul> </li> </ul> <h3 id="g27-관례보다-구조를-사용하라"> <a href="#g27-관례보다-구조를-사용하라" class="anchor-heading" aria-labelledby="g27-관례보다-구조를-사용하라"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> <em>G27: 관례보다 구조를 사용하라</em> </h3> <ul> <li>설계 결정을 강제할 때는 규칙보다 관례를 사용한다.</li> <li>예를 들어, enum 변수가 멋진 switch/case 문보다 추상 메서드가 있는 기초 클래스 가 더 좋다.</li> <li>switch/case 문을 매번 똑같이 구현하게 강제하기는 어렵지만, 파생 클래스는 추상 메서드를 모두 구현하지 않으면 안 되기 때문이다.</li> </ul> <h3 id="_g28-조건을-캡슐화하라"> <a href="#_g28-조건을-캡슐화하라" class="anchor-heading" aria-labelledby="_g28-조건을-캡슐화하라"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> _G28: 조건을 캡슐화하라 </h3> <ul> <li>부울 논리는 이해하기 어렵다. 조건의 의도를 분명히 밝히는 함수로 표현하라.</li> <li>예를 들어, <ul> <li> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="k">if</span> <span class="o">(</span><span class="n">shouldBeDeleted</span><span class="o">(</span><span class="n">timer</span><span class="o">))</span>
</code></pre></div> </div> <p>라는 코드는 다음 코드보다 좋다.</p> </li> <li> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">if</span> <span class="o">(</span><span class="n">timer</span><span class="o">.</span><span class="na">hasExpired</span><span class="o">()</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">timer</span><span class="o">.</span><span class="na">isRecurrent</span><span class="o">())</span>
</code></pre></div> </div> </li> </ul> </li> </ul> <h3 id="g29-부정-조건은-피하라"> <a href="#g29-부정-조건은-피하라" class="anchor-heading" aria-labelledby="g29-부정-조건은-피하라"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> <em>G29: 부정 조건은 피하라</em> </h3> <ul> <li>부정 조건은 긍정 조건보다 이해하기 어렵다. 가능하면 긍정 조건으로 표현한다.</li> <li>예를 들어, <ul> <li> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">if</span> <span class="o">(</span><span class="n">buffer</span><span class="o">.</span><span class="na">shouldCompact</span><span class="o">())</span>
</code></pre></div> </div> <p>라는 코드가 아래 코드보다 좋다.</p> </li> <li> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">if</span> <span class="o">(!</span><span class="n">buffer</span><span class="o">.</span><span class="na">shouldNotCompact</span><span class="o">())</span>
</code></pre></div> </div> </li> </ul> </li> </ul> <h3 id="g30-함수는-한-가지만-해야-한다"> <a href="#g30-함수는-한-가지만-해야-한다" class="anchor-heading" aria-labelledby="g30-함수는-한-가지만-해야-한다"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> <em>G30: 함수는 한 가지만 해야 한다</em> </h3> <ul> <li>함수를 짜다 보면, 한 함수안에서 일련의 작업을 수행하고픈 유혹에 빠진다. 하지만 이는 각각의 작업을 담당하는 여럿의 함수로 나누어야한다. <h3 id="g31-숨겨진-시간적인-결합"> <a href="#g31-숨겨진-시간적인-결합" class="anchor-heading" aria-labelledby="g31-숨겨진-시간적인-결합"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> <em>G31: 숨겨진 시간적인 결합</em> </h3> </li> <li>때로는 시간적인 결합이 필요하다. 함수를 짤 때는 함수 인수를 적절히 배치해 함수가 호출되는 순서를 명백히 드러낸다. 다음 코드를 살펴보자.</li> </ul> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">MoogDiver</span> <span class="o">{</span>
    <span class="nc">Gradient</span> <span class="n">gradient</span><span class="o">;</span>
    <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Spline</span><span class="o">&gt;</span> <span class="n">splines</span><span class="o">;</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">dive</span><span class="o">(</span><span class="nc">String</span> <span class="n">reason</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">saturatedGradient</span><span class="o">();</span>
        <span class="n">reticulateSplines</span><span class="o">();</span>
        <span class="n">diverForMoog</span><span class="o">(</span><span class="n">reason</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="o">...</span>
<span class="o">}</span>
</code></pre></div></div> <p>위 코드에서는 세 함수가 실행되는 순서가 중요하다.</p> <p>먼저 <code class="language-plaintext highlighter-rouge">gradient</code>를 처리하기 위해 <code class="language-plaintext highlighter-rouge">saturatedGradient()</code>를 호출하고 나서, <code class="language-plaintext highlighter-rouge">reticulateSplines()</code>를, 마지막으로 <code class="language-plaintext highlighter-rouge">diverForMoog()</code>를 수행한다.</p> <p>하지만 위의 코드는 시간적인 결합을 강제하지 않는다. 따라서, 도중에 오류가 발생해도 막을 도리가 없다. 다음 코드가 더 좋다.</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">MoogDiver</span> <span class="o">{</span>
    <span class="nc">Gradient</span> <span class="n">gradient</span><span class="o">;</span>
    <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Spline</span><span class="o">&gt;</span> <span class="n">splines</span><span class="o">;</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">dive</span><span class="o">(</span><span class="nc">String</span> <span class="n">reason</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Gradient</span> <span class="n">gradient</span> <span class="o">=</span> <span class="n">saturateGradient</span><span class="o">();</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Spline</span><span class="o">&gt;</span> <span class="n">splines</span><span class="o">.</span> <span class="o">=</span> <span class="n">reticulateSplines</span><span class="o">(</span><span class="n">gradient</span><span class="o">);</span>
        <span class="n">diveForMoog</span><span class="o">(</span><span class="nc">Splines</span><span class="o">,</span> <span class="n">reason</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <p>위 코드는 함수의 인자를 일종의 연결 소자로써 사용하여 시간적인 결합을 노출한다.</p> <h3 id="g32-일관성을-유지하라"> <a href="#g32-일관성을-유지하라" class="anchor-heading" aria-labelledby="g32-일관성을-유지하라"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> <em>G32: 일관성을 유지하라</em> </h3> <ul> <li><strong>코드 구조를 잡을 때는 이유를 고민하라. 그리고 그 이유를 코드 구조로 명백히 표현하라.</strong></li> <li>시스템 전반에 걸친 구조가 일관성이 있다면, 남도 일관성을 따르고 보존한다.</li> </ul> <h3 id="g33-경계-조건을-캡슐화하라"> <a href="#g33-경계-조건을-캡슐화하라" class="anchor-heading" aria-labelledby="g33-경계-조건을-캡슐화하라"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> <em>G33: 경계 조건을 캡슐화하라</em> </h3> <ul> <li>경계 조건은 별도로 한곳에서 처리한다. <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span><span class="o">(</span><span class="n">level</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="n">tags</span><span class="o">.</span><span class="na">length</span><span class="o">&gt;)</span>
<span class="o">{</span>
  <span class="n">parts</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Parse</span><span class="o">(</span><span class="n">body</span><span class="o">,</span> <span class="n">tags</span><span class="o">,</span> <span class="n">level</span> <span class="o">+</span> <span class="mi">1</span><span class="o">,</span> <span class="n">offset</span> <span class="o">+</span> <span class="n">endTag</span><span class="o">);</span>
  <span class="n">body</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div> </div> </li> </ul> <p>위의 코드에서 <code class="language-plaintext highlighter-rouge">level + 1</code> 은 여기 저기에 나온다. 이러한 경계 조건은 캡슐화하는 편이 좋다.</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">nextLevel</span> <span class="o">=</span> <span class="n">level</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
<span class="k">if</span><span class="o">(</span><span class="n">nextLevel</span> <span class="o">&lt;</span> <span class="n">tags</span><span class="o">.</span><span class="na">length</span><span class="o">)</span>
<span class="o">{</span>
    <span class="n">parts</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Parse</span><span class="o">(</span><span class="n">body</span><span class="o">,</span> <span class="n">tags</span><span class="o">,</span> <span class="n">nextLevel</span><span class="o">,</span> <span class="n">offset</span> <span class="o">+</span> <span class="n">endTag</span><span class="o">);</span>
    <span class="n">body</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div> <h3 id="g34-함수는-추상화-수준을-한-단계만-내려가야-한다"> <a href="#g34-함수는-추상화-수준을-한-단계만-내려가야-한다" class="anchor-heading" aria-labelledby="g34-함수는-추상화-수준을-한-단계만-내려가야-한다"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> <em>G34: 함수는 추상화 수준을 한 단계만 내려가야 한다</em> </h3> <ul> <li>함수 내 모든 문장은 추상화 수준이 동일해야 한다. 그리고 그 수준은 함수 이름이 의미하는 작업보다 한 단계 더 낮아야 한다.(작업이 더 구체적이어야 한다.)</li> <li>함수에서 추상화 수준을 분리하면 드러나지 않았던 새로운 추상화 수준이 드러나는 경우가 빈번하다.</li> </ul> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="nc">String</span> <span class="nf">render</span><span class="o">()</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
    <span class="nc">StringBuffer</span> <span class="n">html</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringBuffer</span><span class="o">(</span><span class="s">"&lt;hr"</span><span class="o">);</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">html</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="s">" size=\""</span><span class="o">).</span><span class="na">append</span><span class="o">(</span><span class="n">size</span> <span class="o">+</span> <span class="mi">1</span><span class="o">).</span><span class="na">append</span><span class="o">(</span><span class="s">"\""</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="n">html</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="s">"&gt;"</span><span class="o">);</span>

    <span class="k">return</span> <span class="n">html</span><span class="o">.</span><span class="na">toString</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div></div> <p>위 함수에는 추상화 수준이 최소한 두 개가 섞여 있다. 첫째는 수평선에 크기가 있다는 개념이다. 둘째는 HR 태그 자체의 문법이다.</p> <p>위 코드를 다음과 같이 수정해보자. <code class="language-plaintext highlighter-rouge">size</code> 변수 이름은 목적을 반영하게 적절히 변경했다. <code class="language-plaintext highlighter-rouge">size</code> 변수는 추가된 대시 개수를 저장한다. <code class="language-plaintext highlighter-rouge">render</code>함수는 <code class="language-plaintext highlighter-rouge">HR</code> 태그만 생성하며, 구체적인 문법은 전혀 상관하지 않는다. 추상화 수준을 분리되었다.</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="nc">String</span> <span class="nf">render</span><span class="o">()</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
    <span class="nc">HtmlTag</span> <span class="n">hr</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HtmlTag</span><span class="o">(</span><span class="s">"hr"</span><span class="o">);</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">extraDashes</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">hr</span><span class="o">.</span><span class="na">addAttribute</span><span class="o">(</span><span class="s">"size"</span><span class="o">,</span> <span class="n">hrSize</span><span class="o">(</span><span class="n">extraDashes</span><span class="o">));</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">hr</span><span class="o">.</span><span class="na">html</span><span class="o">();</span>
<span class="o">}</span>

<span class="kd">private</span> <span class="nc">String</span> <span class="nf">hrSize</span><span class="o">(</span><span class="kt">int</span> <span class="n">height</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">hrSize</span> <span class="o">=</span> <span class="n">height</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
    <span class="k">return</span> <span class="nc">String</span><span class="o">.</span><span class="na">format</span><span class="o">(</span><span class="s">"%d"</span><span class="o">,</span> <span class="n">hrSize</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div> <h3 id="g35-설정-정보는-최상위-단계에-둬라"> <a href="#g35-설정-정보는-최상위-단계에-둬라" class="anchor-heading" aria-labelledby="g35-설정-정보는-최상위-단계에-둬라"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> <em>G35: 설정 정보는 최상위 단계에 둬라</em> </h3> <ul> <li>추상화 최상위 단계에 둬야 할 기본값 상수나 설정 관련 상수를 저차원 함수에 숨겨서는 안 된다. <ul> <li><strong>대신 고차원 함수에서 저차원 함수를 호출할 때 인수로 넘긴다.</strong></li> </ul> </li> <li>설정 정보를 최상위 단계에 둬야 찾기도, 변경하기도 쉽다. ```java public static void main(String [] args) throws Exception { Arguments arguments = parseCommandLine(args); … }</li> </ul> <p>public class Arguments { // 설정 정보 public static final String DEFAULT_APTH = “.”; public static final String default_root = “FitNesseRoot”; … }</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
### _G36: 추이적 탐색을 피하라_
- 일반적으로 한 모듈은 주변 모듈을 모를수록 좋다.
- A가 B를 사용하고, B가 C를 사용한다 해서, A가 C를 알아야 할 필요는 없다는 뜻이다.
    - 이를 디미터 법칙이라고 부른다.
- 여러 모듈에서 `a.getB().getC()` 라는 형태를 사용한다면 설계와 아키텍처를 바꿔 B와 C사이에 Q를 넣기 쉽지않다.
- 원하는 기능을 찾아 객체를 따라 시스템 전체를 탐색할 필요가 없어야 한다.

## 자바

### _J1: 긴 import 목록을 피하고 와일드 카드를 사용하라_
- 패키지에서 클래스를 둘 이상 사용한다면 와일드카드를 사용해 패키지 전체를 가져오라.
    - 명시적으로 사용하는 import 문은 강한 의존성을 생성하지만, 와일드카드는 그렇지 않다.
```java
import package.*;
</code></pre></div></div> <ul> <li>와일드카드가 이름 충돌이나 모호성을 초래할 경우에는 명시적으로 import 문을 사용한다. 아니면 코드에서 클래스를 사용할 때 전체 경로를 명시한다.</li> </ul> <h3 id="j2-상수는-상속하지-않는다"> <a href="#j2-상수는-상속하지-않는다" class="anchor-heading" aria-labelledby="j2-상수는-상속하지-않는다"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> <em>J2: 상수는 상속하지 않는다</em> </h3> <ul> <li>상수를 상속하는 것은 언어의 범위 규칙을 속이는 행위다.</li> <li>대신 <code class="language-plaintext highlighter-rouge">static import</code> 를 사용하라.</li> </ul> <h3 id="j3-상수-대-enum"> <a href="#j3-상수-대-enum" class="anchor-heading" aria-labelledby="j3-상수-대-enum"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> <em>J3: 상수 대 Enum</em> </h3> <ul> <li><code class="language-plaintext highlighter-rouge">enum</code>은 이름이 부여된 열거체에 속한다.</li> <li>메서드와 필드도 사용할 수 있다. int 보다 훨씬 더 유연하고 <strong>서술적인</strong> 강력한 도구다. 맘껏 사용하라.</li> </ul> <h2 id="이름"> <a href="#이름" class="anchor-heading" aria-labelledby="이름"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 이름 </h2> <h3 id="n1-서술적인-이름을-사용하라"> <a href="#n1-서술적인-이름을-사용하라" class="anchor-heading" aria-labelledby="n1-서술적인-이름을-사용하라"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> N1: 서술적인 이름을 사용하라 </h3> <ul> <li>소프트웨어 가독성의 90%는 이름이 결정한다. 그러니 이름을 정할 때는 시간을 들여 현명하게 선택한다.</li> <li>신중하게 선택한 이름은 추가 설명이 필요하지 않다. <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">private</span> <span class="kt">boolean</span> <span class="nf">isStrike</span><span class="o">(</span><span class="kt">int</span> <span class="n">frame</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">return</span> <span class="n">rolls</span><span class="o">[</span><span class="n">frame</span><span class="o">]</span> <span class="o">==</span> <span class="mi">10</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div> </div> <h3 id="n2-적절한-추상화-수준에서-이름을-선택하라"> <a href="#n2-적절한-추상화-수준에서-이름을-선택하라" class="anchor-heading" aria-labelledby="n2-적절한-추상화-수준에서-이름을-선택하라"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> N2: 적절한 추상화 수준에서 이름을 선택하라 </h3> </li> <li><strong>구현을 드러내는 이름은 피하라.</strong></li> <li>작업 대상 클래스나 함수가 위치하는 추상화 수준을 반영하는 이름을 선택하라.</li> </ul> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">Modem</span> <span class="o">{</span>
    <span class="kt">boolean</span> <span class="nf">dial</span><span class="o">(</span><span class="nc">String</span> <span class="n">phoneNumber</span><span class="o">);</span>
    <span class="kt">boolean</span> <span class="nf">disconnect</span><span class="o">();</span>
    <span class="kt">boolean</span> <span class="nf">send</span><span class="o">(</span><span class="kt">char</span> <span class="n">c</span><span class="o">);</span>
    <span class="kt">char</span> <span class="nf">recv</span><span class="o">();</span>
    <span class="nc">String</span> <span class="nf">getConnectedPhoneNumber</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">Modem</code> 관련 인터페이스이다. 얼핏 문제 없어 보이지만 전화선에 일부 연결되지 않는 모뎀을 생각해보자. 그렇다면 전화번호라는 개념은 추상화 수준이 틀렸다. 다음과 같이 수정하면, 연결 대상은 전화로 제한되지 않는다.</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">Modem</span> <span class="o">{</span>
    <span class="kt">boolean</span> <span class="nf">connect</span><span class="o">(</span><span class="nc">String</span> <span class="n">connectionLocator</span><span class="o">);</span>
    <span class="kt">boolean</span> <span class="nf">disconnect</span><span class="o">();</span>
    <span class="kt">boolean</span> <span class="nf">send</span><span class="o">(</span><span class="kt">char</span> <span class="n">c</span><span class="o">);</span>
    <span class="kt">char</span> <span class="nf">recv</span><span class="o">();</span>
    <span class="nc">String</span> <span class="nf">getConnectedPhoneNumber</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div></div> <h3 id="n3-가능하다면-표준-명명법을-사용하라"> <a href="#n3-가능하다면-표준-명명법을-사용하라" class="anchor-heading" aria-labelledby="n3-가능하다면-표준-명명법을-사용하라"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> <em>N3: 가능하다면 표준 명명법을 사용하라</em> </h3> <ul> <li>예를 들어, <code class="language-plaintext highlighter-rouge">DECORATOR</code> 패턴을 활용하는 클래스 이름에는 <code class="language-plaintext highlighter-rouge">Decorator</code>라는 단어를 사용해야 한다.</li> <li>패턴은 한 가지 표준에 불과하다. 이러한 경우 이름은 관례에 따르는 편이 좋다.</li> <li><strong>프로젝트에 유효한 의미가 담긴 이름을 많이 사용할수록 독자가 코드를 이해하기 쉬워진다.</strong></li> </ul> <h3 id="n4-명확한-이름"> <a href="#n4-명확한-이름" class="anchor-heading" aria-labelledby="n4-명확한-이름"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> <em>N4: 명확한 이름</em> </h3> <ul> <li>함수나 변수의 목적을 명확히 밝히는 이름을 선택한다.</li> <li>길어도 좋으며, 길다는 단점은 서술성이 충분히 메꿀수 있다. <h3 id="n5-긴-범위는-긴-이름을-사용하라"> <a href="#n5-긴-범위는-긴-이름을-사용하라" class="anchor-heading" aria-labelledby="n5-긴-범위는-긴-이름을-사용하라"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> <em>N5: 긴 범위는 긴 이름을 사용하라</em> </h3> </li> <li><strong>이름 길이는 범위 길이에 비례해야 한다.</strong> 범위가 작으면 아주 짧은 이름을 사용해도 괜찮다. 하지만 범위가 길어지면 긴 이름을 사용한다.</li> <li>이름범위가 길어질 수록 이름을 정확하고 길게 짓는다.</li> <li>범위가 5줄 안팎이라면 <code class="language-plaintext highlighter-rouge">i</code>나 <code class="language-plaintext highlighter-rouge">j</code>와 같은 변수 이름도 괜찮다.</li> </ul> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">private</span> <span class="kt">void</span> <span class="nf">rollMany</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">,</span> <span class="kt">int</span> <span class="n">pins</span><span class="o">)</span>
<span class="o">{</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span>
        <span class="n">g</span><span class="o">.</span><span class="na">roll</span><span class="o">(</span><span class="n">pins</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div> <p>만일 <code class="language-plaintext highlighter-rouge">i</code> 대신 <code class="language-plaintext highlighter-rouge">rollCount</code>라고 썼다면 더 헷갈렸을 것이다.</p> <h3 id="n6-인코딩을-피하라"> <a href="#n6-인코딩을-피하라" class="anchor-heading" aria-labelledby="n6-인코딩을-피하라"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> <em>N6: 인코딩을 피하라</em> </h3> <ul> <li>이름에 유형 정보나 범위 정보를 넣어서는 안된다.</li> <li>예를 들어 오늘날 개발 환경에서, <code class="language-plaintext highlighter-rouge">m_</code> 이나 <code class="language-plaintext highlighter-rouge">f</code> 와 같은 접두어는 불필요하다. <h3 id="n7-이름으로-부수-효과를-설명하라"> <a href="#n7-이름으로-부수-효과를-설명하라" class="anchor-heading" aria-labelledby="n7-이름으로-부수-효과를-설명하라"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> <em>N7: 이름으로 부수 효과를 설명하라</em> </h3> </li> <li>이름에 부수 효과를 숨기지 않는다.</li> </ul> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="nc">ObjectOutprStream</span> <span class="nf">getOos</span><span class="o">()</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">m_oos</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">m_oos</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ObjectOutprStream</span><span class="o">(</span><span class="n">m_socket</span><span class="o">.</span><span class="na">getOutputStream</span><span class="o">());</span>
    <span class="o">}</span> 
    <span class="k">return</span> <span class="n">m_oos</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div> <p>위 함수는 단순히 “oos”만 가져오지 않고, 없으면 생성하기도 한다. 그러므로 <code class="language-plaintext highlighter-rouge">createOrReturnOos</code> 라는 이름이 더 적합하다.</p> <h2 id="테스트"> <a href="#테스트" class="anchor-heading" aria-labelledby="테스트"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 테스트 </h2> <h3 id="t1-불충분한-테스트"> <a href="#t1-불충분한-테스트" class="anchor-heading" aria-labelledby="t1-불충분한-테스트"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> <em>T1: 불충분한 테스트</em> </h3> <ul> <li>테스트 케이스는 잠재적으로 깨질 만한 부분을 모두 테스트 해야한다.</li> <li>테스트 케이스가 확인하지 않는 조건이나 검증하지 않는 계산이 있다면 그 테스트는 불완전하다.</li> </ul> <h3 id="t2-커버리지-도구를-사용하라"> <a href="#t2-커버리지-도구를-사용하라" class="anchor-heading" aria-labelledby="t2-커버리지-도구를-사용하라"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> <em>T2: 커버리지 도구를 사용하라!</em> </h3> <ul> <li>커버리지 도구는 테스트가 빠뜨리는 공백을 알려준다.</li> <li>커버리지 도구를 사용하면 테스트가 불충분한 모듈, 클래스, 함수를 찾기가 쉬워진다.</li> </ul> <h3 id="t3-사소한-테스트를-건너-뛰지-마라"> <a href="#t3-사소한-테스트를-건너-뛰지-마라" class="anchor-heading" aria-labelledby="t3-사소한-테스트를-건너-뛰지-마라"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> <em>T3: 사소한 테스트를 건너 뛰지 마라</em> </h3> <ul> <li>사소한 테스트는 짜기 쉽다.</li> <li>사소한 테스트가 제공하는 문서적 가치는 구현에 드는 비용을 넘어선다.</li> </ul> <h3 id="t4-무시한-테스트는-모호함을-뜻한다"> <a href="#t4-무시한-테스트는-모호함을-뜻한다" class="anchor-heading" aria-labelledby="t4-무시한-테스트는-모호함을-뜻한다"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> <em>T4: 무시한 테스트는 모호함을 뜻한다</em> </h3> <ul> <li>때로는 요구사항이 불분명해 프로그램이 돌아가는 방식을 확신하기 어렵다. <ul> <li>이러한 경우 테스트 케이스를 주석 처리하거나, <code class="language-plaintext highlighter-rouge">@Ignore</code>를 붙여 표현한다.</li> </ul> </li> </ul> <h3 id="t5-경계-조건을-테스트하라"> <a href="#t5-경계-조건을-테스트하라" class="anchor-heading" aria-labelledby="t5-경계-조건을-테스트하라"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> <em>T5: 경계 조건을 테스트하라</em> </h3> <ul> <li>경계 조건은 각별히 신경 써서 테스트 한다.</li> </ul> <h3 id="t6-버그-주변은-철저히-테스트하라"> <a href="#t6-버그-주변은-철저히-테스트하라" class="anchor-heading" aria-labelledby="t6-버그-주변은-철저히-테스트하라"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> <em>T6: 버그 주변은 철저히 테스트하라</em> </h3> <ul> <li>버그는 서로 모이는 경향이 있다.</li> <li>한 함수 에서 버그를 발견했다면 그 함수를 철저히 테스트하는 편이 좋다.</li> </ul> <h3 id="t7-실제-패턴을-살펴라"> <a href="#t7-실제-패턴을-살펴라" class="anchor-heading" aria-labelledby="t7-실제-패턴을-살펴라"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> <em>T7: 실제 패턴을 살펴라</em> </h3> <ul> <li>때로는 테스트 케이스가 실패하는 패턴으로 문제를 진단할 수 있다.</li> <li>합리적인 순서로 정렬된 꼼꼼한 테스트 케이스들은 실패 패턴을 드러낸다.</li> </ul> <h3 id="t8-테스트-커버리지-패턴을-살펴라"> <a href="#t8-테스트-커버리지-패턴을-살펴라" class="anchor-heading" aria-labelledby="t8-테스트-커버리지-패턴을-살펴라"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> <em>T8: 테스트 커버리지 패턴을 살펴라</em> </h3> <ul> <li>통과하는 테스트나 실행하거나 실행하지 않는 코드를 살펴보면 실패하는 테스트 케이스의 실패 원인이 드러난다.</li> </ul> <h3 id="t9-테스트는-빨라야-한다"> <a href="#t9-테스트는-빨라야-한다" class="anchor-heading" aria-labelledby="t9-테스트는-빨라야-한다"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> <em>T9: 테스트는 빨라야 한다</em> </h3> <ul> <li>느린 테스트 케이스는 실행하지 않게 된다. 그러므로 테스트 케이스는 최대한 빨리 돌아가게 노력한다.</li> </ul> <h2 id="결론"> <a href="#결론" class="anchor-heading" aria-labelledby="결론"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 결론 </h2> <p>이 장에서 소개한 휴리스틱과 냄새 목록이 완전하다 말하기는 어렵다. 하지만 완전한 목록이 목표가 아닌, 가치 체계를 피력한다.</p> <p>사실상 가치 체계는 이 책의 주제이자 목표다. 일군의 규칙만 따른다고 깨끗한 코드가 얻어지지 않는다. 휴리스틱 목록을 익힌다고 소프트웨어 장인이 되지는 못한다. 장인 정신은 가치에서 나온다. 그 가치에 기반한 규율과 절제가 필요하다.</p> </main> </div> </div> <div class="search-overlay"></div> </div> </body> </html>
