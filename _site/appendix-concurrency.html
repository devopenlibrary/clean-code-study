<!DOCTYPE html> <html lang="en"> <head> <meta charset="UTF-8"> <meta http-equiv="X-UA-Compatible" content="IE=Edge"> <link rel="stylesheet" href="/assets/css/just-the-docs-default.css"> <link rel="stylesheet" href="/assets/css/just-the-docs-head-nav.css" id="jtd-head-nav-stylesheet"> <style id="jtd-nav-activation"> .site-nav > ul.nav-list:first-child > li:not(:nth-child(19)) > a, .site-nav > ul.nav-list:first-child > li > ul > li a { background-image: none; } .site-nav > ul.nav-list:not(:first-child) a, .site-nav li.external a { background-image: none; } .site-nav > ul.nav-list:first-child > li:nth-child(19) > a { font-weight: 600; text-decoration: none; }.site-nav > ul.nav-list:first-child > li:nth-child(19) > button svg { transform: rotate(-90deg); }.site-nav > ul.nav-list:first-child > li.nav-list-item:nth-child(19) > ul.nav-list { display: block; } </style> <script src="/assets/js/vendor/lunr.min.js"></script> <script src="/assets/js/just-the-docs.js"></script> <meta name="viewport" content="width=device-width, initial-scale=1"> <!-- Begin Jekyll SEO tag v2.8.0 --> <title>동시성 | Dev Open Library</title> <meta name="generator" content="Jekyll v3.10.0" /> <meta property="og:title" content="동시성" /> <meta property="og:locale" content="en" /> <meta name="description" content="A minimal, responsive and feature-rich Jekyll theme for technical writing." /> <meta property="og:description" content="A minimal, responsive and feature-rich Jekyll theme for technical writing." /> <link rel="canonical" href="http://localhost:4000/appendix-concurrency.html" /> <meta property="og:url" content="http://localhost:4000/appendix-concurrency.html" /> <meta property="og:site_name" content="Dev Open Library" /> <meta property="og:type" content="website" /> <meta name="twitter:card" content="summary" /> <meta property="twitter:title" content="동시성" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"WebPage","description":"A minimal, responsive and feature-rich Jekyll theme for technical writing.","headline":"동시성","url":"http://localhost:4000/appendix-concurrency.html"}</script> <!-- End Jekyll SEO tag --> </head> <body> <a class="skip-to-main" href="#main-content">Skip to main content</a> <svg xmlns="http://www.w3.org/2000/svg" class="d-none"> <symbol id="svg-link" viewBox="0 0 24 24"> <title>Link</title> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-link"> <path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path> </svg> </symbol> <symbol id="svg-menu" viewBox="0 0 24 24"> <title>Menu</title> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-menu"> <line x1="3" y1="12" x2="21" y2="12"></line><line x1="3" y1="6" x2="21" y2="6"></line><line x1="3" y1="18" x2="21" y2="18"></line> </svg> </symbol> <symbol id="svg-arrow-right" viewBox="0 0 24 24"> <title>Expand</title> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-chevron-right"> <polyline points="9 18 15 12 9 6"></polyline> </svg> </symbol> <!-- Feather. MIT License: https://github.com/feathericons/feather/blob/master/LICENSE --> <symbol id="svg-external-link" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-external-link"> <title id="svg-external-link-title">(external link)</title> <path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path><polyline points="15 3 21 3 21 9"></polyline><line x1="10" y1="14" x2="21" y2="3"></line> </symbol> <symbol id="svg-doc" viewBox="0 0 24 24"> <title>Document</title> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-file"> <path d="M13 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V9z"></path><polyline points="13 2 13 9 20 9"></polyline> </svg> </symbol> <symbol id="svg-search" viewBox="0 0 24 24"> <title>Search</title> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-search"> <circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"></line> </svg> </symbol> <!-- Bootstrap Icons. MIT License: https://github.com/twbs/icons/blob/main/LICENSE.md --> <symbol id="svg-copy" viewBox="0 0 16 16"> <title>Copy</title> <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-clipboard" viewBox="0 0 16 16"> <path d="M4 1.5H3a2 2 0 0 0-2 2V14a2 2 0 0 0 2 2h10a2 2 0 0 0 2-2V3.5a2 2 0 0 0-2-2h-1v1h1a1 1 0 0 1 1 1V14a1 1 0 0 1-1 1H3a1 1 0 0 1-1-1V3.5a1 1 0 0 1 1-1h1v-1z"/> <path d="M9.5 1a.5.5 0 0 1 .5.5v1a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5v-1a.5.5 0 0 1 .5-.5h3zm-3-1A1.5 1.5 0 0 0 5 1.5v1A1.5 1.5 0 0 0 6.5 4h3A1.5 1.5 0 0 0 11 2.5v-1A1.5 1.5 0 0 0 9.5 0h-3z"/> </svg> </symbol> <symbol id="svg-copied" viewBox="0 0 16 16"> <title>Copied</title> <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-clipboard-check-fill" viewBox="0 0 16 16"> <path d="M6.5 0A1.5 1.5 0 0 0 5 1.5v1A1.5 1.5 0 0 0 6.5 4h3A1.5 1.5 0 0 0 11 2.5v-1A1.5 1.5 0 0 0 9.5 0h-3Zm3 1a.5.5 0 0 1 .5.5v1a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5v-1a.5.5 0 0 1 .5-.5h3Z"/> <path d="M4 1.5H3a2 2 0 0 0-2 2V14a2 2 0 0 0 2 2h10a2 2 0 0 0 2-2V3.5a2 2 0 0 0-2-2h-1v1A2.5 2.5 0 0 1 9.5 5h-3A2.5 2.5 0 0 1 4 2.5v-1Zm6.854 7.354-3 3a.5.5 0 0 1-.708 0l-1.5-1.5a.5.5 0 0 1 .708-.708L7.5 10.793l2.646-2.647a.5.5 0 0 1 .708.708Z"/> </svg> </symbol> </svg> <div class="side-bar"> <div class="site-header" role="banner"> <a href="/" class="site-title lh-tight"> Dev Open Library </a> <button id="menu-button" class="site-button btn-reset" aria-label="Toggle menu" aria-pressed="false"> <svg viewBox="0 0 24 24" class="icon" aria-hidden="true"><use xlink:href="#svg-menu"></use></svg> </button> </div> <nav aria-label="Main" id="site-nav" class="site-nav"> <ul class="nav-list"><li class="nav-list-item"><a href="/" class="nav-list-link">Clean Code Study</a></li><li class="nav-list-item"><a href="/chapter1-clean-code.html" class="nav-list-link">1장 깨끗한 코드</a></li><li class="nav-list-item"><a href="/chapter2-meaningful-names.html" class="nav-list-link">2장 의미 있는 이름</a></li><li class="nav-list-item"><a href="/chapter3-function.html" class="nav-list-link">3장 함수</a></li><li class="nav-list-item"><a href="/chapter4-annotation.html" class="nav-list-link">4장 주석</a></li><li class="nav-list-item"><a href="/chapter5-consistent-formatting%20.html" class="nav-list-link">5장 형식 맞추기</a></li><li class="nav-list-item"><a href="/chpater6-obejct-and-data-structure.html" class="nav-list-link">6장 객체와 자료구조</a></li><li class="nav-list-item"><a href="/chapter7-error-handling.html" class="nav-list-link">7장 오류 처리</a></li><li class="nav-list-item"><a href="/chapter8-boundary.html" class="nav-list-link">8장 경계</a></li><li class="nav-list-item"><a href="/chapter9-unit-test.html" class="nav-list-link">9장 단위 테스트</a></li><li class="nav-list-item"><a href="/chapter10-class.html" class="nav-list-link">10장 클래스</a></li><li class="nav-list-item"><a href="/chapter11-system.html" class="nav-list-link">11장 시스템</a></li><li class="nav-list-item"><a href="/chapter12-emergence.html" class="nav-list-link">12장 창발성</a></li><li class="nav-list-item"><a href="/chapter13-concurrency.html" class="nav-list-link">13장 동시성</a></li><li class="nav-list-item"><a href="/chapter14-incremental-improvement.html" class="nav-list-link">14장 점진적인 개선</a></li><li class="nav-list-item"><a href="/chapter15-junit.html" class="nav-list-link">15장 JUnit</a></li><li class="nav-list-item"><a href="/chapter16-SerialDate-refactoring.html" class="nav-list-link">16장 SerialDate 리팩토링</a></li><li class="nav-list-item"><a href="/chapter17-smell-and-heuristic.html" class="nav-list-link">17장 냄새와 휴리스틱</a></li><li class="nav-list-item"><a href="/appendix-concurrency.html" class="nav-list-link">동시성</a></li></ul> </nav> <footer class="site-footer"> This site uses <a href="https://github.com/just-the-docs/just-the-docs">Just the Docs</a>, a documentation theme for Jekyll. </footer> </div> <div class="main" id="top"> <div id="main-header" class="main-header"> <div class="search" role="search"> <div class="search-input-wrap"> <input type="text" id="search-input" class="search-input" tabindex="0" placeholder="Search Dev Open Library" aria-label="Search Dev Open Library" autocomplete="off"> <label for="search-input" class="search-label"><svg viewBox="0 0 24 24" class="search-icon"><use xlink:href="#svg-search"></use></svg></label> </div> <div id="search-results" class="search-results"></div> </div> </div> <div class="main-content-wrap"> <div id="main-content" class="main-content"> <main> <h1 id="동시성"> <a href="#동시성" class="anchor-heading" aria-labelledby="동시성"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 동시성 </h1> <h2 id="클라이언트--서버-예제"> <a href="#클라이언트--서버-예제" class="anchor-heading" aria-labelledby="클라이언트--서버-예제"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 클라이언트 / 서버 예제 </h2> <p>클라이언트 - 서버 애플리케이션을 예시로 동시성에 대해 알아보자.</p> <h3 id="서버"> <a href="#서버" class="anchor-heading" aria-labelledby="서버"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 서버 </h3> <p>아래와 같이 단일 스레드 방식의 클라이언트 - 서버 구조인 애플리케이션이 있다고 가정하자.</p> <ul> <li> <p>서버: 소켓을 열어놓고 클라이언트가 연결하기를 기다림</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="nc">ServerSocket</span> <span class="n">serverSocket</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ServerSocket</span><span class="o">(</span><span class="mi">8009</span><span class="o">);</span>
    
  <span class="k">while</span> <span class="o">(</span><span class="n">keepProcessing</span><span class="o">)</span> <span class="o">{</span>
      <span class="k">try</span> <span class="o">{</span>
          <span class="nc">Socket</span> <span class="n">socket</span> <span class="o">=</span> <span class="n">serverSocket</span><span class="o">.</span><span class="na">accept</span><span class="o">();</span>
          <span class="n">process</span><span class="o">(</span><span class="n">socket</span><span class="o">);</span>
      <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">Exception</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
          <span class="n">handle</span><span class="o">(</span><span class="n">e</span><span class="o">);</span>
      <span class="o">}</span>
  <span class="o">}</span>
</code></pre></div> </div> </li> <li> <p>클라이언트: 소켓에 연결해 요청을 보냄</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kd">private</span> <span class="kt">void</span> <span class="nf">connectSendReceive</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">)</span> <span class="o">{</span>
      <span class="k">try</span> <span class="o">{</span>
          <span class="nc">Socket</span> <span class="n">socket</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Socket</span><span class="o">(</span><span class="s">"localhost"</span><span class="o">,</span> <span class="no">PORT</span><span class="o">);</span>
          <span class="nc">MessageUtils</span><span class="o">.</span><span class="na">sendMessage</span><span class="o">(</span><span class="n">socket</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">i</span><span class="o">));</span>
          <span class="nc">MessageUtils</span><span class="o">.</span><span class="na">getMessage</span><span class="o">(</span><span class="n">socket</span><span class="o">);</span>
          <span class="n">socket</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
      <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">Exception</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
          <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
      <span class="o">}</span>
  <span class="o">}</span> 
</code></pre></div> </div> </li> <li> <dl> <dt>테스트 코드</dt> <dd>이때 이 코드가 잘 동작하는지 테스트 하기 위해, 아래 테스트 코드를 작성합니다. <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Test</span><span class="o">(</span><span class="n">timeout</span> <span class="o">=</span> <span class="mi">10000</span><span class="o">)</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">shouldRunInUnder10Seconds</span><span class="o">()</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
    <span class="nc">Thread</span><span class="o">[]</span> <span class="n">threads</span> <span class="o">=</span> <span class="n">createThreads</span><span class="o">();</span>
    <span class="n">startAllThreads</span><span class="o">(</span><span class="n">threads</span><span class="o">);</span>
    <span class="n">waitForAllThreadsToFinish</span><span class="o">(</span><span class="n">threads</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div> </div> <ul> <li>테스트 케이스는 동시성 작업 처리 능력을 검증하는 전형적인 예시로, 10,000밀리초 내에 끝나기를 검사</li> <li>단일 스레드 서버는 한 번에 하나의 요청만 순차적으로 처리, 클라이언트 증가시 실패할 가능성이 매우 높음</li> </ul> </dd> </dl> </li> </ul> <h3 id="스레드-추가하기"> <a href="#스레드-추가하기" class="anchor-heading" aria-labelledby="스레드-추가하기"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 스레드 추가하기 </h3> <p>해결하기 위해 가장 먼저 떠올릴 수 있는 방법은, 각 클라이언트 요청을 별도의 스레드에서 처리하는 것</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">ServerSocket</span> <span class="n">serverSocket</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ServerSocket</span><span class="o">(</span><span class="mi">8009</span><span class="o">);</span>

<span class="k">while</span> <span class="o">(</span><span class="n">keepProcessing</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">try</span> <span class="o">{</span>
        <span class="nc">Socket</span> <span class="n">socket</span> <span class="o">=</span> <span class="n">serverSocket</span><span class="o">.</span><span class="na">accept</span><span class="o">();</span>
        <span class="c1">// 요청이 들어올 때마다 새로운 스레드를 생성해 처리</span>
        <span class="k">new</span> <span class="nf">Thread</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="n">process</span><span class="o">(</span><span class="n">socket</span><span class="o">)).</span><span class="na">start</span><span class="o">();</span>
    <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">Exception</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">handle</span><span class="o">(</span><span class="n">e</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <p>: 서버는 클라이언트 요청을 받자마자 새 스레드에 작업을 위임 -&gt; 바로 다음 연결을 대기함 =&gt; 여러 클라이언트의 요청을 동시에 처리 가능함</p> <blockquote> <ul> <li>I/O 바운드: 소켓 사용, DB연결, 가상 메모리 스와핑 등 <code class="language-plaintext highlighter-rouge">대기</code>하는 작업이 많음 -&gt; 동시성이 성능을 높일 수 있음</li> <li>CPU 바운드: 수치 계산, 정규식 처리, 가비지 컬렉션 등 <code class="language-plaintext highlighter-rouge">연산</code>하는 작업이 많음 -&gt; 하드웨어를 추가해 성능을 높일 수 있음</li> </ul> </blockquote> <h3 id="서버-살펴보기"> <a href="#서버-살펴보기" class="anchor-heading" aria-labelledby="서버-살펴보기"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 서버 살펴보기 </h3> <ul> <li>SRP 위반: 서버는 여러개의 책임을 지고 있음 <ul> <li>소켓 연결 관리</li> <li>클라이언트 처리</li> <li>스레드 정책</li> <li>서버 종료 정책</li> </ul> </li> </ul> <h3 id="결론"> <a href="#결론" class="anchor-heading" aria-labelledby="결론"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 결론 </h3> <p>단순히 스레드를 추가하는 것만으로는 견고한 동시성 시스템을 만들 수 없다. 이는 동시성이 야기하는 근본적인 문제들을 해결하지 못하기 때문이다. 깨끗한 동시성 코드를 작성하려면 실행 경로, 자원 공유, 데드락 등 더 깊은 이해가 필요하다.</p> <h2 id="가능한-실행-경로"> <a href="#가능한-실행-경로" class="anchor-heading" aria-labelledby="가능한-실행-경로"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 가능한 실행 경로 </h2> <h3 id="경로-수"> <a href="#경로-수" class="anchor-heading" aria-labelledby="경로-수"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 경로 수 </h3> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">IdGenerator</span><span class="o">{</span>

  <span class="kt">int</span> <span class="n">lastIdUsed</span><span class="o">;</span>
  
  <span class="kd">public</span> <span class="kt">int</span> <span class="nf">incrementValue</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">return</span> <span class="o">++</span><span class="n">lastIdUsed</span><span class="o">;</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <p>스레드가 1개라면 동일한 결과가 보장되지만, n개라면 다양한 결과가 나올 수 있다.</p> <p>그 이유는 가능한 실행 경로 수와 JVM의 동작 방식을 알아야 한다.</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">return</span> <span class="o">++</span><span class="n">lastIdUsed</span><span class="o">;</span>
</code></pre></div></div> <p>이 한줄은 바이트 코드 8개가 해당되어, 스레드가 여러 개라면 명령 8개를 뒤섞어 실행할 가능성이 충분하다.</p> <h3 id="가능한-순열-수-계산하기"> <a href="#가능한-순열-수-계산하기" class="anchor-heading" aria-labelledby="가능한-순열-수-계산하기"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 가능한 순열 수 계산하기 </h3> <ul> <li> <p>위의 경우의 수</p> \[\text{경로 수} = \frac{(T \times N)!}{(N!)^T}\] <ul> <li>단계가 N, 스레드가 T라면 총 단게는 N * T개</li> <li>정해진 순서를 위반하는 경우를 제거</li> </ul> </li> <li> <p>코드를 변경한다면?</p> </li> </ul> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">synchronized</span> <span class="kt">void</span> <span class="nf">incrementValue</span><span class="o">(){</span>
  <span class="o">++</span><span class="n">lastIdUsed</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div> <p>가능한 경로의 수는 스레드 개수만큼으로 줄어든다. (단계가 사라짐) -&gt; 1개가 되지 않는다.</p> <p>만약</p> <h3 id="심층-분석"> <a href="#심층-분석" class="anchor-heading" aria-labelledby="심층-분석"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 심층 분석 </h3> <ul> <li>원자적 연산이란? <ul> <li>중단이 불가능한 연산을 원자적 연산이라고 정의함</li> <li>e.g. <code class="language-plaintext highlighter-rouge">lastId = 0;</code></li> </ul> </li> <li>자료형을 변경한다면? int -&gt; long <ul> <li>만약 자료형을 변경시, <code class="language-plaintext highlighter-rouge">lastId = 0;</code> 또한 원자적 연산이 될 수 없음</li> </ul> </li> <li>전처리 증가 연산자(++)는? <ul> <li>중단이 가능하기 때문에, 원자적 연산이 아님</li> </ul> </li> <li>바이트 코드를 보기전 알아야할 개념 <ul> <li>프레임: 호출 스택을 정의할 때 사용하는 표준 기법으로, 모든 메서드 호출에 는 프레임이 필요함</li> <li>지역 변수: 메서드 내에 정의되는 모든 변수, this는 현재 스레드에서 가장 퇴근에 메시지를 받아 메서들르 호출한 객체를 가리킴</li> <li>피연산자 스택: 매개변수를 저장하는 장소, LIFO 구조</li> </ul> </li> <li><code class="language-plaintext highlighter-rouge">synchronized</code>를 이용하면, <code class="language-plaintext highlighter-rouge">incrementValue()</code>는 해결됨 <ul> <li>동기화 되기 때문에 가능한 수(경로)는 여러개지만, 결과는 단 한개가 됨</li> </ul> </li> </ul> <h2 id="라이브러리를-이해하라"> <a href="#라이브러리를-이해하라" class="anchor-heading" aria-labelledby="라이브러리를-이해하라"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 라이브러리를 이해하라 </h2> <h3 id="executor-프레임워크"> <a href="#executor-프레임워크" class="anchor-heading" aria-labelledby="executor-프레임워크"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Executor 프레임워크 </h3> <p>스레드와 관련된 프레임 워크로 <code class="language-plaintext highlighter-rouge">Executor</code>클래스와 <code class="language-plaintext highlighter-rouge">Future</code>를 이용해본다.</p> <h3 id="스레드를-차단하지-않는-방법"> <a href="#스레드를-차단하지-않는-방법" class="anchor-heading" aria-labelledby="스레드를-차단하지-않는-방법"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 스레드를 차단하지 않는 방법 </h3> <p>먼저 적용한 <code class="language-plaintext highlighter-rouge">synchronized</code>를 이용한 방법은 락을 이용한 방법으로 스레드를 차단한다. 동시성 문제가 크지 않을 때라면 괜찮지만, 많다면 성능에 문제가 생길 수 있다.</p> <blockquote> <p>CAS (Compare-And-Swap) 연산</p> <p>DB분야에서 낙관적 잠금이라는 개념과 유사, (동기화는 비관적 잠금 개념과 유사)</p> <p>3가지 값을 사용</p> <ul> <li>메모리의 현재 값 (V: Value): 지금 현재 공유 변수에 저장된 값입니다.</li> <li>예상되는 현재 값 (A: Expected Old Value): 스레드가 변수를 읽어와서 변경하려고 할 때 ‘내가 읽었을 때 이 값이 있었을 것이다’라고 예상하는 값입니다.</li> <li>새로운 값 (B: New Value): 스레드가 변수를 성공적으로 업데이트하고 싶은 새로운 값입니다.</li> </ul> </blockquote> <h3 id="다중-스레드-환경에서-안전하지-않은-클래스"> <a href="#다중-스레드-환경에서-안전하지-않은-클래스" class="anchor-heading" aria-labelledby="다중-스레드-환경에서-안전하지-않은-클래스"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 다중 스레드 환경에서 안전하지 않은 클래스 </h3> <ul> <li>안전하지 않은 스레드 <ul> <li><code class="language-plaintext highlighter-rouge">SimpleDateFormat</code></li> <li>DB 연결</li> <li>java.util 컨테이너 클래스</li> <li>서블릿</li> </ul> </li> <li> <p>만약 아래 코드가 멀티스레드 환경에서 동작한다면</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span><span class="o">(!</span><span class="n">hashTable</span><span class="o">.</span><span class="na">containKey</span><span class="o">(</span><span class="n">someKey</span><span class="o">))</span> <span class="o">{</span>
  <span class="n">hashTable</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">somekey</span><span class="o">,</span> <span class="k">new</span> <span class="nc">SomeValeu</span><span class="o">());</span>
<span class="o">}</span>
</code></pre></div> </div> <ol> <li>클라이언트 기반 잠금: 사용하는 클라이언트가 잠금(<code class="language-plaintext highlighter-rouge">synchronized</code>)를 이용</li> <li>서버 기반 잠금: 서버가 잠금(<code class="language-plaintext highlighter-rouge">synchronized</code>)를 이용</li> <li>스레드에 안전한 집합 클래스를 사용</li> </ol> </li> </ul> <h2 id="메서드-사이에-존재하는-의존성을-조심하라"> <a href="#메서드-사이에-존재하는-의존성을-조심하라" class="anchor-heading" aria-labelledby="메서드-사이에-존재하는-의존성을-조심하라"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 메서드 사이에 존재하는 의존성을 조심하라 </h2> <ul> <li> <p>의존성을 만드는 예제</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">IntegerIterator</span> <span class="kd">implements</span> <span class="nc">Iterator</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">Integer</span> <span class="n">nextValue</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
  
    <span class="kd">public</span> <span class="kd">synchronized</span> <span class="kt">boolean</span> <span class="nf">hasNext</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">nextValue</span> <span class="o">&lt;</span> <span class="mi">100000</span><span class="o">;</span>
    <span class="o">}</span>
  
    <span class="kd">public</span> <span class="kd">synchronized</span> <span class="nc">Integer</span> <span class="nf">next</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">nextValue</span> <span class="o">==</span> <span class="mi">100000</span><span class="o">)</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nf">IteratorPastEndException</span><span class="o">();</span>
        <span class="k">return</span> <span class="n">nextValue</span><span class="o">++;</span>
    <span class="o">}</span>
  
    <span class="kd">public</span> <span class="kd">synchronized</span> <span class="nc">Integer</span> <span class="nf">getNextValue</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">nextValue</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div> </div> </li> <li> <p>위 예제를 사용하는 코드</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">IntegerIterator</span> <span class="n">iterator</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">IntegerIterator</span><span class="o">();</span>
<span class="k">while</span><span class="o">(</span><span class="n">iterator</span><span class="o">.</span><span class="na">hasNext</span><span class="o">())</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">nextValue</span> <span class="o">=</span> <span class="n">iterator</span><span class="o">.</span><span class="na">next</span><span class="o">();</span>
    <span class="c1">// nextValue를 뭔가 한다.</span>
<span class="o">}</span>
</code></pre></div> </div> </li> <li> <p>문제상황</p> <ol> <li><code class="language-plaintext highlighter-rouge">nextValue</code>가 <code class="language-plaintext highlighter-rouge">99999</code>일 때, <code class="language-plaintext highlighter-rouge">Thread 1</code>이 <code class="language-plaintext highlighter-rouge">hasNext()</code>를 호출하면 <code class="language-plaintext highlighter-rouge">true</code>를 반환</li> <li>그 사이에 <code class="language-plaintext highlighter-rouge">Thread 2</code>가 <code class="language-plaintext highlighter-rouge">next()</code>를 호출하여 <code class="language-plaintext highlighter-rouge">nextValue</code>를 <code class="language-plaintext highlighter-rouge">100000</code>으로 만들고, <code class="language-plaintext highlighter-rouge">IteratorPastEndException을</code> 발생</li> <li><code class="language-plaintext highlighter-rouge">Thread 1</code>이 이어서 <code class="language-plaintext highlighter-rouge">next()</code>를 호출하면, 이미 <code class="language-plaintext highlighter-rouge">nextValue</code>가 <code class="language-plaintext highlighter-rouge">100000</code>이므로 <code class="language-plaintext highlighter-rouge">IteratorPastEndException을</code> 발생</li> </ol> </li> </ul> <h3 id="실패를-용인한다"> <a href="#실패를-용인한다" class="anchor-heading" aria-labelledby="실패를-용인한다"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 실패를 용인한다 </h3> <p>떄로는 실패를 해도 괜찮도록 할 수 있다. e.g. 클라이언트가 예외를 받아 처리, 메모리 누수를 시간마다 재부팅하는 방식</p> <h3 id="클라이언트---기반-잠금"> <a href="#클라이언트---기반-잠금" class="anchor-heading" aria-labelledby="클라이언트---기반-잠금"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 클라이언트 - 기반 잠금 </h3> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="nc">IntegerIterator</span> <span class="n">iterator</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">IntegerIterator</span><span class="o">();</span>
  
  <span class="k">while</span><span class="o">(</span><span class="kc">true</span><span class="o">){</span>
      <span class="kt">int</span> <span class="n">nextValue</span><span class="o">;</span>
      <span class="kd">synchronized</span> <span class="o">(</span><span class="n">iterator</span><span class="o">){</span>
        <span class="k">if</span><span class="o">(!</span><span class="n">iterator</span><span class="o">.</span><span class="na">hasNext</span><span class="o">())</span>
          <span class="k">break</span><span class="o">;</span>
          
        <span class="n">nextValue</span> <span class="o">=</span> <span class="n">iterator</span><span class="o">.</span><span class="na">next</span><span class="o">();</span>
      <span class="o">}</span>
      <span class="n">doSomethingWith</span><span class="o">(</span><span class="n">nextValue</span><span class="o">);</span>
  <span class="o">}</span>
</code></pre></div></div> <p>각 클라이언트가 <code class="language-plaintext highlighter-rouge">synchronized</code>를 이용해 <code class="language-plaintext highlighter-rouge">IntegerIterator</code>객체에 락을 건다. -&gt; <code class="language-plaintext highlighter-rouge">IntegerIterator</code>를 이용하는 모든 프로그래머가 이를 기억해야함 (위험, 해결하기 어려움)</p> <h3 id="서버---기반-잠금"> <a href="#서버---기반-잠금" class="anchor-heading" aria-labelledby="서버---기반-잠금"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 서버 - 기반 잠금 </h3> <p>클라이언트에서 중복해서 락을 걸지 않아도 된다.</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kd">public</span> <span class="kd">class</span> <span class="nc">IntegerIteratorServerLocked</span> <span class="o">{</span>
      <span class="kd">private</span> <span class="nc">Integer</span> <span class="n">nextValue</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
  
      <span class="kd">public</span> <span class="kd">synchronized</span> <span class="nc">Integer</span> <span class="nf">nextOrNull</span><span class="o">()</span> <span class="o">{</span>
          <span class="k">if</span><span class="o">(</span><span class="n">nextValue</span> <span class="o">&lt;</span> <span class="mi">100000</span><span class="o">)</span>
            <span class="k">return</span> <span class="n">nextValue</span><span class="o">++;</span>
          <span class="k">else</span>
            <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
      <span class="o">}</span>
  <span class="o">}</span>
</code></pre></div></div> <ul> <li>더 바람직한 이유 <ul> <li>코드 중복이 줄어듬</li> <li>성능이 좋아짐: 단일 스레드 환경으로 시스템을 배치할 경우, 서버만 교체하면 오버헤드가 줄어든다.</li> <li>락 관리가 1곳이라, 위험이 줄어듬</li> <li>스레드 정책이 1개</li> <li>공유 변수 범위가 줄어듬</li> </ul> </li> <li>만약 서버 코드를 수정할 수 없다면? Adapter 패턴을 이용해 API를 변경한 후 잠금을 추가</li> </ul> <h2 id="작업-처리량-높이기"> <a href="#작업-처리량-높이기" class="anchor-heading" aria-labelledby="작업-처리량-높이기"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 작업 처리량 높이기 </h2> <ul> <li><code class="language-plaintext highlighter-rouge">synchronized</code>의 영역은 언제나 작을수록 좋다.</li> </ul> <p>가정</p> <ul> <li>페이지를 읽어오는 평균 I/O 시간 : 1초</li> <li>페이지를 분석하는 평균 처리 시간 : 0.5초</li> <li>처리는 CPU 100% 사용, I/O는 CPU 0% 사용</li> </ul> <h3 id="작업-처리량-계산---단일-스레드-환경"> <a href="#작업-처리량-계산---단일-스레드-환경" class="anchor-heading" aria-labelledby="작업-처리량-계산---단일-스레드-환경"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 작업 처리량 계산 - 단일 스레드 환경 </h3> <p>만약 스레드 1개인 단일 스레드 환경에서, N개의 페이지를 처리한다면 =&gt; 실행시간은 총1.5초 * N 초</p> <h3 id="작업-처리량-계산---다중-스레드-환경"> <a href="#작업-처리량-계산---다중-스레드-환경" class="anchor-heading" aria-labelledby="작업-처리량-계산---다중-스레드-환경"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 작업 처리량 계산 - 다중 스레드 환경 </h3> <p>만약 순서와 무관하게 페이지를 독립적으로 읽어와 처리해도 된다면, 다중 스레드가 속도를 높이는데 도움이 될 수 있다.</p> <p>3개의 스레드를 사용한다고 하면, I/O 작업이 발생하는 1초동안 2페이지의 내용을 처리할 수 있다. 즉 1초마다 2개의 페이지를 처리할 수있으므로, 단일 스레드 환경과 비교한다면 처리율을 3배다.</p> <h2 id="데드락"> <a href="#데드락" class="anchor-heading" aria-labelledby="데드락"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 데드락 </h2> <p>데드락을 발생 시키는 조건</p> <ul> <li>상호 배제(Mutual exclusion)</li> <li>잠금 &amp; 대기(Lock &amp; Wait)</li> <li>선점 불가(No preemption)</li> <li>순환 대기(Circular Wait)</li> </ul> <h3 id="상호배제"> <a href="#상호배제" class="anchor-heading" aria-labelledby="상호배제"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 상호배제 </h3> <p>여러 스레드가 한 자원을 공유하면서,</p> <ul> <li>동시에 사용하지 못하며</li> <li>개수가 제한적이라면 조건을 만족한다.</li> </ul> <p>e.g. DB 연결, 쓰기용 파일 열기, 레코드 락, 세마포어 등</p> <h3 id="잠금--대기"> <a href="#잠금--대기" class="anchor-heading" aria-labelledby="잠금--대기"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 잠금 &amp; 대기 </h3> <p>자원을 점유하면, <strong>필요한 나머지 자원까지</strong> 모두 점유한뒤 작업을 마칠 때까지 이미 점유한 자원을 내놓지 않음</p> <h3 id="선점-불가"> <a href="#선점-불가" class="anchor-heading" aria-labelledby="선점-불가"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 선점 불가 </h3> <p>한 스레드가 다른 스레드로부터 자원을 빼앗지 못함 -&gt; 스스로 내놓지 않으면 다른 스레드는 그 자원을 점유하지 못함</p> <h3 id="순환-대기"> <a href="#순환-대기" class="anchor-heading" aria-labelledby="순환-대기"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 순환 대기 </h3> <blockquote> <p>죽음의 포옴 2개의 스레드 (T1, T2)가 2개의 공유 자원(R1,R2)가 있을 때, T1 - R1, T2 - R2 이렇게 점유 된 상황에서 T1 -&gt; R2, T2 -&gt; R1f 이렇게 원하는 상황이라면 데드락이 발생한다. (서로 필요한 자원이 생기지 않아 자신의 자원을 놓지 않고 있으므로)</p> </blockquote> <p>위 4개의 조건 중 하나라도 깨버린다면, 데드락은 발생하지 않는다.</p> <h3 id="상호-배제-조건-깨기"> <a href="#상호-배제-조건-깨기" class="anchor-heading" aria-labelledby="상호-배제-조건-깨기"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 상호 배제 조건 깨기 </h3> <ul> <li>동시에 사용해도 괜찮은 자원을 사용</li> <li><code class="language-plaintext highlighter-rouge">스레드 수 &lt; 리소스 수</code> 가 되도록 리소스 증가</li> <li>자원 점유 전, 필요한 모든 자원이 있는지 확인 후 자원 점유</li> </ul> <p>-&gt; 사용하기 어려울 수 있음</p> <h3 id="잠금--대기-조건-깨기"> <a href="#잠금--대기-조건-깨기" class="anchor-heading" aria-labelledby="잠금--대기-조건-깨기"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 잠금 &amp; 대기 조건 깨기 </h3> <p>대기하지 않으면 데드락이 발생하지 않음, 각 자원 점유전에 확인해 어느 하나라도 점유하지 못하면 모든 리소스 반환</p> <p>잠재적인 문제</p> <ul> <li>기아: 한 스레드가 계속해서 자원을 점유하지 못함</li> <li>라이브락: 여러 스레드가 한번에 잠금 단계로 진입, 모두가 자원을 점유했다 포기했다를 반복 -&gt; CPU를 의미 없이 많이 사용하기도 함</li> </ul> <h3 id="선점-불가-조건-깨기"> <a href="#선점-불가-조건-깨기" class="anchor-heading" aria-labelledby="선점-불가-조건-깨기"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 선점 불가 조건 깨기 </h3> <p>자원을 뺏어오자!</p> <p>필요한 자원이 잠겨있다면, 풀어달라고 요청 -&gt; 요청을 받은 스레드: 다른 스레드의 자원을 대기하는 중이였다면, 잠금을 해재하고 처음부터 다시 기다림</p> <p>-&gt; 모든 요청을 관리하는 것이 어려움</p> <h3 id="순환-대기-조건-깨기"> <a href="#순환-대기-조건-깨기" class="anchor-heading" aria-labelledby="순환-대기-조건-깨기"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 순환 대기 조건 깨기 </h3> <p>가장 흔한 전략</p> <p>리소스 할당은 순서를 지정해, 순서에 맞게 할당 하도록 함</p> <p>잠재적인 문제</p> <ul> <li> <dl> <dt>자원을 할당하는 순서와 자원을 사용하는 순서가 다를지도 모른다.</dt> <dd>T1이 일찍 받았지만, 바로 사용하지 않고 이후에 사용할 수 있음 -&gt; 동시에 같은 리소스가 필요했던 T2는 더 오래 기다리게 됨</dd> </dl> </li> <li>때로는 순서에 따라 자원을 할당하기 어려움</li> </ul> <blockquote> <p>항상 모든 것은 트레이드 오프가 있고, 완벽한 해결책은 없다 스레드 관련 코드를 분리하면, 조율과 실험이 가능해 최적의 전략을 찾기 쉬워진다.</p> </blockquote> <h2 id="다중-스레드-코드-테스트"> <a href="#다중-스레드-코드-테스트" class="anchor-heading" aria-labelledby="다중-스레드-코드-테스트"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 다중 스레드 코드 테스트 </h2> <p>다중 스레드를 사용하는 부분에서 동시성 문제가 있는지 테스트하는 것은 매우 어렵다. 발생할 조건을 만들어도 매우 드물게 발생하기 때문에 테스트를 많이 진행해야 한두번 나올까 말까</p> <ul> <li>몬테 카를로 테스트 : 조율이 가능하게 유연한 테스트를 만들고, 임의로 값을 조절하며 테스트한다. -&gt; 테스트가 실패한 조건은 신중하게 기록한다.</li> <li>시스템을 배치할 모든 곳에서 테스트를 실행한다.</li> <li>부하가 변하는 장비에서 테스트를 실행한다.</li> </ul> <h2 id="스레드-코드-테스트를-도와주는-도구"> <a href="#스레드-코드-테스트를-도와주는-도구" class="anchor-heading" aria-labelledby="스레드-코드-테스트를-도와주는-도구"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 스레드 코드 테스트를 도와주는 도구 </h2> <p>conTest: IBM이 만든 도구로, 스레드에 안전하지 않은 코드에 보조 코드를 더해 실패할 가능성을 높여주는 도구</p> <p>사용하는 방법</p> <ul> <li>실제 코드와 테스트 코드를 작성</li> <li>conTest로 실제 코드와 테스트 코드에 보조 코드를 추가</li> <li>테스트 실행</li> </ul> <p>이전에는 천만~백만번에 한두번 나오던 실패가, 서른번에 한번정도로 실패</p> <h2 id="결론-1"> <a href="#결론-1" class="anchor-heading" aria-labelledby="결론-1"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 결론 </h2> <p>다중 시스템을 구현하려면 알아야 할 내용이 더 많다. <strong>더그 리</strong>의 <code class="language-plaintext highlighter-rouge">Concurrent Programming in Java: Design Principles and Patterns</code>를 추천한다.</p> </main> </div> </div> <div class="search-overlay"></div> </div> </body> </html>
