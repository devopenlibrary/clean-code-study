<!DOCTYPE html> <html lang="en"> <head> <meta charset="UTF-8"> <meta http-equiv="X-UA-Compatible" content="IE=Edge"> <link rel="stylesheet" href="/assets/css/just-the-docs-default.css"> <link rel="stylesheet" href="/assets/css/just-the-docs-head-nav.css" id="jtd-head-nav-stylesheet"> <style id="jtd-nav-activation"> .site-nav > ul.nav-list:first-child > li:not(:nth-child(14)) > a, .site-nav > ul.nav-list:first-child > li > ul > li a { background-image: none; } .site-nav > ul.nav-list:not(:first-child) a, .site-nav li.external a { background-image: none; } .site-nav > ul.nav-list:first-child > li:nth-child(14) > a { font-weight: 600; text-decoration: none; }.site-nav > ul.nav-list:first-child > li:nth-child(14) > button svg { transform: rotate(-90deg); }.site-nav > ul.nav-list:first-child > li.nav-list-item:nth-child(14) > ul.nav-list { display: block; } </style> <script src="/assets/js/vendor/lunr.min.js"></script> <script src="/assets/js/just-the-docs.js"></script> <meta name="viewport" content="width=device-width, initial-scale=1"> <!-- Begin Jekyll SEO tag v2.8.0 --> <title>13장 동시성 | Dev Open Library</title> <meta name="generator" content="Jekyll v3.10.0" /> <meta property="og:title" content="13장 동시성" /> <meta property="og:locale" content="en" /> <meta name="description" content="A minimal, responsive and feature-rich Jekyll theme for technical writing." /> <meta property="og:description" content="A minimal, responsive and feature-rich Jekyll theme for technical writing." /> <link rel="canonical" href="http://localhost:4000/chapter13-concurrency.html" /> <meta property="og:url" content="http://localhost:4000/chapter13-concurrency.html" /> <meta property="og:site_name" content="Dev Open Library" /> <meta property="og:type" content="website" /> <meta name="twitter:card" content="summary" /> <meta property="twitter:title" content="13장 동시성" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"WebPage","description":"A minimal, responsive and feature-rich Jekyll theme for technical writing.","headline":"13장 동시성","url":"http://localhost:4000/chapter13-concurrency.html"}</script> <!-- End Jekyll SEO tag --> </head> <body> <a class="skip-to-main" href="#main-content">Skip to main content</a> <svg xmlns="http://www.w3.org/2000/svg" class="d-none"> <symbol id="svg-link" viewBox="0 0 24 24"> <title>Link</title> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-link"> <path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path> </svg> </symbol> <symbol id="svg-menu" viewBox="0 0 24 24"> <title>Menu</title> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-menu"> <line x1="3" y1="12" x2="21" y2="12"></line><line x1="3" y1="6" x2="21" y2="6"></line><line x1="3" y1="18" x2="21" y2="18"></line> </svg> </symbol> <symbol id="svg-arrow-right" viewBox="0 0 24 24"> <title>Expand</title> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-chevron-right"> <polyline points="9 18 15 12 9 6"></polyline> </svg> </symbol> <!-- Feather. MIT License: https://github.com/feathericons/feather/blob/master/LICENSE --> <symbol id="svg-external-link" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-external-link"> <title id="svg-external-link-title">(external link)</title> <path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path><polyline points="15 3 21 3 21 9"></polyline><line x1="10" y1="14" x2="21" y2="3"></line> </symbol> <symbol id="svg-doc" viewBox="0 0 24 24"> <title>Document</title> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-file"> <path d="M13 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V9z"></path><polyline points="13 2 13 9 20 9"></polyline> </svg> </symbol> <symbol id="svg-search" viewBox="0 0 24 24"> <title>Search</title> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-search"> <circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"></line> </svg> </symbol> <!-- Bootstrap Icons. MIT License: https://github.com/twbs/icons/blob/main/LICENSE.md --> <symbol id="svg-copy" viewBox="0 0 16 16"> <title>Copy</title> <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-clipboard" viewBox="0 0 16 16"> <path d="M4 1.5H3a2 2 0 0 0-2 2V14a2 2 0 0 0 2 2h10a2 2 0 0 0 2-2V3.5a2 2 0 0 0-2-2h-1v1h1a1 1 0 0 1 1 1V14a1 1 0 0 1-1 1H3a1 1 0 0 1-1-1V3.5a1 1 0 0 1 1-1h1v-1z"/> <path d="M9.5 1a.5.5 0 0 1 .5.5v1a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5v-1a.5.5 0 0 1 .5-.5h3zm-3-1A1.5 1.5 0 0 0 5 1.5v1A1.5 1.5 0 0 0 6.5 4h3A1.5 1.5 0 0 0 11 2.5v-1A1.5 1.5 0 0 0 9.5 0h-3z"/> </svg> </symbol> <symbol id="svg-copied" viewBox="0 0 16 16"> <title>Copied</title> <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-clipboard-check-fill" viewBox="0 0 16 16"> <path d="M6.5 0A1.5 1.5 0 0 0 5 1.5v1A1.5 1.5 0 0 0 6.5 4h3A1.5 1.5 0 0 0 11 2.5v-1A1.5 1.5 0 0 0 9.5 0h-3Zm3 1a.5.5 0 0 1 .5.5v1a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5v-1a.5.5 0 0 1 .5-.5h3Z"/> <path d="M4 1.5H3a2 2 0 0 0-2 2V14a2 2 0 0 0 2 2h10a2 2 0 0 0 2-2V3.5a2 2 0 0 0-2-2h-1v1A2.5 2.5 0 0 1 9.5 5h-3A2.5 2.5 0 0 1 4 2.5v-1Zm6.854 7.354-3 3a.5.5 0 0 1-.708 0l-1.5-1.5a.5.5 0 0 1 .708-.708L7.5 10.793l2.646-2.647a.5.5 0 0 1 .708.708Z"/> </svg> </symbol> </svg> <div class="side-bar"> <div class="site-header" role="banner"> <a href="/" class="site-title lh-tight"> Dev Open Library </a> <button id="menu-button" class="site-button btn-reset" aria-label="Toggle menu" aria-pressed="false"> <svg viewBox="0 0 24 24" class="icon" aria-hidden="true"><use xlink:href="#svg-menu"></use></svg> </button> </div> <nav aria-label="Main" id="site-nav" class="site-nav"> <ul class="nav-list"><li class="nav-list-item"><a href="/" class="nav-list-link">Clean Code Study</a></li><li class="nav-list-item"><a href="/chapter1-clean-code.html" class="nav-list-link">1장 깨끗한 코드</a></li><li class="nav-list-item"><a href="/chapter2-meaningful-names.html" class="nav-list-link">2장 의미 있는 이름</a></li><li class="nav-list-item"><a href="/chapter3-function.html" class="nav-list-link">3장 함수</a></li><li class="nav-list-item"><a href="/chapter4-annotation.html" class="nav-list-link">4장 주석</a></li><li class="nav-list-item"><a href="/chapter5-consistent-formatting%20.html" class="nav-list-link">5장 형식 맞추기</a></li><li class="nav-list-item"><a href="/chpater6-obejct-and-data-structure.html" class="nav-list-link">6장 객체와 자료구조</a></li><li class="nav-list-item"><a href="/chapter7-error-handling.html" class="nav-list-link">7장 오류 처리</a></li><li class="nav-list-item"><a href="/chapter8-boundary.html" class="nav-list-link">8장 경계</a></li><li class="nav-list-item"><a href="/chapter9-unit-test.html" class="nav-list-link">9장 단위 테스트</a></li><li class="nav-list-item"><a href="/chapter10-class.html" class="nav-list-link">10장 클래스</a></li><li class="nav-list-item"><a href="/chapter11-system.html" class="nav-list-link">11장 시스템</a></li><li class="nav-list-item"><a href="/chapter12-emergence.html" class="nav-list-link">12장 창발성</a></li><li class="nav-list-item"><a href="/chapter13-concurrency.html" class="nav-list-link">13장 동시성</a></li><li class="nav-list-item"><a href="/chapter14-incremental-improvement.html" class="nav-list-link">14장 점진적인 개선</a></li><li class="nav-list-item"><a href="/chapter15-junit.html" class="nav-list-link">15장 JUnit</a></li><li class="nav-list-item"><a href="/chapter16-SerialDate-refactoring.html" class="nav-list-link">16장 SerialDate 리팩토링</a></li><li class="nav-list-item"><a href="/chapter17-smell-and-heuristic.html" class="nav-list-link">17장 냄새와 휴리스틱</a></li><li class="nav-list-item"><a href="/appendix-concurrency.html" class="nav-list-link">동시성</a></li></ul> </nav> <footer class="site-footer"> This site uses <a href="https://github.com/just-the-docs/just-the-docs">Just the Docs</a>, a documentation theme for Jekyll. </footer> </div> <div class="main" id="top"> <div id="main-header" class="main-header"> <div class="search" role="search"> <div class="search-input-wrap"> <input type="text" id="search-input" class="search-input" tabindex="0" placeholder="Search Dev Open Library" aria-label="Search Dev Open Library" autocomplete="off"> <label for="search-input" class="search-label"><svg viewBox="0 0 24 24" class="search-icon"><use xlink:href="#svg-search"></use></svg></label> </div> <div id="search-results" class="search-results"></div> </div> </div> <div class="main-content-wrap"> <div id="main-content" class="main-content"> <main> <h1 id="13장-동시성"> <a href="#13장-동시성" class="anchor-heading" aria-labelledby="13장-동시성"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 13장 동시성 </h1> <p>동시성과 깔끔한 코드는 양립하기 어렵다. 스레드 하나만 사용하는 코드는 작성하기 쉽지만, 동시성을 구현하려면 많은 고려가 필요하다.</p> <p>동시성 문제는 시스템이 부하를 받기 전까지는 잘 드러나지 않으며, 한 번 발생하면 재현하기도 어렵다.</p> <h2 id="동시성이-필요한-이유"> <a href="#동시성이-필요한-이유" class="anchor-heading" aria-labelledby="동시성이-필요한-이유"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 동시성이 필요한 이유? </h2> <p>동시성은 <strong>결합을 없애는 전략</strong>이다. 즉, <strong>무엇</strong>과 <strong>언제</strong>를 분리하는 전략이다.</p> <p><strong>무엇(What)</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>프로그램이 해야 하는 작업 자체
→ "파일 다운로드", "DB에 저장", "로그 출력"
</code></pre></div></div> <p><strong>언제(When)</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>그 작업을 실행하는 시점
    → "지금 바로 실행할지", "나중에 실행할지", "특정 조건이 충족될 때 실행할지"
</code></pre></div></div> <ul> <li>스레드가 하나인 프로그램에서는 <strong>무엇</strong>과 <strong>언제</strong>가 밀접하다.</li> <li><strong>무엇</strong>과 <strong>언제</strong>를 분리하면 애플리케이션 구조와 효율이 크게 향상된다. <ul> <li>예: 서블릿 <ul> <li>서블릿은 EJB 컨테이너가 동시성을 일부 관리해 준다.</li> <li>프로그래머는 모든 웹 요청을 직접 관리하지 않아도 된다.</li> <li>각 서블릿 스레드는 독립적으로 동작한다.</li> </ul> </li> </ul> </li> </ul> <p><strong>동시성이 필요한 상황</strong></p> <ul> <li><strong>구조적 개선</strong>을 위해 도입하는 경우도 있지만</li> <li>주로 <strong>응답 시간, 처리량</strong> 등의 요구사항으로 동시성이 불가피한 경우도 있다. <ul> <li>정보 수집기</li> <li>사용자 수가 많은 시스템</li> <li>대량의 데이터를 처리하는 시스템</li> </ul> </li> </ul> <h3 id="미신과-오해"> <a href="#미신과-오해" class="anchor-heading" aria-labelledby="미신과-오해"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 미신과 오해 </h3> <ul> <li> <p>동시성을 항상 성능을 높여준다.</p> <p>→ X: 대기 시간이 충분히 길거나 독립적 계산이 많을 때만 그렇다.</p> </li> <li> <p>동시성을 구현해도 설계는 변하지 않는다</p> <p>→ X: 무엇과 언제를 분리하면 시스템 설계 자체가 달라진다.</p> </li> <li> <p>웹 또는 EJB 컨테이너를 사용하면 동시성을 이해할 필요가 없다.</p> <p>→ X: 컨테이너 동작 방식, 동시 수정/데드락 회피 방법을 이해해야 한다.</p> </li> </ul> <p><strong>동시성의 어려운 이유</strong></p> <ul> <li>성능 부하: 락, 컨텍스트 스위칭 등으로 오버헤드 발생.</li> <li>복잡성 증가: 단순한 문제도 동시성 때문에 어렵다.</li> <li>버그 재현 어려움: 잠복 버그는 재현이 매우 힘들어 무시되기 쉽다.</li> <li>설계 복잡성: 근본적인 설계 전략부터 재검토해야 한다.</li> </ul> <h2 id="난관"> <a href="#난관" class="anchor-heading" aria-labelledby="난관"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 난관 </h2> <p>동시성을 구현하기 어려운 이유는</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">X</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">lastIdUsed</span><span class="o">;</span>

    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">getNextId</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="o">++</span><span class="n">lastIdUsed</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <p>lastIdUsed = 42인 상태에서 두 스레드가 동시에 <code class="language-plaintext highlighter-rouge">getNextId()</code> 호출 시:</p> <ol> <li>A 스레드: 43 / B 스레드: 44 → lastIdUsed = 44</li> <li>A 스레드: 44 / B 스레드: 43 → lastIdUsed = 44</li> <li>A 스레드: 43 / B 스레드: 43 → lastIdUsed = 43 (⚠️)</li> </ol> <p>스레드 간 동시 실행 경로는 수천~수만 개.</p> <p>일부 경로에서 잘못된 결과가 발생한다.</p> <h2 id="동시성-방어-원칙"> <a href="#동시성-방어-원칙" class="anchor-heading" aria-labelledby="동시성-방어-원칙"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 동시성 방어 원칙 </h2> <h3 id="단일-책임-원칙single-responsibility-principle-srp"> <a href="#단일-책임-원칙single-responsibility-principle-srp" class="anchor-heading" aria-labelledby="단일-책임-원칙single-responsibility-principle-srp"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 단일 책임 원칙Single Responsibility Principle, SRP </h3> <p>👉 <strong>동시성 관련 코드는 다른 코드와 분리해야 한다.</strong></p> <ul> <li>동시성 자체만으로도 충분히 복잡하다.</li> <li>다른 코드에 섞이면 유지보수 난이도가 급격히 올라간다.</li> <li>동시성 코드(락, 스레드 관리, 동기화)는 별도의 모듈로 분리하라.</li> </ul> <h3 id="따름-정리corollary-자료-범위를-제한하라"> <a href="#따름-정리corollary-자료-범위를-제한하라" class="anchor-heading" aria-labelledby="따름-정리corollary-자료-범위를-제한하라"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 따름 정리corollary: 자료 범위를 제한하라 </h3> <p><strong>👉 자료를 캡슐화 하고, 공유 자료를 최대한 줄여라.</strong></p> <p>공유 자원은 가능하면 피하고, 꼭 필요하다면:</p> <ul> <li><code class="language-plaintext highlighter-rouge">synchronized</code> 등으로 임계영역을 보호하라.</li> <li>임계영역의 범위를 최소화하라.</li> </ul> <p>공유 자원을 수정하는 코드가 많을수록:</p> <ul> <li>임계영역 보호를 빼먹기 쉽다.</li> <li>모든 임계영역을 올바르게 보호했는지 확인하는 데 많은 노력이 든다.</li> <li>찾기 어려운 동시성 버그는 더욱 찾기 어려워진다.</li> </ul> <h3 id="따름-정리-자료-사본을-사용하라"> <a href="#따름-정리-자료-사본을-사용하라" class="anchor-heading" aria-labelledby="따름-정리-자료-사본을-사용하라"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 따름 정리: 자료 사본을 사용하라 </h3> <p>가능한 경우, <strong>공유하지 말고 복사본을 만들어 사용</strong>하라.</p> <ul> <li>읽기 전용 객체는 복사해 사용.</li> <li>각 스레드가 자신만의 사본을 만들어 독립적으로 작업.</li> <li>결과가 필요하면 한 스레드가 사본에서 최종 결과를 모은다.</li> </ul> <p>예시</p> <ul> <li>불변 객체(Immutable Object) 사용.</li> <li>복사 생성자, 팩토리 메서드를 통한 복사.</li> <li>Thread-Local Storage.</li> </ul> <h3 id="따름-정리-스레드는-가능한-독립적으로-구현하라"> <a href="#따름-정리-스레드는-가능한-독립적으로-구현하라" class="anchor-heading" aria-labelledby="따름-정리-스레드는-가능한-독립적으로-구현하라"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 따름 정리: 스레드는 가능한 독립적으로 구현하라 </h3> <ul> <li>스레드 간 자료 공유를 피하라.</li> <li>각 스레드는 자신만의 데이터를 처리하도록 하라.</li> <li>로컬 변수만 사용하도록 설계하라.</li> </ul> <p>예시: 서블릿의 <code class="language-plaintext highlighter-rouge">doGet()</code>/<code class="language-plaintext highlighter-rouge">doPost()</code> 메서드</p> <ul> <li><code class="language-plaintext highlighter-rouge">HttpServlet</code>의 <code class="language-plaintext highlighter-rouge">doGet()</code>과 <code class="language-plaintext highlighter-rouge">doPost()</code>는 요청별로 새로운 스레드에서 실행되며, 로컬 변수만 사용한다면 <strong>동기화 문제가 발생할 여지가 없다.</strong></li> <li>각 요청 스레드가 <strong>독립적인 클라이언트 요청</strong>을 처리하고, 필요한 데이터는 <strong>비공유 출처</strong>에서 가져와 <strong>로컬 변수</strong>에 저장.</li> <li>결과적으로 스레드는 독립적이고 안전하게 동작한다.</li> </ul> <h2 id="라이브러리를-이해하라"> <a href="#라이브러리를-이해하라" class="anchor-heading" aria-labelledby="라이브러리를-이해하라"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 라이브러리를 이해하라 </h2> <p>👉 <strong>언어가 제공하는 클래스를 검토하라.</strong></p> <ol> <li>스레드 환경에 안전한 컬렉션을 사용한다. <ul> <li>Java 5 이상의 <code class="language-plaintext highlighter-rouge">java.util.concurren</code> 패키지 <ul> <li>이 컬렉션들은 다중 스레드 환경에서도 안전하게 동작하며, 성능까지 고려해 설계됨.</li> </ul> </li> </ul> </li> <li>서로 무관한 작업을 수행할 때는 executor 프레임워크를 사용한다. <ul> <li><code class="language-plaintext highlighter-rouge">ExecutorService</code>, <code class="language-plaintext highlighter-rouge">ScheduledExecutorService</code></li> <li>장점 <ul> <li>스레드 생성, 관리, 종료를 추상화.</li> <li>작업 큐 관리, 스레드 재사용, 에러 처리 등을 간단하게 처리.</li> </ul> </li> </ul> </li> <li>가능하다면 스레드가 차단되지 않는 방법을 사용한다. <ul> <li>락 대신 비차단 알고리즘 (lock-free, CAS 기반 연산 등) 사용. <ul> <li> <p>CAS (Compare-And-Swap) : CAS는 원자적(atomic) 연산 제공</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="nc">AtomicInteger</span> <span class="n">counter</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">AtomicInteger</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span>
  <span class="n">counter</span><span class="o">.</span><span class="na">compareAndSet</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">);</span> 
  <span class="c1">// counter가 0이면 1로 변경</span>
</code></pre></div> </div> </li> <li> <p>락을 사용하지 않고도 안전하게 변수 변경 가능. 실패하면 다시 시도</p> </li> </ul> </li> <li>동시성 유틸리티 (<code class="language-plaintext highlighter-rouge">Atomic*</code> 클래스, <code class="language-plaintext highlighter-rouge">LongAdder</code> 등) 활용.</li> <li>불필요한 대기를 줄이면 성능과 응답성이 향상됨.</li> </ul> </li> <li>일부 클래스 라이브러리는 스레드에 안전하지 못하다. <ul> <li><code class="language-plaintext highlighter-rouge">ArrayList</code>, <code class="language-plaintext highlighter-rouge">HashMap</code>, <code class="language-plaintext highlighter-rouge">SimpleDateFormat</code> 등.</li> <li>이런 클래스들을 사용할 때는: <ul> <li>외부에서 동기화를 직접 구현하거나,</li> <li>가능하면 스레드 안전한 대안으로 교체 (<code class="language-plaintext highlighter-rouge">ConcurrentHashMap</code>, <code class="language-plaintext highlighter-rouge">DateTimeFormatter</code> ).</li> </ul> </li> </ul> </li> </ol> <h3 id="스레드-환경에-안전한-컬렉션"> <a href="#스레드-환경에-안전한-컬렉션" class="anchor-heading" aria-labelledby="스레드-환경에-안전한-컬렉션"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 스레드 환경에 안전한 컬렉션 </h3> <p>👉 <strong>언어가 제공하는 클래스를 검토하라.</strong></p> <ul> <li>Java는 <strong>동시성 라이브러리</strong>를 제공한다.</li> <li>직접 구현하기 전에: <ul> <li><strong>표준 라이브러리</strong>에 유사 기능이 있는지 확인.</li> <li>성능, 안전성, 유지보수 측면에서 <strong>검증된 라이브러리</strong>를 우선 사용.</li> </ul> </li> </ul> <h2 id="실행-모델을-이해하라"> <a href="#실행-모델을-이해하라" class="anchor-heading" aria-labelledby="실행-모델을-이해하라"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 실행 모델을 이해하라 </h2> <p><strong>동시성 유형</strong></p> <div class="table-wrapper"><table> <thead> <tr> <th>문제</th> <th>설명</th> </tr> </thead> <tbody> <tr> <td>한정된 자원(Bound Resource)</td> <td>다중 스레드 환경에서 사용되는 크기나 수량이 제한된 자원은 기다림, 블로킹, 경쟁 조건 등을 유발 가능 (데이터베이스 연결, 읽기/쓰기 버퍼)</td> </tr> <tr> <td>상호 배제 (Mutual Exclusion)</td> <td>한 번에 한 스레드만 공유 자원/자료에 접근 가능.</td> </tr> <tr> <td>기아 (Starvation)</td> <td>특정 스레드가 자원을 계속 얻지 못해 영원히 기다림.예: 짧은 작업에 우선순위를 주면 긴 작업은 계속 기다리게 됨.</td> </tr> <tr> <td>데드락 (Deadlock)</td> <td>여러 스레드가 서로의 자원을 기다리며 진행 불가.모든 스레드가 멈춘 상태.</td> </tr> <tr> <td>라이브락 (Livelock)</td> <td>각 스레드가 진행하려 하지만 서로 양보/회피하다가 계속 교착 상태에 빠짐.진행은 되지만 아무것도 끝나지 않음.</td> </tr> </tbody> </table></div> <h3 id="생산자-소비자producer-consumer"> <a href="#생산자-소비자producer-consumer" class="anchor-heading" aria-labelledby="생산자-소비자producer-consumer"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 생산자-소비자Producer-Consumer </h3> <ul> <li>생산자 스레드: 데이터를 생성해 대기열(버퍼)에 넣음.</li> <li>소비자 스레드: 대기열에서 데이터를 꺼내 처리.</li> <li>문제 <ul> <li>생산자는 <strong>버퍼가 가득 차면</strong> 대기해야 함.</li> <li>소비자는 <strong>버퍼가 비면</strong> 대기해야 함.</li> <li>생산자와 소비자가 서로 시그널을 잘못 처리하면 <strong>둘 다 기다리는 상태</strong>에 빠질 수 있음.</li> </ul> </li> </ul> <h3 id="읽기-쓰기"> <a href="#읽기-쓰기" class="anchor-heading" aria-labelledby="읽기-쓰기"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> <strong>읽기-쓰기</strong> </h3> <p>다수의 <strong>읽기 스레드</strong>는 공유 자원 읽기 가능하지만 하나의 <strong>쓰기 스레드</strong>는 공유 자원을 갱신한다고 할 때</p> <ul> <li>문제 <ul> <li>처리율을 강조하면 기아 현상이나 오래된 정보가 쌓이고, 갱신을 허용하면 처리율에 영향을 미친다.</li> <li>처리율과 일관성의 균형 필요.</li> </ul> </li> <li><strong>해결 방법</strong> <ol> <li><strong>읽기 우선</strong> <ul> <li>쓰기 스레드는 읽기 스레드가 모두 끝나야 실행 가능.</li> <li>쓰기 스레드 기아(starvation) 위험.</li> </ul> </li> <li><strong>쓰기 우선</strong> <ul> <li>읽기 스레드는 쓰기 스레드가 끝나야 실행 가능.</li> <li>쓰기 스레드가 연속 실행되면 전체 처리율 저하.</li> </ul> </li> </ol> </li> </ul> <h3 id="식사하는-철학자들"> <a href="#식사하는-철학자들" class="anchor-heading" aria-labelledby="식사하는-철학자들"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> <strong>식사하는 철학자들</strong> </h3> <p>N명의 철학자가 식탁에 앉아 있다. 각 철학자는 양쪽 포크를 모두 잡아야 식사를 할 수 있다. 인접 철학자가 포크를 들고 있다면 기다려야 한다.</p> <p>여러 프로세스가 자원을 얻으려 경쟁하기 때문에 주의해서 설계하지 않으면 문제가 발생한다.</p> <p><strong>발생 가능한 문제</strong></p> <ul> <li>데드락: 서로 포크를 기다리며 멈춤.</li> <li>라이브락: 포크를 놓았다 잡았다 반복하며 진행 못함.</li> <li>처리율 저하, 기아 등.</li> </ul><hr /> <p>👉 <strong>위에서 설명한 기본 알고리즘과 각 해법을 이해하라.</strong></p> <p>동시성 문제를 단순히 “락 걸기”로만 해결하려 하지 말고:</p> <ul> <li><strong>자원 관리</strong>의 특성과 제한 이해.</li> <li><strong>데드락, 기아, 라이브락</strong> 가능성 고려.</li> <li>표준 알고리즘/패턴 적용: <ul> <li>생산자-소비자 → BlockingQueue, Condition 사용.</li> <li>읽기-쓰기 → ReadWriteLock.</li> <li>식사하는 철학자 → 리소스 순서 지정, 타임아웃 도입 등</li> </ul> </li> </ul> <p>을 고려해본다.</p> <h2 id="동기화하는-메서드-사이에-존재하는-의존성을-이해하라"> <a href="#동기화하는-메서드-사이에-존재하는-의존성을-이해하라" class="anchor-heading" aria-labelledby="동기화하는-메서드-사이에-존재하는-의존성을-이해하라"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 동기화하는 메서드 사이에 존재하는 의존성을 이해하라 </h2> <p>👉 <strong>원칙: 공유 객체 하나에는 동기화 메서드 하나만 사용하라.</strong></p> <p>공유 클래스의 여러 동기화 메서드가 서로 의존하면, 예상치 못한 문제가 발생할 수 있다. 멀티스레드 환경의 버그는 재현이 어렵고, 디버깅이 매우 힘들기 때문에 공유 객체는 하나의 메서드만 외부에서 접근 가능하도록 제한한다.</p> <p><strong>공유 객체 하나에 여러 메서드가 필요한 상황이라면?</strong></p> <div class="table-wrapper"><table> <thead> <tr> <th>방법</th> <th>설명</th> </tr> </thead> <tbody> <tr> <td>클라이언트에서 잠금</td> <td>클라이언트가 첫 번째 메서드 호출 전에 락을 획득하고, 마지막 메서드 호출 후 락 해제.</td> </tr> <tr> <td>서버에서 잠금</td> <td>서버(공유 객체)에서 여러 메서드를 묶어서 락을 걸고 하나의 통합 메서드 제공.</td> </tr> <tr> <td>연결 서버</td> <td>잠금을 담당하는 중간 계층(Wrapper, Facade)을 만들어서 관리. 서버 코드 수정 최소화.</td> </tr> </tbody> </table></div> <h2 id="동기화하는-부분을-작게-만들어라"> <a href="#동기화하는-부분을-작게-만들어라" class="anchor-heading" aria-labelledby="동기화하는-부분을-작게-만들어라"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 동기화하는 부분을 작게 만들어라 </h2> <p>같은 락으로 감싼 모든 코드 영역은 한 번에 한 스레드만 실행이 가능하다.</p> <p><code class="language-plaintext highlighter-rouge">synchronized</code>로 감싼 코드가 클수록:</p> <ul> <li>락 대기 시간이 증가</li> <li>스레드 간 병목 현상 발생</li> </ul> <p>해결 방법</p> <ul> <li> <p>임계영역(Critical Section)은 최소화</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="c1">// 불필요한 전체 메서드 락</span>
  <span class="kd">public</span> <span class="kd">synchronized</span> <span class="kt">void</span> <span class="nf">update</span><span class="o">()</span> <span class="o">{</span>
      <span class="n">somethingLong</span><span class="o">();</span> <span class="c1">// 오래 걸리는 작업</span>
      <span class="n">sharedList</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">"data"</span><span class="o">);</span> <span class="c1">// 실제 임계영역</span>
  <span class="o">}</span>
    
  <span class="c1">// 동기화 구간 최소화</span>
  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">updateData</span><span class="o">()</span> <span class="o">{</span>
      <span class="n">somethingLong</span><span class="o">();</span> <span class="c1">// 동기화 필요 없음</span>
      <span class="kd">synchronized</span> <span class="o">(</span><span class="n">sharedList</span><span class="o">)</span> <span class="o">{</span>
          <span class="n">sharedList</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">"data"</span><span class="o">);</span>
      <span class="o">}</span>
  <span class="o">}</span>
</code></pre></div> </div> </li> </ul> <h2 id="올바른-종료-코드는-구현하기-어렵다"> <a href="#올바른-종료-코드는-구현하기-어렵다" class="anchor-heading" aria-labelledby="올바른-종료-코드는-구현하기-어렵다"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 올바른 종료 코드는 구현하기 어렵다 </h2> <p>👉 <strong>종료 코드는 초기에 설계한다.</strong></p> <p>종료 처리는 나중에 붙이는 게 아니라 처음부터 고려하고, 동작하는 형태로 작성해야 한다.</p> <p>스레드 종료 처리는 단순히 종료 신호를 보내는 것으로 끝나지 않는다.</p> <p><strong>잘못된 종료 코드의 문제</strong></p> <ul> <li>데드락 (Deadlock)</li> <li>무한 대기 (스레드가 신호를 못 받아 영원히 블로킹)</li> <li>자원 해제 누락 (락, 파일, DB 연결 등)</li> </ul> <p><strong>부모-자식 스레드 종료 문제</strong></p> <p>부모 스레드가 여러 자식 스레드를 생성 → 자식 스레드 종료를 기다림 → 자원 해제 후 종료</p> <ul> <li>문제 <ul> <li>자식 스레드 중 하나가 데드락 상태 → 부모는 영원히 대기 → 프로그램 종료 불가</li> </ul> </li> </ul> <p><strong>생산자-소비자 종료 문제</strong></p> <ul> <li>소비자 스레드가 생산자의 시그널(데이터) 을 기다림</li> <li>부모 스레드가 종료 신호를 보내도, 소비자는 생산자의 데이터가 없으므로 차단 상태</li> <li> <p>결국 소비자는 종료 신호를 못 받고, 생산자도 소비자가 데이터를 가져갈 때까지 차단</p> <p>👉 데드락 발생</p> </li> </ul> <h2 id="스레드-코드-테스트하기"> <a href="#스레드-코드-테스트하기" class="anchor-heading" aria-labelledby="스레드-코드-테스트하기"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 스레드 코드 테스트하기 </h2> <ul> <li>말이 안 되는 실패는 잠정적인 스레드 문제로 취급하라</li> <li>다중 스레드를 고려하지 않은 순차 코드부터 제대로 돌게 만들자</li> <li>다중 스레드를 쓰는 코드 부분을 다양한 환경에 쉽게 끼워 넣을 수 있도록 스레드 코드를 구현하라</li> <li>다중 스레드를 쓰는 코드 부분을 상황에 맞춰 조정할 수 있게 작성하라</li> <li>프로세서 수보다 많은 스레드를 돌려보라</li> <li>다른 플랫폼에서 돌려보라</li> <li>코드에 보조 코드를 넣어 돌려라. 강제로 실패를 일으켜라.</li> </ul> <h3 id="말이-안-되는-실패는-잠정적인-스레드-문제로-취급하라"> <a href="#말이-안-되는-실패는-잠정적인-스레드-문제로-취급하라" class="anchor-heading" aria-labelledby="말이-안-되는-실패는-잠정적인-스레드-문제로-취급하라"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 말이 안 되는 실패는 잠정적인 스레드 문제로 취급하라 </h3> <ul> <li>다중 스레드 코드는 때때로 말이 안 되는 오류를 일으킨다.</li> <li>스레드 버그는 수백만 번에 한 번씩 드러나기도 한다.</li> <li>실패를 재현하기는 아주 어렵다.</li> <li>일회성 문제를 무시하지 말자</li> </ul> <h3 id="다중-스레드를-고려하지-않은-순차-코드부터-제대로-돌게-만들자"> <a href="#다중-스레드를-고려하지-않은-순차-코드부터-제대로-돌게-만들자" class="anchor-heading" aria-labelledby="다중-스레드를-고려하지-않은-순차-코드부터-제대로-돌게-만들자"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 다중 스레드를 고려하지 않은 순차 코드부터 제대로 돌게 만들자 </h3> <ul> <li>스레드 환경 밖에서 생기는 버그와 스레드 환경에서 생기는 버그를 동시에 디버깅하지 않고 스레드 환경 밖에서 코드가 제대로 도는지 반드시 확인한다.</li> <li>스레드가 호출하는 <strong>POJO</strong>를 만든다. POJO는 스레드를 모르기 때문에 스레드 환경 밖에서 테스트 가능하다.</li> </ul> <h3 id="다중-스레드를-쓰는-코드-부분을-다양한-환경에-쉽게-끼워-넣을-수-있게-스레드-코드를-구현하라"> <a href="#다중-스레드를-쓰는-코드-부분을-다양한-환경에-쉽게-끼워-넣을-수-있게-스레드-코드를-구현하라" class="anchor-heading" aria-labelledby="다중-스레드를-쓰는-코드-부분을-다양한-환경에-쉽게-끼워-넣을-수-있게-스레드-코드를-구현하라"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 다중 스레드를 쓰는 코드 부분을 다양한 환경에 쉽게 끼워 넣을 수 있게 스레드 코드를 구현하라 </h3> <ul> <li>한 스레드로 실행하거나, 여러 스레드로 실행하거나, 실행 중 스레드 수를 바꿔본다.</li> <li>스레드 코드를 실제 환경이나 테스트 환경에서 돌려본다.</li> <li>테스트 코드를 빨리, 천천히, 다양한 속도로 돌려본다.</li> <li>반복 테스트가 가능하도록 테스트 케이스를 작성한다.</li> <li>다양한 설정에서 실행한 목적은 다른 환경에 쉽게 끼워 넣을 수 있게 만드는 것.</li> </ul> <h3 id="다중-스레드를-쓰는-코드-부분을-상황에-맞게-조율할-수-있게-작성하라"> <a href="#다중-스레드를-쓰는-코드-부분을-상황에-맞게-조율할-수-있게-작성하라" class="anchor-heading" aria-labelledby="다중-스레드를-쓰는-코드-부분을-상황에-맞게-조율할-수-있게-작성하라"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 다중 스레드를 쓰는 코드 부분을 상황에 맞게 조율할 수 있게 작성하라 </h3> <ul> <li>적절한 스레드 개수를 파악하려면 시행착오가 필요하다.</li> <li>다양한 설정으로 프로그램의 성능을 측정하는 방법을 강구하라.</li> <li>스레드 개수를 조율하기 쉽게 코드를 구현하라.</li> <li>프로그램이 돌아가는 도중에 스레드 개수를 변경하는 방법도 고려하라.</li> <li>프로그램 처리율과 효율에 따라 스스로 스레드 개수를 조율하는 코드도 고민하라.</li> </ul> <h3 id="프로세서-수보다-많은-스레드를-돌려보라"> <a href="#프로세서-수보다-많은-스레드를-돌려보라" class="anchor-heading" aria-labelledby="프로세서-수보다-많은-스레드를-돌려보라"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 프로세서 수보다 많은 스레드를 돌려보라 </h3> <ul> <li>시스템이 스레드를 스와핑할 때 문제가 발생할 수 있다.</li> <li>스와핑을 일으키려면 프로세서 수보다 많은 스레드를 돌려라.</li> <li>스와핑이 잦을수록 임계영역을 빼먹은 코드나 데드락을 일으키는 코드를 찾기 쉬워진다.</li> </ul> <h3 id="다른-플랫폼에서-돌려보라"> <a href="#다른-플랫폼에서-돌려보라" class="anchor-heading" aria-labelledby="다른-플랫폼에서-돌려보라"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 다른 플랫폼에서 돌려보라 </h3> <ul> <li>다중 스레드 코드는 플랫폼에 따라 다르게 돌아간다.</li> <li>코드가 돌아갈 가능성이 있는 플랫폼 전부에서 테스트를 수행해야 한다.</li> </ul> <h3 id="코드에-보조-코드를-넣어-돌려라-강제로-실패를-일으키게-해보라"> <a href="#코드에-보조-코드를-넣어-돌려라-강제로-실패를-일으키게-해보라" class="anchor-heading" aria-labelledby="코드에-보조-코드를-넣어-돌려라-강제로-실패를-일으키게-해보라"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 코드에 보조 코드를 넣어 돌려라. 강제로 실패를 일으키게 해보라 </h3> <ul> <li>스레드 코드는 간단한 테스트로는 버그가 드러나지 않는다.</li> <li>스레드 버그는 실패하는 경로가 실행될 확률이 극도로 저조하다.</li> <li>버그를 발견하고 찾아내기가 아주 어렵다.</li> <li>보조 코드를 추가해 코드가 실행되는 순서를 바꿔 코드의 다양한 순서를 실행하라. <ul> <li>wait(), sleep(), yield(), priority()…</li> <li>각 메서드는 스레드가 실행되는 순서에 영향을 미치고 버그가 드러날 가능성도 높아진다. 잘못된 코드라면 가능한 초반에 가능한 자주 실패하는 편이 좋다.</li> </ul> </li> </ul> <p><strong>코드에 보조 코드를 추가하는 방법</strong></p> <ul> <li><strong>직접 구현</strong> <ul> <li> <p>코드에다 직접 wait(), sleep(), yield(), priority() 메서드를 추가한다.</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kd">public</span> <span class="kd">synchronized</span> <span class="nc">String</span> <span class="nf">nextUrlOrNull</span><span class="o">()</span> <span class="o">{</span>
      <span class="k">if</span> <span class="o">(</span><span class="n">hasNext</span><span class="o">())</span> <span class="o">{</span>
          <span class="nc">String</span> <span class="n">url</span> <span class="o">=</span> <span class="n">urlGenerator</span><span class="o">.</span><span class="na">next</span><span class="o">();</span>
          <span class="nc">Thread</span><span class="o">.</span><span class="na">yield</span><span class="o">();</span> <span class="c1">// 테스트를 위해 추가</span>
          <span class="n">updateHasNext</span><span class="o">();</span>
        
          <span class="k">return</span> <span class="n">url</span><span class="o">;</span>
      <span class="o">}</span>
            
      <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
  <span class="o">}</span>
</code></pre></div> </div> </li> <li> <p>문제</p> <ul> <li>보조 코드를 삽입할 적정 위치를 직적 찾아야 한다.</li> <li>어던 함수를 어디서 호출해야 적당한지 어떻게 알지?</li> <li>배포 환경에 보조 코드를 그대로 남겨두면 프로그램 성능이 떨어진다.</li> <li>무작위적이다. 오류가 드러날지도 모르고 드러나지 않을지도 모른다.</li> <li>실행할 때마다 설정을 바꿔줄 방법도 필요하다. 그래야 전체적으로 오류가 드러날 확률이 높아진다.</li> </ul> </li> </ul> </li> <li><strong>자동화</strong> <ul> <li> <p>AOF, CGLIB, ASM 등 도구를 사용해 자동화할 수 있다.</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kd">public</span> <span class="kd">class</span> <span class="nc">ThreadJigglePoint</span> <span class="o">{</span>
      <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">jiggle</span><span class="o">()</span> <span class="o">{</span>
  			<span class="c1">// sleep, yield, nop 무작위 수행</span>
      <span class="o">}</span>
  <span class="o">}</span>
        
  <span class="kd">public</span> <span class="kd">synchronized</span> <span class="nc">String</span> <span class="nf">nextUrlOrNull</span><span class="o">()</span> <span class="o">{</span>
      <span class="k">if</span> <span class="o">(</span><span class="n">hasNext</span><span class="o">())</span> <span class="o">{</span>
          <span class="nc">ThreadJigglePoint</span><span class="o">.</span><span class="na">jiggle</span><span class="o">();</span>
          <span class="nc">String</span> <span class="n">url</span> <span class="o">=</span> <span class="n">urlGenerator</span><span class="o">.</span><span class="na">next</span><span class="o">();</span>
          <span class="nc">ThreadJigglePoint</span><span class="o">.</span><span class="na">jiggle</span><span class="o">();</span>
          <span class="n">updateHasNext</span><span class="o">();</span>
          <span class="nc">ThreadJigglePoint</span><span class="o">.</span><span class="na">jiggle</span><span class="o">();</span>
        
          <span class="k">return</span> <span class="n">url</span><span class="o">;</span>
      <span class="o">}</span>
        
      <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
  <span class="o">}</span>
</code></pre></div> </div> <ul> <li><code class="language-plaintext highlighter-rouge">ThreadJigglePoint.jiggle()</code> 호출은 무작위로 <code class="language-plaintext highlighter-rouge">sleep()</code>, <code class="language-plaintext highlighter-rouge">yield()</code>, <code class="language-plaintext highlighter-rouge">nop</code>(아무 동작 안 함) 중 하나를 수행한다.</li> <li><code class="language-plaintext highlighter-rouge">jiggle()</code> 메서드를 비워두고 배포 환경에서 사용한다.</li> <li>무작위로 <code class="language-plaintext highlighter-rouge">nop</code>, <code class="language-plaintext highlighter-rouge">sleep</code>, <code class="language-plaintext highlighter-rouge">yield</code> 등을 테스트 환경에서 수행한다.</li> </ul> </li> </ul> </li> </ul> <h3 id="결론"> <a href="#결론" class="anchor-heading" aria-labelledby="결론"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 결론 </h3> <ul> <li>다중 스레드 코드는 올바르게 구현하기 어렵다.</li> <li>다중 스레드 코드를 작성한다면 각별히 깨끗하게 코드를 짜야 한다.</li> <li>SRP(단일 책임 원칙)를 준수하여 스레드를 아는 코드와 스레드를 모르는 코드로 분리한다.</li> <li>스레드 코드를 테스트할 때는 전적으로 스레드만 테스트한다.</li> <li>스레드 코드는 최대한 집약되고 작아야 한다.</li> <li>동시성 오류를 일으키는 잠정적인 원인을 철저히 이해해야 한다.</li> <li>사용하는 라이브러리의 기본 알고리즘을 이해해야 한다.</li> <li>보호할 코드 영역을 찾아내는 방법과 코드 영역을 잠그는 방법을 이해해야 한다.</li> <li>초반에 드러나지 않는 문제를 일회성으로 치부해 무시하면 안 된다.</li> <li>스레드 코드는 많은 플랫폼에서 많은 설정으로 반복해서 계속 테스트해야 한다.</li> <li>보조 코드를 추가해 오류가 드러날 가능성을 크게 높인다.</li> </ul> </main> </div> </div> <div class="search-overlay"></div> </div> </body> </html>
