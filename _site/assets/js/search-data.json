{"0": {
    "doc": "동시성",
    "title": "동시성",
    "content": " ",
    "url": "/appendix-concurrency.html",
    
    "relUrl": "/appendix-concurrency.html"
  },"1": {
    "doc": "동시성",
    "title": "클라이언트 / 서버 예제",
    "content": "클라이언트 - 서버 애플리케이션을 예시로 동시성에 대해 알아보자. 서버 . 아래와 같이 단일 스레드 방식의 클라이언트 - 서버 구조인 애플리케이션이 있다고 가정하자. | 서버: 소켓을 열어놓고 클라이언트가 연결하기를 기다림 . ServerSocket serverSocket = new ServerSocket(8009); while (keepProcessing) { try { Socket socket = serverSocket.accept(); process(socket); } catch (Exception e) { handle(e); } } . | 클라이언트: 소켓에 연결해 요청을 보냄 . private void connectSendReceive(int i) { try { Socket socket = new Socket(\"localhost\", PORT); MessageUtils.sendMessage(socket, Integer.toString(i)); MessageUtils.getMessage(socket); socket.close(); } catch (Exception e) { e.printStackTrace(); } } . | 테스트 코드 이때 이 코드가 잘 동작하는지 테스트 하기 위해, 아래 테스트 코드를 작성합니다. @Test(timeout = 10000) public void shouldRunInUnder10Seconds() throws Exception { Thread[] threads = createThreads(); startAllThreads(threads); waitForAllThreadsToFinish(threads); } . | 테스트 케이스는 동시성 작업 처리 능력을 검증하는 전형적인 예시로, 10,000밀리초 내에 끝나기를 검사 | 단일 스레드 서버는 한 번에 하나의 요청만 순차적으로 처리, 클라이언트 증가시 실패할 가능성이 매우 높음 | . | . 스레드 추가하기 . 해결하기 위해 가장 먼저 떠올릴 수 있는 방법은, 각 클라이언트 요청을 별도의 스레드에서 처리하는 것 . ServerSocket serverSocket = new ServerSocket(8009); while (keepProcessing) { try { Socket socket = serverSocket.accept(); // 요청이 들어올 때마다 새로운 스레드를 생성해 처리 new Thread(() -&gt; process(socket)).start(); } catch (Exception e) { handle(e); } } . : 서버는 클라이언트 요청을 받자마자 새 스레드에 작업을 위임 -&gt; 바로 다음 연결을 대기함 =&gt; 여러 클라이언트의 요청을 동시에 처리 가능함 . | I/O 바운드: 소켓 사용, DB연결, 가상 메모리 스와핑 등 대기하는 작업이 많음 -&gt; 동시성이 성능을 높일 수 있음 | CPU 바운드: 수치 계산, 정규식 처리, 가비지 컬렉션 등 연산하는 작업이 많음 -&gt; 하드웨어를 추가해 성능을 높일 수 있음 | . 서버 살펴보기 . | SRP 위반: 서버는 여러개의 책임을 지고 있음 . | 소켓 연결 관리 | 클라이언트 처리 | 스레드 정책 | 서버 종료 정책 | . | . 결론 . 단순히 스레드를 추가하는 것만으로는 견고한 동시성 시스템을 만들 수 없다. 이는 동시성이 야기하는 근본적인 문제들을 해결하지 못하기 때문이다. 깨끗한 동시성 코드를 작성하려면 실행 경로, 자원 공유, 데드락 등 더 깊은 이해가 필요하다. ",
    "url": "/appendix-concurrency.html#%ED%81%B4%EB%9D%BC%EC%9D%B4%EC%96%B8%ED%8A%B8--%EC%84%9C%EB%B2%84-%EC%98%88%EC%A0%9C",
    
    "relUrl": "/appendix-concurrency.html#클라이언트--서버-예제"
  },"2": {
    "doc": "동시성",
    "title": "가능한 실행 경로",
    "content": "경로 수 . public class IdGenerator{ int lastIdUsed; public int incrementValue() { return ++lastIdUsed; } } . 스레드가 1개라면 동일한 결과가 보장되지만, n개라면 다양한 결과가 나올 수 있다. 그 이유는 가능한 실행 경로 수와 JVM의 동작 방식을 알아야 한다. return ++lastIdUsed; . 이 한줄은 바이트 코드 8개가 해당되어, 스레드가 여러 개라면 명령 8개를 뒤섞어 실행할 가능성이 충분하다. 가능한 순열 수 계산하기 . | 위의 경우의 수 . \\[\\text{경로 수} = \\frac{(T \\times N)!}{(N!)^T}\\] . | 단계가 N, 스레드가 T라면 총 단게는 N * T개 | 정해진 순서를 위반하는 경우를 제거 | . | 코드를 변경한다면? . | . public synchronized void incrementValue(){ ++lastIdUsed; } . 가능한 경로의 수는 스레드 개수만큼으로 줄어든다. (단계가 사라짐) -&gt; 1개가 되지 않는다. 만약 . 심층 분석 . | 원자적 연산이란? . | 중단이 불가능한 연산을 원자적 연산이라고 정의함 | e.g. lastId = 0; | . | 자료형을 변경한다면? int -&gt; long . | 만약 자료형을 변경시, lastId = 0; 또한 원자적 연산이 될 수 없음 | . | 전처리 증가 연산자(++)는? . | 중단이 가능하기 때문에, 원자적 연산이 아님 | . | 바이트 코드를 보기전 알아야할 개념 . | 프레임: 호출 스택을 정의할 때 사용하는 표준 기법으로, 모든 메서드 호출에 는 프레임이 필요함 | 지역 변수: 메서드 내에 정의되는 모든 변수, this는 현재 스레드에서 가장 퇴근에 메시지를 받아 메서들르 호출한 객체를 가리킴 | 피연산자 스택: 매개변수를 저장하는 장소, LIFO 구조 | . | synchronized를 이용하면, incrementValue()는 해결됨 . | 동기화 되기 때문에 가능한 수(경로)는 여러개지만, 결과는 단 한개가 됨 | . | . ",
    "url": "/appendix-concurrency.html#%EA%B0%80%EB%8A%A5%ED%95%9C-%EC%8B%A4%ED%96%89-%EA%B2%BD%EB%A1%9C",
    
    "relUrl": "/appendix-concurrency.html#가능한-실행-경로"
  },"3": {
    "doc": "동시성",
    "title": "라이브러리를 이해하라",
    "content": "Executor 프레임워크 . 스레드와 관련된 프레임 워크로 Executor클래스와 Future를 이용해본다. 스레드를 차단하지 않는 방법 . 먼저 적용한 synchronized를 이용한 방법은 락을 이용한 방법으로 스레드를 차단한다. 동시성 문제가 크지 않을 때라면 괜찮지만, 많다면 성능에 문제가 생길 수 있다. CAS (Compare-And-Swap) 연산 . DB분야에서 낙관적 잠금이라는 개념과 유사, (동기화는 비관적 잠금 개념과 유사) . 3가지 값을 사용 . | 메모리의 현재 값 (V: Value): 지금 현재 공유 변수에 저장된 값입니다. | 예상되는 현재 값 (A: Expected Old Value): 스레드가 변수를 읽어와서 변경하려고 할 때 ‘내가 읽었을 때 이 값이 있었을 것이다’라고 예상하는 값입니다. | 새로운 값 (B: New Value): 스레드가 변수를 성공적으로 업데이트하고 싶은 새로운 값입니다. | . 다중 스레드 환경에서 안전하지 않은 클래스 . | 안전하지 않은 스레드 . | SimpleDateFormat | DB 연결 | java.util 컨테이너 클래스 | 서블릿 | . | 만약 아래 코드가 멀티스레드 환경에서 동작한다면 . if(!hashTable.containKey(someKey)) { hashTable.put(somekey, new SomeValeu()); } . | 클라이언트 기반 잠금: 사용하는 클라이언트가 잠금(synchronized)를 이용 | 서버 기반 잠금: 서버가 잠금(synchronized)를 이용 | 스레드에 안전한 집합 클래스를 사용 | . | . ",
    "url": "/appendix-concurrency.html#%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC%EB%A5%BC-%EC%9D%B4%ED%95%B4%ED%95%98%EB%9D%BC",
    
    "relUrl": "/appendix-concurrency.html#라이브러리를-이해하라"
  },"4": {
    "doc": "동시성",
    "title": "메서드 사이에 존재하는 의존성을 조심하라",
    "content": ". | 의존성을 만드는 예제 . public class IntegerIterator implements Iterator&lt;Integer&gt; { private Integer nextValue = 0; public synchronized boolean hasNext() { return nextValue &lt; 100000; } public synchronized Integer next() { if (nextValue == 100000) throw new IteratorPastEndException(); return nextValue++; } public synchronized Integer getNextValue() { return nextValue; } } . | 위 예제를 사용하는 코드 . IntegerIterator iterator = new IntegerIterator(); while(iterator.hasNext()) { int nextValue = iterator.next(); // nextValue를 뭔가 한다. } . | 문제상황 . | nextValue가 99999일 때, Thread 1이 hasNext()를 호출하면 true를 반환 | 그 사이에 Thread 2가 next()를 호출하여 nextValue를 100000으로 만들고, IteratorPastEndException을 발생 | Thread 1이 이어서 next()를 호출하면, 이미 nextValue가 100000이므로 IteratorPastEndException을 발생 | . | . 실패를 용인한다 . 떄로는 실패를 해도 괜찮도록 할 수 있다. e.g. 클라이언트가 예외를 받아 처리, 메모리 누수를 시간마다 재부팅하는 방식 . 클라이언트 - 기반 잠금 . IntegerIterator iterator = new IntegerIterator(); while(true){ int nextValue; synchronized (iterator){ if(!iterator.hasNext()) break; nextValue = iterator.next(); } doSomethingWith(nextValue); } . 각 클라이언트가 synchronized를 이용해 IntegerIterator객체에 락을 건다. -&gt; IntegerIterator를 이용하는 모든 프로그래머가 이를 기억해야함 (위험, 해결하기 어려움) . 서버 - 기반 잠금 . 클라이언트에서 중복해서 락을 걸지 않아도 된다. public class IntegerIteratorServerLocked { private Integer nextValue = 0; public synchronized Integer nextOrNull() { if(nextValue &lt; 100000) return nextValue++; else return null; } } . | 더 바람직한 이유 . | 코드 중복이 줄어듬 | 성능이 좋아짐: 단일 스레드 환경으로 시스템을 배치할 경우, 서버만 교체하면 오버헤드가 줄어든다. | 락 관리가 1곳이라, 위험이 줄어듬 | 스레드 정책이 1개 | 공유 변수 범위가 줄어듬 | . | 만약 서버 코드를 수정할 수 없다면? Adapter 패턴을 이용해 API를 변경한 후 잠금을 추가 | . ",
    "url": "/appendix-concurrency.html#%EB%A9%94%EC%84%9C%EB%93%9C-%EC%82%AC%EC%9D%B4%EC%97%90-%EC%A1%B4%EC%9E%AC%ED%95%98%EB%8A%94-%EC%9D%98%EC%A1%B4%EC%84%B1%EC%9D%84-%EC%A1%B0%EC%8B%AC%ED%95%98%EB%9D%BC",
    
    "relUrl": "/appendix-concurrency.html#메서드-사이에-존재하는-의존성을-조심하라"
  },"5": {
    "doc": "동시성",
    "title": "작업 처리량 높이기",
    "content": ". | synchronized의 영역은 언제나 작을수록 좋다. | . 가정 . | 페이지를 읽어오는 평균 I/O 시간 : 1초 | 페이지를 분석하는 평균 처리 시간 : 0.5초 | 처리는 CPU 100% 사용, I/O는 CPU 0% 사용 | . 작업 처리량 계산 - 단일 스레드 환경 . 만약 스레드 1개인 단일 스레드 환경에서, N개의 페이지를 처리한다면 =&gt; 실행시간은 총1.5초 * N 초 . 작업 처리량 계산 - 다중 스레드 환경 . 만약 순서와 무관하게 페이지를 독립적으로 읽어와 처리해도 된다면, 다중 스레드가 속도를 높이는데 도움이 될 수 있다. 3개의 스레드를 사용한다고 하면, I/O 작업이 발생하는 1초동안 2페이지의 내용을 처리할 수 있다. 즉 1초마다 2개의 페이지를 처리할 수있으므로, 단일 스레드 환경과 비교한다면 처리율을 3배다. ",
    "url": "/appendix-concurrency.html#%EC%9E%91%EC%97%85-%EC%B2%98%EB%A6%AC%EB%9F%89-%EB%86%92%EC%9D%B4%EA%B8%B0",
    
    "relUrl": "/appendix-concurrency.html#작업-처리량-높이기"
  },"6": {
    "doc": "동시성",
    "title": "데드락",
    "content": "데드락을 발생 시키는 조건 . | 상호 배제(Mutual exclusion) | 잠금 &amp; 대기(Lock &amp; Wait) | 선점 불가(No preemption) | 순환 대기(Circular Wait) | . 상호배제 . 여러 스레드가 한 자원을 공유하면서, . | 동시에 사용하지 못하며 | 개수가 제한적이라면 조건을 만족한다. | . e.g. DB 연결, 쓰기용 파일 열기, 레코드 락, 세마포어 등 . 잠금 &amp; 대기 . 자원을 점유하면, 필요한 나머지 자원까지 모두 점유한뒤 작업을 마칠 때까지 이미 점유한 자원을 내놓지 않음 . 선점 불가 . 한 스레드가 다른 스레드로부터 자원을 빼앗지 못함 -&gt; 스스로 내놓지 않으면 다른 스레드는 그 자원을 점유하지 못함 . 순환 대기 . 죽음의 포옴 2개의 스레드 (T1, T2)가 2개의 공유 자원(R1,R2)가 있을 때, T1 - R1, T2 - R2 이렇게 점유 된 상황에서 T1 -&gt; R2, T2 -&gt; R1f 이렇게 원하는 상황이라면 데드락이 발생한다. (서로 필요한 자원이 생기지 않아 자신의 자원을 놓지 않고 있으므로) . 위 4개의 조건 중 하나라도 깨버린다면, 데드락은 발생하지 않는다. 상호 배제 조건 깨기 . | 동시에 사용해도 괜찮은 자원을 사용 | 스레드 수 &lt; 리소스 수 가 되도록 리소스 증가 | 자원 점유 전, 필요한 모든 자원이 있는지 확인 후 자원 점유 | . -&gt; 사용하기 어려울 수 있음 . 잠금 &amp; 대기 조건 깨기 . 대기하지 않으면 데드락이 발생하지 않음, 각 자원 점유전에 확인해 어느 하나라도 점유하지 못하면 모든 리소스 반환 . 잠재적인 문제 . | 기아: 한 스레드가 계속해서 자원을 점유하지 못함 | 라이브락: 여러 스레드가 한번에 잠금 단계로 진입, 모두가 자원을 점유했다 포기했다를 반복 -&gt; CPU를 의미 없이 많이 사용하기도 함 | . 선점 불가 조건 깨기 . 자원을 뺏어오자! . 필요한 자원이 잠겨있다면, 풀어달라고 요청 -&gt; 요청을 받은 스레드: 다른 스레드의 자원을 대기하는 중이였다면, 잠금을 해재하고 처음부터 다시 기다림 . -&gt; 모든 요청을 관리하는 것이 어려움 . 순환 대기 조건 깨기 . 가장 흔한 전략 . 리소스 할당은 순서를 지정해, 순서에 맞게 할당 하도록 함 . 잠재적인 문제 . | 자원을 할당하는 순서와 자원을 사용하는 순서가 다를지도 모른다. T1이 일찍 받았지만, 바로 사용하지 않고 이후에 사용할 수 있음 -&gt; 동시에 같은 리소스가 필요했던 T2는 더 오래 기다리게 됨 | 때로는 순서에 따라 자원을 할당하기 어려움 | . 항상 모든 것은 트레이드 오프가 있고, 완벽한 해결책은 없다 스레드 관련 코드를 분리하면, 조율과 실험이 가능해 최적의 전략을 찾기 쉬워진다. ",
    "url": "/appendix-concurrency.html#%EB%8D%B0%EB%93%9C%EB%9D%BD",
    
    "relUrl": "/appendix-concurrency.html#데드락"
  },"7": {
    "doc": "동시성",
    "title": "다중 스레드 코드 테스트",
    "content": "다중 스레드를 사용하는 부분에서 동시성 문제가 있는지 테스트하는 것은 매우 어렵다. 발생할 조건을 만들어도 매우 드물게 발생하기 때문에 테스트를 많이 진행해야 한두번 나올까 말까 . | 몬테 카를로 테스트 : 조율이 가능하게 유연한 테스트를 만들고, 임의로 값을 조절하며 테스트한다. -&gt; 테스트가 실패한 조건은 신중하게 기록한다. | 시스템을 배치할 모든 곳에서 테스트를 실행한다. | 부하가 변하는 장비에서 테스트를 실행한다. | . ",
    "url": "/appendix-concurrency.html#%EB%8B%A4%EC%A4%91-%EC%8A%A4%EB%A0%88%EB%93%9C-%EC%BD%94%EB%93%9C-%ED%85%8C%EC%8A%A4%ED%8A%B8",
    
    "relUrl": "/appendix-concurrency.html#다중-스레드-코드-테스트"
  },"8": {
    "doc": "동시성",
    "title": "스레드 코드 테스트를 도와주는 도구",
    "content": "conTest: IBM이 만든 도구로, 스레드에 안전하지 않은 코드에 보조 코드를 더해 실패할 가능성을 높여주는 도구 . 사용하는 방법 . | 실제 코드와 테스트 코드를 작성 | conTest로 실제 코드와 테스트 코드에 보조 코드를 추가 | 테스트 실행 | . 이전에는 천만~백만번에 한두번 나오던 실패가, 서른번에 한번정도로 실패 . ",
    "url": "/appendix-concurrency.html#%EC%8A%A4%EB%A0%88%EB%93%9C-%EC%BD%94%EB%93%9C-%ED%85%8C%EC%8A%A4%ED%8A%B8%EB%A5%BC-%EB%8F%84%EC%99%80%EC%A3%BC%EB%8A%94-%EB%8F%84%EA%B5%AC",
    
    "relUrl": "/appendix-concurrency.html#스레드-코드-테스트를-도와주는-도구"
  },"9": {
    "doc": "동시성",
    "title": "결론",
    "content": "다중 시스템을 구현하려면 알아야 할 내용이 더 많다. 더그 리의 Concurrent Programming in Java: Design Principles and Patterns를 추천한다. ",
    "url": "/appendix-concurrency.html#%EA%B2%B0%EB%A1%A0-1",
    
    "relUrl": "/appendix-concurrency.html#결론-1"
  },"10": {
    "doc": "1장 깨끗한 코드",
    "title": "1장 깨끗한 코드",
    "content": ". | 주요 내용 . | 나쁜 코드를 작성하게되면 어떻게 되는지, 깨끗한 코드를 작성해야하는 이유 | 깨끗한 코드의 다양한 의견 | . | . ",
    "url": "/chapter1-clean-code.html",
    
    "relUrl": "/chapter1-clean-code.html"
  },"11": {
    "doc": "1장 깨끗한 코드",
    "title": "코드가 존재하리라",
    "content": ". | 코드를 자동으로 생성하는 시대가 오고, 그 때 프로그래머는 필요가 없다고 생각하는 사람들이 있지만 앞으로 코드가 사라질 가능성은 전혀없다. | 코드는 요구사항을 상세히 표현하는 수단이라, 어느 수준에 이르면 코드의 도움 없이 요구사항을 상세하게 표현하기란 불가능하다. | 궁금적으로 코드는 요구사항을 표현하는 언어라는 사실을 명심한다. | . ",
    "url": "/chapter1-clean-code.html#%EC%BD%94%EB%93%9C%EA%B0%80-%EC%A1%B4%EC%9E%AC%ED%95%98%EB%A6%AC%EB%9D%BC",
    
    "relUrl": "/chapter1-clean-code.html#코드가-존재하리라"
  },"12": {
    "doc": "1장 깨끗한 코드",
    "title": "나쁜 코드",
    "content": ". | 급하고 서두르느라 제대로 짤 시간이 없다고 생각해 나쁜 코드를 작성한다. | 그리고 우리 모두는 자신이 짠 쓰레기 코드를 쳐다보며 나중에 손보겠다고 생각한 경험이 있다. | 우리는 르블랑의 법칙(leblanc’s Law)을 몰랐고, 나중은 결코 오지 않는다. | . ",
    "url": "/chapter1-clean-code.html#%EB%82%98%EC%81%9C-%EC%BD%94%EB%93%9C",
    
    "relUrl": "/chapter1-clean-code.html#나쁜-코드"
  },"13": {
    "doc": "1장 깨끗한 코드",
    "title": "나쁜 코드로 치르는 대가",
    "content": "점점 생산성이 떨어진다. | 개발 속도가 프로젝트 초반에는 번개처럼 나가다가 1-2년만에 굼뱅이처럼 기어들어가는 팀도 많다. | 코드를 고칠 때마다 엉뚱한 곳에서 문제가 발생하거나, 나쁜 코드는 간단하게 변경할 수는 없어 코드를 해독한뒤 얽히고설킨 코드를 더한다. | . 원대한 재설계의 꿈 . | 생산성이 떨어져, 기존 팀을 나누어 재설계를 계획한다. | 재설계하는 팀은 기존 기능과 변경 내용을 모두 잡아야하고, 기존 팀은 변경 사항을 적용해야한다. | 이 과정은 재설계된 시스템이 완성될 때까지 진행되며, 오래걸릴 수 있다. | . 태도 . 계속 변경되는 요구사항과 일정이 촉박해 나쁜 코드를 작성했다고 생각하지만, 이 부분의 문제는 전적으로 프로그래머에게 있다. 우리가 일정이 부족하다면 제대로 정보를 제공해야 했기 때문이다. 만약, 환자가 의사에게 자신의 수술을 진행할 때 시간이 급하니 소독을 생략해달라해도 의사는 단호하게 거부할 것이다. 질병과 감염에 대해서는 의사자가 더 잘 알고, 의사가 그 행동을 따르는 것은 전문가답지 못하기 떄문이다. 원초적 난제 . | 나쁜 코드를 양산하면 기한을 맞추지 못하고, 오히려 엉망진창인 상태로 인해 속도가 늦어져 기한을 놓친다. | 빨리가는 유일한 방법은 언제나 코드를 최대한 깨끗하게 유지하는 습관이다. | . 깨끗한 코드라는 예술? . | 깨끗한 코드와 나쁜 코드를 구분할 줄 안다고 깨끗한 코드를 작성할 수 있다는 뜻은 아니다. | 깨끗한 코드를 작성하려면 ‘청결’이라는 힘겹게 습득한 감각을 활용해 자잘한 기법들은 적용하는 절제와 규율이 필요하다. | . 꺠끗한 코드란? . 아래의 내용은 각 사람이 생각하는 깨끗한 코드에 대한 의견이다. 이 생각이 절대적으로 ‘옳다’는 단정은 금물이다. | 비야네 스트롭스트룹 . | 보기에 즐거운 코드 | 논리는 간단하게 의존성을 줄이고 오류는 전략에 의거해 관리하며 성능을 최적으로 유지해야한다. | 한가지에 집중한다. 각 함수와 클래스와 모듈은 주변 상황에 현혹되거나 오염되지 않은 채 한길만 걷는다. | . | 데이브 토마스, 앤드 헌트: 깨진 창문(나쁜 코드는 나쁜 코드를 유혹한다.) | 그래디 부치: 잘 쓴 문장처럼 읽혀야한다. | 데이브 토마스 . | 작성자가 아닌 사람도 읽기 쉽고 고치기 쉽다. | 단위 테스트 케이스와 인수 테스트 케이스가 존재한다. | . | 마이클 페더스: 누군가 주의 깊게 썻다는 느낌을 준다. | 론 제프리스: 중복 줄이기, 표현력 높이기, 초반부터 간단한 추상화 고려하기 | 워드 커닝햄: 짐작했던 기능을 각 루틴이 그대로 수행단다면 깨끗한 코드다. = 코드를 독해하느라 머리를 쥐어짤 필요가 없어야한다. | . ",
    "url": "/chapter1-clean-code.html#%EB%82%98%EC%81%9C-%EC%BD%94%EB%93%9C%EB%A1%9C-%EC%B9%98%EB%A5%B4%EB%8A%94-%EB%8C%80%EA%B0%80",
    
    "relUrl": "/chapter1-clean-code.html#나쁜-코드로-치르는-대가"
  },"14": {
    "doc": "1장 깨끗한 코드",
    "title": "우리는 저자다",
    "content": ". | javadoc에서 @author 필드는 저자를 소개한다. 우리는 저자다. | 저자에게는 독자가 있고, 독자와 잘 소통할 책임도 있다. 코드를 작성할 때 이 점을 잊지말자. | 새 코드를 짜면서 우리는 끊임없이 기존 코드를 읽는다. 그래서 읽기 쉬운 코드가 매우 중요하다. | . ",
    "url": "/chapter1-clean-code.html#%EC%9A%B0%EB%A6%AC%EB%8A%94-%EC%A0%80%EC%9E%90%EB%8B%A4",
    
    "relUrl": "/chapter1-clean-code.html#우리는-저자다"
  },"15": {
    "doc": "1장 깨끗한 코드",
    "title": "보이스카우트 규칙",
    "content": "캠프장은 처음 왔을 때보다 더 깨끗하게 해놓고 떠나라 . 미국 보이스카우트가 따르는 간단한 규칙 . | 시간이 지나도 언제나 깨끗하게 유지해야한다. | . ",
    "url": "/chapter1-clean-code.html#%EB%B3%B4%EC%9D%B4%EC%8A%A4%EC%B9%B4%EC%9A%B0%ED%8A%B8-%EA%B7%9C%EC%B9%99",
    
    "relUrl": "/chapter1-clean-code.html#보이스카우트-규칙"
  },"16": {
    "doc": "1장 깨끗한 코드",
    "title": "읽고 느낀 점",
    "content": "실제 코드를 작성할 때, 일단 작성해놓고 나중에 수정하자 라고 생각했던 적이 많았습니다. 지금 이 내용을 읽으며 그때 진짜 다시 수정한 것이 얼마나 되었나를 생각해보게 되었고, 나쁜 코드를 작성하는 일이 주는 영향에 대해 다시 생각해 보게 되었습니다. 그리고 그만큼 깨끗한 코드의 다양한 생각을 읽고, 왜 그렇게 생각했나를 고민해보며 각 생각이 표현이 다를 뿐 통일된 내용을 의미한다고 생각했습니다. ",
    "url": "/chapter1-clean-code.html#%EC%9D%BD%EA%B3%A0-%EB%8A%90%EB%82%80-%EC%A0%90",
    
    "relUrl": "/chapter1-clean-code.html#읽고-느낀-점"
  },"17": {
    "doc": "10장 클래스",
    "title": "10장 클래스",
    "content": " ",
    "url": "/chapter10-class.html",
    
    "relUrl": "/chapter10-class.html"
  },"18": {
    "doc": "10장 클래스",
    "title": "클래스 체계",
    "content": "클래스를 만들 때는 변수와 함수의 위치와 순서를 체계적으로 정리한다. class { // 변수 public static final ... // 정적 공개 상수 private static ... // 정적 비공개 변수 private ... // 비공개 인스턴스 변수 // 함수 public ... // 공개 함수 (필요 시 비공개 함수 호출) private ... // ↪ 유틸리티 등 비공개 함수 } . 변수는 역할에 따라 가시성을 신중히 조정해야 하며, 공개 함수는 필요한 동작만 외부에 노출해야 한다. 캡슐화 . 캡슐화를 풀어주는 결정은 언제나 최후의 수단이다. | 내부 구현을 외부에 숨기고 필요한 부분만 공개한다. | 내부 구현을 외부에서 함부로 건드릴 수 없다. | 변경이 필요한 경우에도 내부만 수정하면 된다. | . | 테스트나 동일 패키지 내에서 접근이 꼭 필요하다면 protected나 패키지 접근 수준(default)을 고려할 수 있지만, 항상 감추는 것이 기본이다. | . ",
    "url": "/chapter10-class.html#%ED%81%B4%EB%9E%98%EC%8A%A4-%EC%B2%B4%EA%B3%84",
    
    "relUrl": "/chapter10-class.html#클래스-체계"
  },"19": {
    "doc": "10장 클래스",
    "title": "클래스는 작아야 한다",
    "content": "클래스도 함수와 마찬가지로 작고 명확해야 한다. | 한 클래스가 너무 많은 책임을 지고 있다면, 코드가 복잡해지고 수정이 어려워진다. | 클래스의 크기는 클래스가 맡은 책임으로 센다. | 클래스 이름은 해당 클래스 책임을 기술해야 한다. | 간결한 이름이 떠오르지 않는다면 클래스 크기가 너무 커서 그렇다. | 클래스 이름이 모호하다면 클래스 책임이 너무 많진 않은지 생각해봐야 한다. | . | . 👎👎👎 . // 클래스 책임이 수억개 public class SuperDashboard extends JFrame implements MetaDataUser { public String getCustomizerLanguagePath() public void setSystemConfigPath(String systemConfigPath) public String getSystemConfigDocument() public void setSystemConfigDocument(String systemConfigDocument) public boolean getGuruState() public boolean getNoviceState() public boolean getOpenSourceState() public void showObject(MetaObject object) public void showProgress(String s) public boolean isMetadataDirty() public void setIsMetadataDirty(boolean isMetadataDirty) public Component getLastFocusedComponent() public void setLastFocused(Component lastFocused) public void setMouseSelectState(boolean isMouseSelected) public boolean isMouseSelected() public LanguageManager getLanguageManager() public Project getProject() public Project getFirstProject() public Project getLastProject() public String getNewProjectName() public void setComponentSizes(Dimension dim) public String getCurrentDir() public void setCurrentDir(String newDir) public void updateStatus(int dotPos, int markPos) public Class[] getDataBaseClasses() // ... 그 외 수많은 공개/비공개 메서드 ... // ~~ 중략 ~~ } . 👎👎👎 . // 메소드는 5개지만 책임도 여러개 public class SuperDashboard extends JFrame implements MetaDataUser { public Component getLastFocusedComponent() public void setLastFocused(Component lastFocused) public int getMajorVersionNumber() public int getMinorVersionNumber() public int getBuildNumber() } . 단일 책임 원칙(SRP, Single Responsibility Principle) . 클래스는 하나의 책임만 가지고 있어야 한다. 클래스나 모듈을 변경할 이유는 하나뿐이어야 한다. 👍👍👍 . // 버전 정보를 다루는 메서드 3개를 따로 빼서 // Version 이라는 독자적인 클래스를 만들어 다른 곳에서 재사용하기 쉬워졌다. public class Version { public int getMajorVersionNumber() public int getMinorVersionNumber() public int getBuildNumber() } . 이렇게 책임을 나누면, 하나의 기능을 변경할 때 다른 기능에 영향을 주지 않게 된다. 응집도(Cohesion) . 클래스 내 메서드들이 동일한 데이터에 관심이 없을 경우, 분리할 필요가 있다는 신호이다. | 응집도: 클래스 내부의 메서드와 변수들이 서로 밀접하게 연관되어 있음을 말한다. | 응집도가 높으면 클래스가 자기 역할에 집중하고, 다른 역할을 침범하지 않는다. | . | 메서드가 인스턴스 변수를 많이 쓸수록 응집도가 높다. | 응집도가 낮으면, 클래스를 나누는 것을 고려해야 한다. | . 👍👍👍 . // 높은 응집도 public class Stack { private int topOfStack = 0; List&lt;Integer&gt; elements = new LinkedList&lt;Integer&gt;(); public int size() { return topOfStack; } public void push(int element) { topOfStack++; elements.add(element); } public int pop() throws PoppedWhenEmpty { if (topOfStack == 0) throw new PoppedWhenEmpty(); int element = elements.get(--topOfStack); elements.remove(topOfStack); return element; } } . 응집도를 유지하면 작은 클래스 여럿이 나온다 . | 하나의 큰 클래스를 만들기보다는 작은 책임을 가진 클래스들로 쪼개는 것이 바람직하다. | 클래스를 쪼개면 응집도는 유지되고, 클래스는 자연스럽게 작아진다. | . 👎👎👎 . public class PrintPrimes { public static void main(String[] args) { final int M = 1000; final int RR = 50; final int CC = 4; final int WW = 10; final int ORDMAX = 30; int P[] = new int[M + 1]; int PAGENUMBER; int PAGEOFFSET; int ROWOFFSET; int C; int J; int K; boolean JPRIME; int ORD; int SQUARE; int N; int MULT[] = new int[ORDMAX + 1]; J = 1; K = 1; P[1] = 2; ORD = 2; SQUARE = 9; while (K &lt; M) { do { J = J + 2; if (J == SQUARE) { ORD = ORD + 1; SQUARE = P[ORD] * P[ORD]; MULT[ORD - 1] = J; } N = 2; JPRIME = true; while (N &lt; ORD &amp;&amp; JPRIME) { while (MULT[N] &lt; J) MULT[N] = MULT[N] + P[N] + P[N]; if (MULT[N] == J) JPRIME = false; N = N + 1; } } while (!JPRIME); K = K + 1; P[K] = J; } { PAGENUMBER = 1; PAGEOFFSET = 1; while (PAGEOFFSET &lt;= M) { System.out.println(\"The First \" + M + \" Prime Numbers --- Page \" + PAGENUMBER); System.out.println(\"\"); for (ROWOFFSET = PAGEOFFSET; ROWOFFSET &lt; PAGEOFFSET + RR; ROWOFFSET++) { for (C = 0; C &lt; CC; C++) if (ROWOFFSET + C * RR &lt;= M) System.out.format(\"%10d\", P[ROWOFFSET + C * RR]); System.out.println(\"\"); } System.out.println(\"\\f\"); PAGENUMBER = PAGENUMBER + 1; PAGEOFFSET = PAGEOFFSET + RR * CC; } } } } 1. 명확하지 않은 변수명 2. 단일 main 메서드에 모든 로직 집중 (책임 분리x) 3. 하드코딩된 상수 및 매직 넘버 4. 복잡한 제어 흐름 . 👍👍👍 각 책임을 클래스로 나누면? . // 실행 담당 public class PrimePrinter { public static void main(String[] args) { final int NUMBER_OF_PRIMES = 1000; int[] primes = PrimeGenerator.generate(NUMBER_OF_PRIMES); final int ROWS_PER_PAGE = 50; final int COLUMNS_PER_PAGE = 4; RowColumnPagePrinter tablePrinter = new RowColumnPagePrinter(ROWS_PER_PAGE, COLUMNS_PER_PAGE, \"The First \" + NUMBER_OF_PRIMES + \" Prime Numbers\"); tablePrinter.print(primes); } } // 프린트 포맷 담당 public class RowColumnPagePrinter { private int rowsPerPage; private int columnsPerPage; private int numbersPerPage; private String pageHeader; private PrintStream printStream; public RowColumnPagePrinter(int rowsPerPage, int columnsPerPage, String pageHeader) { this.rowsPerPage = rowsPerPage; this.columnsPerPage = columnsPerPage; this.pageHeader = pageHeader; numbersPerPage = rowsPerPage * columnsPerPage; printStream = System.out; } public void print(int data[]) { int pageNumber = 1; for (int firstIndexOnPage = 0; firstIndexOnPage &lt; data.length; firstIndexOnPage += numbersPerPage) { int lastIndexOnPage = Math.min(firstIndexOnPage + numbersPerPage - 1, data.length - 1); printPageHeader(pageHeader, pageNumber); printPage(firstIndexOnPage, lastIndexOnPage, data); printStream.println(\"\\f\"); pageNumber++; } } private void printPage(int firstIndexOnPage, int lastIndexOnPage, int[] data) { int firstIndexOfLastRowOnPage = firstIndexOnPage + rowsPerPage - 1; for (int firstIndexInRow = firstIndexOnPage; firstIndexInRow &lt;= firstIndexOfLastRowOnPage; firstIndexInRow++) { printRow(firstIndexInRow, lastIndexOnPage, data); printStream.println(\"\"); } } ... } // 소수 판별 담당 public class PrimeGenerator { private static int[] primes; private static ArrayList&lt;Integer&gt; multiplesOfPrimeFactors; protected static int[] generate(int n) { primes = new int[n]; multiplesOfPrimeFactors = new ArrayList&lt;Integer&gt;(); set2AsFirstPrime(); checkOddNumbersForSubsequentPrimes(); return primes; } private static void set2AsFirstPrime() { primes[0] = 2; multiplesOfPrimeFactors.add(2); } private static void checkOddNumbersForSubsequentPrimes() { int primeIndex = 1; for (int candidate = 3; primeIndex &lt; primes.length; candidate += 2) { if (isPrime(candidate)) primes[primeIndex++] = candidate; } } private static boolean isPrime(int candidate) { if (isLeastRelevantMultipleOfNextLargerPrimeFactor(candidate)) { multiplesOfPrimeFactors.add(candidate); return false; } return isNotMultipleOfAnyPreviousPrimeFactor(candidate); } ... } 1. 좀 더 길고 서술적인 변수명 사용 2. 함수 선언과 클래스 선언으로 코드를 설명 3. 가독성을 위해 공백을 추가 및 형식 맞춤 . 클래스는 작아지고 각자의 책임에 집중할 수 있다. | 가장 먼저 원래 프로그램의 정확한 동작을 검증하는 테스트 슈트를 작성하라. | 그 다음 한번에 하나씩 여러번에 걸쳐 코드를 변경하고, | 코드를 변경 할 때 마다 테스트를 수행해 원래 프로그램과 동일하게 동작하는지 확인하라. | . ",
    "url": "/chapter10-class.html#%ED%81%B4%EB%9E%98%EC%8A%A4%EB%8A%94-%EC%9E%91%EC%95%84%EC%95%BC-%ED%95%9C%EB%8B%A4",
    
    "relUrl": "/chapter10-class.html#클래스는-작아야-한다"
  },"20": {
    "doc": "10장 클래스",
    "title": "변경하기 쉬운 클래스",
    "content": "우리가 작성하는 대부분의 소프트웨어는 시간이 지나면서 변경이 필요해진다(위험 ⏫). 클래스가 체계적으로 정리되어 있으면 변경도 훨씬 쉬워진다. | 공개할 필요 없는 메서드는 반드시 감춘다. | 외부 클래스와의 불필요한 결합을 피하기 위함 | . | . 👎👎👎 . public class Sql { public Sql(String table, Column[] columns) public String create() public String insert(Object[] fields) public String selectAll() public String findByKey(String keyColumn, String keyValue) public String select(Column column, String pattern) public String select(Criteria criteria) public String preparedInsert() private String columnList(Column[] columns) private String valuesList(Object[] fields, final Column[] columns) private String selectWithCriteria(String criteria) private String placeholderList(Column[] columns) } . 👍👍👍 . abstract public class Sql { public Sql(String table, Column[] columns) abstract public String generate(); } public class CreateSql extends Sql { public CreateSql(String table, Column[] columns) @Override public String generate() } public class SelectSql extends Sql { public SelectSql(String table, Column[] columns) @Override public String generate() } ... // update 문을 추가 할때 기존 클래스를 변경할 필요가 없다. // 테스트 관점에서도 모든 논리를 검증하고 증명하기 쉬워졌다. 변경으로부터 격리 . 상세 구현보다 추상화에 의존하라 . | 구현에 직접 의존하는 코드는 변경에 취약하다. 인터페이스나 추상 클래스를 통해 구현 세부사항을 감추고, 변경으로부터 코드를 격리해야 한다. | 추상화에 의존하면 결합도가 낮아지고, 테스트도 쉬워지며 재사용성과 유연성도 높아진다. | . 예시) . Portfolio라는 클래스가 외부 TokyoStockExchange API를 사용한다고 할 때, . // 5분마다 값이 달라지는 주식 시세를 가져오는 API public interface StockExchange { Money currentPrice(String symbol); } . Portfolio는 직접 API를 호출하지 않고 StockExchange 인터페이스에 의존한다. TokyoStockExchange는 이 인터페이스를 구현한다. public class Portfolio { private StockExchange exchange; public Portfolio(StockExchange exchange) { this.exchange = exchange; } // ... } . Portfolio 생성자에서 StockExchange를 인수로 받는다. public class PortfolioTest { private FixedStockExchangeStub exchange; private Portfolio portfolio; @Before public void setUp() { exchange = new FixedStockExchangeStub(); exchange.fix(\"MSFT\", 100); portfolio = new Portfolio(exchange); } @Test public void testTotalValue() { portfolio.add(5, \"MSFT\"); Assert.assertEquals(500, portfolio.value()); } } . 결과적으로 실제 주가를 어디서 어떻게 가져오는지는 숨기고, Portfolio는 StockExchange라는 인터페이스에만 의존하므로 훨씬 유연하고 관리하기 쉬워진다. | 결합도를 낮추면 유연성과 재사용성이 높아진다. | 각 요소가 서로 독립적이고, 변경에 덜 민감해진다. | 시스템 요소가 서로 잘 격리되어 있으면 각 요소를 이해하기 더 쉽다. | . | 결합도를 최소로 줄이면 자연스럽게 DIP(Dependency Inversion Principle)를 따르는 클래스가 나온다. | DIP : 클래스가 상세한 구현이 아니라 추상화에 의존해야 한다는 원칙 | . | . ",
    "url": "/chapter10-class.html#%EB%B3%80%EA%B2%BD%ED%95%98%EA%B8%B0-%EC%89%AC%EC%9A%B4-%ED%81%B4%EB%9E%98%EC%8A%A4",
    
    "relUrl": "/chapter10-class.html#변경하기-쉬운-클래스"
  },"21": {
    "doc": "10장 클래스",
    "title": "요약",
    "content": ". | 클래스는 변수와 함수를 체계적으로 배치한다. | 캡슐화로 내부를 숨기고, 꼭 필요한 부분만 공개한다. | 클래스는 작고 단일 책임 원칙을 지켜야 한다. | 응집도가 높아야 클래스가 자기 역할에 집중할 수 있다. | 변경에 대비해 추상화와 낮은 결합도를 설계한다. | . ",
    "url": "/chapter10-class.html#%EC%9A%94%EC%95%BD",
    
    "relUrl": "/chapter10-class.html#요약"
  },"22": {
    "doc": "11장 시스템",
    "title": "11장 시스템",
    "content": "“복잡성은 죽음이다. 개발자에게서 생기를 앗아가며, 제품을 걔획하고 제작하고 테스트하기 어렵게 만든다” - 레이 오지, 마이크로소프트 CTO . ",
    "url": "/chapter11-system.html",
    
    "relUrl": "/chapter11-system.html"
  },"23": {
    "doc": "11장 시스템",
    "title": "도시를 세운다면?",
    "content": "만약 나 혼자서 도시를 세운다고 생각해보자. 도시에서 돌아가는 모든 세세한 일을 다 관리할 수는 없을 것이다. 흔히 소프트웨어 팀도 도시처럼 구성한다. 도시(소프트웨어 팀)는 수도 관리팀, 전력관리팀, 교통 관리 팀 등 각 분야를 관리하는 팀으로 돌아간다. 또한, 도시가 돌아가는 또다른 이유는 적절한 추상화와 모듈화 때문이다. 그래서 큰 그림을 이해하지 못할지라도 개인개인이 관리하는 ‘구성요소’는 효율적으로 돌아간다. 깨끗한 코드를 구현하면 낮은 추상화 수준에서 관심사를 분리하기 쉬워진다. 이 장에서는 높은 추상화 수준, 즉 시스템 수준에서도 깨끗함을 유지하는 방법을 살펴본다. ",
    "url": "/chapter11-system.html#%EB%8F%84%EC%8B%9C%EB%A5%BC-%EC%84%B8%EC%9A%B4%EB%8B%A4%EB%A9%B4",
    
    "relUrl": "/chapter11-system.html#도시를-세운다면"
  },"24": {
    "doc": "11장 시스템",
    "title": "시스템 제작과 시스템 사용을 분리하라",
    "content": "우선 제작(construction)과 사용(use)은 아주 다르다는 사실을 명심한다. 예를 들어, 호텔을 새로 짓는다고 가정하자. 콘크리트 상자에 기중기와 승강기가 부착되어있고, 안전모에 작업복을 착용한 사람들이 바쁘게 움직인다. 1년 정도면 호텔은 완공된다. 호텔이 완공되면 기중기와 승강기는 사라진다. 건물은 유리벽과 예쁜 색상의 벽으로 말끔히 꾸며지고, 호텔에 근무하고 채류하는 사람들은 호텔을 지을때 근무하던 사람들과 아주 다른 차림새를 하고 있을 것이다. 소프트웨이 시스템은 (애플리케이션 객체를 제작하고 의존성을 서로 ‘연결’하는) 준비 과정과 (준비 과정 이후에 이이지는) 런타임 로직을 분리해야 한다. 시작 단계는 모든 애플리케이션이 풀어야 할 관심사다. 이것이 이 장에서 우리가 맨 처음 살펴볼 관심사다. 관심사 분리는 우리 분야에서 가장 오래되고 가장 중요한 설계 기법 중 하나다. 다음은 시작 단계 코드를 주먹구구식으로 구현할 뿐만 아니라 린타임 로직과 마구 뒤섞어 놓은 전형적인 예다. public Service getService() { if (service = null) service = new MyServiceImpl(... ) ; // 모든 상황에 적합한 기본값일까? return service; } . 이것은 초기화 지연(Lazy initializaton) 혹은 계산 지연(Lazy Evaluaton)이라는 기법이다. 초기화 지연은 객체나 데이터, 또는 계산 비용이 큰 리소스의 초기화를 그것이 실제로 필요할 때까지 미루는 프로그래밍 기법이다. 즉, 객체나 데이터를 미리 생성하지 않고, 실제로 접근하거나 사용할 때까지 초기화를 연기한다 . 우선, 실제로 필요할 때까지 객체를 생성하지 않으므로 불필요한 부하가 걸리지 않아, 애플리케이션을 시작하는 시간이 그만큼 빨라진다. 둘째, 어떤 경우에도 Null 포인터를 반환하지 않는다. 이러한 장점이 있다. 하지만 getService 메서드가 MyServicelmpl과 (위에서는 생략한) 생성자 인수에 명시적으로 의존한다. 따라서, 런타임 로직에서 MyServicelmpl객체를 전혀 사용 하지 않더라도 의존성을 해결하지 않으면 컴파일이 안 된다. 테스트도 문제인데, MyServicelmpl이 무거운 객체라면 단위 테스트에서 getService 메서드를 호출하기 전에 적절한 테스트 전용 객체를 service 필드에 할당해야 한다. 또한 Service가 null인 경로/null이 아닌 경로 등 모든 실행 경로도 테스트해야 한다. 즉, 메서드가 두 가지 이상 일을 수행하며, 작게나마 단일 책임 원칙(SRP)을 깬다는 말이다. 하지만 무엇보다 우려인점은 MyServicelmpl이 모든 상황에 적합한 객체인지 모든다는 사실이다. 현실적으로 한 객체 유형이 모든 문맥에 적합할 가능성은 희박하다. 초기화 지연 기법을 한 번 정도 사용한다면 별로 심각한 문제가 아니다. 하지만 이러한 설정 방식이 애플리케이션 전반에 흩어져있다면, 모듈성은 저조하며 대개 중복이 심각해진다. 체계적이고 탄탄한 시스템을 만들고 싶다면 모듈성을 깨서는 절대로 안 된다. 객체를 생성하거나 의존성을 연결할 때도 마찬가지다. 설정 논리는 일반 실행 논리와 분리해야 모듈성이 높아진다. 또한 주요 의존성을 해소하기 위한 방식, 즉 전반적이며 일관적인 방식도 필요하다. Main 분리 . 시스템 생성과 시스템 사용을 분리하는 한 가지 방법으로, 생성과 관련한 코드는 모두 main이나 main이 호출하는 모듈로 옮기고, 나머지 시스템은 모든 객체가 생성되었고 모든 의존성이 연결되었다고 가정한다. 흐름은 다음과 같다. | main에서 시스템에 필요한 객체들을 모두 생성한 후 이를 애플리케이션에 넘긴다. | 애플리케이션은 객체를 사용한다. | . main과 애플리케이션 사이에 표시된 의존성 화살표를 보면, 모든 화살표는 main에서 애플리케이션 방향으로 향한다. 즉, 애플리케이션은 main이나 객체가 생성되는 과정을 모른다. 하지만, 모든 객체가 적절히 생성되었다고 가정하며 객체들을 사용할 수 있다. 팩토리 . 물론 때로는 객체가 생성되는 시점을 애플리케이션이 결정할 필요도 생긴다. 예를 들어, 주문처리 시스템에서 애플리케이션은 LineItem 인스턴스를 생성해 Order에 추가한다. 이런 경우에는 추상 팩토리 패턴을 사용한다. 그러면 LineItem을 생성하는 시점은 애플리케이션이 결정하지만, LineItem을 생성하는 코드는 애플리케이션이 모른다. (그림 11-2 참조) . 여기서도 마찬가지로 모든 의존성이 main에서 OrderProcessing (애플리케이션)으로 향한다. 즉, OrderProcessing은 LineItem이 생성되는 구체적인 방법을 모른다. 그 방법은 main 의 LineItemFactoryImplementation이 안다. 그럼에도 OrderProcessing 애플리케이션은 LineItem 인스턴스가 생성되는 시점을 완벽하게 통제할 수 있다. 의존성 주입 . 사용과 제작을 분리하는 강력한 메커니즘 하나가 의존성 주입(Dependency Injection, DI) 이다. 의존성 주입은 제어 역전(Inversion of Control, IoC) 기법을 의존성 관리에 적용한 메커니즘이다. 제어 역전은 프로그램의 제어 흐름을 개발자가 아닌 외부 환경(e.g. 프레임워크, 컨테이너)에 위임하는 소프트웨어 설계 원칙이다. 제어 역전에서는 한 객체가 맡은 보조 책임을 새로운 객체에게 전적으로 떠넘긴다. 새로운 객체는 넘겨받은 책임만 맡으므로 단일 책임 원칙을 따른다. 의존성 관리 맥락에서, 객체는 스스로 인스턴스로 만드는 책임은 지지않고, 이러한 책임을 다른 전담 메커니즘에 넘겨야만 한다. 그렇게 함으로써 제어를 역전한다. 초기 설정은 시스템 전체에서 필요하므로 대개 ‘책임질’ 메커니즘으로 main 루틴이나 특수 컨테이너를 사용한다. 다음 예제 코드를 살펴보자. JNDI 검색은 의존성 주입을 ‘부분적으로’ 구현한 기능이다. 객체를 직접 생성하지 않고 외부 저장소(JNDI 디렉터리)에서 가져온다. MyService myService = (MyService)(jndiContext.lookup(\"NameOfMyService\")); . myService를 호출하는 클래스는 실제로 반환되는 객체의 유형을 제어하지 않는다. 대신 이 클래스는 의존성을 능동적으로 해결한다. (e.g. 수동적은 프레임워크가 해결) . 하지만, 의존성 주입이 진정하게 이루어지려면 클래스는 의존성을 해결하려 시도하지 않는다. 대신에 의존성을 주입하는 방법으로 설정자(Setter) 메서드나 생성자 인수를 (혹은 둘 다를) 제공한다. 예를 들어, DI 컨테이너가 있다. DI 컨테이너는 요청이 들어오면 필요한 객체의 인스턴스를 만든 후 생성자 인수나 설정자 메서드를 사용해 의존성을 설정한다. 실제로 생성되는 객체 유형은 설정 파일에서 지정하거나 특수 생성 모듈에서 코드로 명시한다. 스프링 프레임워크 는 가장 널리 알려진 자바 DI 컨테이너를 제공한다. 객체 사이 의존성은 XML 파일에 정의한다. 그리고 자바 코드에서는 이름으로 특정한 객체를 요청한다. ",
    "url": "/chapter11-system.html#%EC%8B%9C%EC%8A%A4%ED%85%9C-%EC%A0%9C%EC%9E%91%EA%B3%BC-%EC%8B%9C%EC%8A%A4%ED%85%9C-%EC%82%AC%EC%9A%A9%EC%9D%84-%EB%B6%84%EB%A6%AC%ED%95%98%EB%9D%BC",
    
    "relUrl": "/chapter11-system.html#시스템-제작과-시스템-사용을-분리하라"
  },"25": {
    "doc": "11장 시스템",
    "title": "확장 (스케일링)",
    "content": "‘처음부터 올바르게’ 시스템을 만들 수 있다는 믿음은 미신이다. 대신에 우리는 오늘 주어진 사용자 스토리에 맞춰 시스템을 구현해야 한다. 내일은 새로운 스토리에 맞춰 시스템을 조정하고 확장하면 된다. TDD, 리팩토터링, 깨끗한 코드는 코드 수준에서 시스템을 조정하고 확장하기 쉽게 만든다. 하지만 시스템 수준에서는 어떨까? 현실적으로 단순한 아키텍처를 복잡한 아키텍처로 조금씩 키울 수 없다. 소프트웨어 시스템은 물리적인 시스템과 다르다. 관심사를 적절히 분리해 관리한다면 소프트웨어 아키텍처는 점진적으로 발전할 수 있다. 다음은 관심사를 적절히 분리하지 못해 유기적인 성장이 어려웠던 아키텍쳐인 EJB1, EJB2 이다. 목룍 11-1은 클라이언트가 사용할 프로세스 내 지역 인터페이스이다. 목록 11-1 에서 열거하는 속성은 Bank 주소, 은행이 소유하는 계좌다. // 목록 11-1 Bank EJB용 EJB2 지역 인터페이스 package com.example.banking; import java.util.Collections; import javax.ejb.*; public interface BankLocal extends java.ejb.EJBLocalObject { String getStreetAddr1() throws EJBException; String getStreetAddr2() throws EJBException; String getCity() throws EJBException; String getState() throws EJBException; String getZipCode() throws EJBException; void setStreetAddr1(String street1) throws EJBException; void setStreetAddr2(String street2) throws EJBException; void setCity(String city) throws EJBException; void setState(String state) throws EJBException; void setZipCode(String zip) throws EJBException; Collection getAccounts() throws EJBException; void setAccounts(Collection accounts) throws EJBException; void addAccount(AccountDTO accountDTO) throws EJBException; } . 목록 11-2는 목록 11-1 인터페이스에 상응하는 EJB2 빈(엔티티 빈)이다. 엔티티 빈은 관계형 자료, 즉 테이블 행을 표현하는 객체로, 메모리에 상주한다. // 목록 11-2 상응하는 EJB2 엔티티 빈 구현 import java.util.Collections; import javax.ejb.*; public abstract class Bank implements javax.ejb.EntityBean { // 비즈니스 논리... public abstract String getStreetAddr1(); public abstract String getStreetAddr2(); public abstract String getCity(); public abstract String getState(); public abstract String getZipCode(); public abstract void setStreetAddr1(String street1); public abstract void setStreetAddr2(String street2); public abstract void setCity(String city); public abstract void setState(String state); public abstract void setZipCode(String zip); public abstract Collection getAccounts(); public abstract void setAccounts(Collection accounts); public void addAccount(AccountDTO accountDTO) { InitialContext context = new InitialContext(); AccountHomeLocal accountHome = context.lookup(\"AccountHomeLocal\"); AccountLocal account = accountHome.create(accountDTO); Collection accounts = getAccounts(); accounts.add(account); } public abstract void setId(Integer id); public abstract Integer getId(); public Integer ejbCreate(Integer id) { ... } public void ejbPostCreate(Integer id) { ... } // 나머지도 구현해야 하지만 일반적으로 비어있다. public void setEntityContext(EntityContext ctx) {} public void unsetEntityContext() {} public void ejbActivate() {} public void ejbPassivate() {} public void ejbLoad() {} public void ejbStore() {} public void ejbRemove() {} } . 비즈니스 논리는 EJB2 애플리케이션 ‘컨테이너’에 강하게 결합된다. 클래스를 생성하려면, 컨테이너에서 파생해야 하며, 컨테이너가 요구하는 다양한 생명주기 메서드도 제공해야 한다. 이렇듯 비즈니스 논리가 덩치 큰 컨테이너와 밀접하게 결합되면, 독자적인 단위 테스트가 어렵다. 컨테이너를 목킹하거나, EJB와 테스트를 실제 서버에 배치해야 한다. 객체 지향 프로그래밍의 개념 또한 흔들린다. 빈은 다른 빈을 상속 받지 못한다. 일반적으로 EJB2 빈은 DTO를 정의한다. DTO는 사실상 자료구조이다. 즉, 동일한 정보를 저장하는 자료 유형이 두 개라는 의미다. 그래서 한 객체에서 다른 객체로 자료를 복사하는 반복적인 규격 코드가 필요하다. 횡단(cross-cutting) 관심사 . 반면, 어떤면에서 EJB2 아키텍처는 관심사를 거의 완벽하게 분리한다. 예를 들어, 원하는 트랜잭션, 보안, 일부 영속적인 동작은 소스 코드가 아닌 배치 기술자(deployment descriptors)에서 정의한다. 영속성과 같은 관심사는 애플리케이션의 전반에 걸쳐 객체의 경계를 넘나드는 경향이 있다. 따라서, 모든 객체가 전반적으로 동일한 방식을 이용하게 만들어야 한다. 원론적으로는 모듈화되고 캡슐화된 방식으로 영속성 방식을 구상할 수 있다. 하지만 현실적으로는 힘들다. 여기서 횡단 관심사라는 용어가 나온다. 사실상 EJB 아키텍처가 영속성, 보안, 트랜잭션과 같은 관심사를 처리하는 방식은 관점 지향 프로그래밍(Aspect-Oriented Programming, AOP)를 예견했다고도 보인다. AOP는 횡단 관심사에 대처해 모듈성을 확보하는 일반적인 방법론이다. AOP에서 관점(aspect)은 횡단 관심사를 모듈화 한것이라고 생각하면 된다. AOP에서 모듈 구성 개념은 “특정 관심사를 지원하려면 시스템에서 특정 지점들이 동작하는 방식을 일관성 있게 바꿔야 한다”라고 명시한다. 이는 영속성을 예로 들면, 프로그래머는 영속적으로 저장할 객체와 속성을 선언만하고, 그 이후 영속성 책임은 영속성 프레임워크에 위임한다. 그러면 AOP 프레임워크는 대상 코드에 영향을 미치지 않고 동작 방식을 변경한다. 자바에서 사용하는 이와 비슷한 관점 혹은 유사한 메커니즘 세 개를 살펴보자. ",
    "url": "/chapter11-system.html#%ED%99%95%EC%9E%A5-%EC%8A%A4%EC%BC%80%EC%9D%BC%EB%A7%81",
    
    "relUrl": "/chapter11-system.html#확장-스케일링"
  },"26": {
    "doc": "11장 시스템",
    "title": "자바 프록시",
    "content": "자바 프록시는 개별 객체나 클래스에서 메서드 호출을 감싸는 경우에 적합하다. 하지만 JDK 에서 사용하는 동적 프록시는 인터페이스만 지원한다. 클래스 프록시를 사용하려면 바이트 코드 처리 라이브러리(CGLIBM ASM, Javassist …)가 필요하다. 목록 11-3은 Bank 애플리케이션에서 JDK 프록시를 사용해 영속성을 지원하는 예제다. 프록시로 감쌀 인터페이스 Bank 와 비즈니스 논리를 구현하는 POJO(Plain Old Java Object)인 BankImpl을 정의한다. // Bank.java (패키지 이름을 감춘다) import java.util.*; // 은행 추상화 public interface Bank { Collection&lt;Account&gt; getAccounts(); void setAccounts(Collection&lt;Account&gt; accounts); } // BankImpl.java import java.util.*; // 추상화를 위한 POJO(Plain Old Java Object) 구현 public class BankImpl implements Bank { private List&lt;Account&gt; accounts; public Collection&lt;Account&gt; getAccounts() { return accounts; } public void setAccounts(Collection&lt;Account&gt; accounts) { this.accounts = new ArrayList&lt;Account&gt;(); for (Account account : accounts) { this.accounts.add(account); } } } // BankProxyHandler.java import java.lang.reflect.*; import java.util.*; // 프록시 API가 필요한 \"InvocationHandler\" public class BankProxyHandler implements InvocationHandler { private Bank bank; public BankProxyHandler(Bank bank) { this.bank = bank; } // InvocationHandler에 정의된 메서드 public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { String methodName = method.getName(); if (methodName.equals(\"getAccounts\")) { bank.setAccounts(getAccountsFromDatabase()); return bank.getAccounts(); } else if (methodName.equals(\"setAccounts\")) { bank.setAccounts((Collection&lt;Account&gt;) args[0]); setAccountsToDatabase(bank.getAccounts()); return null; } else { // ... } } // 세부사항은 여기에 이어진다. protected Collection&lt;Account&gt; getAccountsFromDatabase() { ... } protected void setAccountsToDatabase(Collection&lt;Account&gt; accounts) { ... } } // 다른 곳에 위치하는 코드 Bank bank = (Bank) Proxy.newProxyInstance( Bank.class.getClassLoader(), new Class[] { Bank.class }, new BankProxyHandler(new BankImpl())); . 이는 단순한 예제지만 코드가 상당히 많으며 제법 복잡하다. 바이트 조작 라이브러리를 사용하더라도 어렵다. 다시 말해, 프록시를 직접 구현하여 사용하면 깨끗한 코드를 작성하기는 어렵다. ",
    "url": "/chapter11-system.html#%EC%9E%90%EB%B0%94-%ED%94%84%EB%A1%9D%EC%8B%9C",
    
    "relUrl": "/chapter11-system.html#자바-프록시"
  },"27": {
    "doc": "11장 시스템",
    "title": "순수 자바 AOP 프레임워크",
    "content": "다행히 대부분의 프록시 코드는 도구로 자동화할 수 있으며, 순수 자바 관점을 구현하는 스프링 AOP, JBoss AOP 등과 같은 여러 자바 프레임워크는 내부적으로 프록시를 사용한다. 스프링은 비즈니스 논리를 POJO로 구현한다. POJO는 순수하게 도메인에 초점을 맞춘다. POJO는 Plain Old Java Object 의 줄임말로, 말 그대로 “오래된 방식의 간단한 자바 객체”를 의미한다. 특정 기술이나 프레임워크에 종속되지 않은 순수한 자바 언어로만 작성된 객체를 뜻한다. 프로그래머는 설정 파일(XML 등)이나 API를 사용하여 필수적인 애플리케이션 기반 구조를 구현한다. 여기에는 횡단 관심사(영속성, 트랜잭션, 보안, 캐시, 장애 조치 등)도 포함된다. 프레임워크는 사용자가 모르게 프록시나 바이트코드 라이브러리를 사용해 이를 구현한다. 이런 선언들이 요청에 따라 주요 객체를 생성하고 서로 연결하는 등 DI 컨테이너의 구체적인 동작을 제어한다. 목록 11-4는 스프링 V2.5 설정 파일 app.xml 일부로, 아주 전형적인 모습이다. &lt;beans&gt; ... &lt;bean id=\"appDataSource\" class=\"org.apache.commons.dbcp.BasicDataSource\" destroy-method=\"close\" p:driverClassName=\"com.mysql.jdbc.Driver\" p:url=\"jdbc:mysql://localhost:3306/mydb\" p:username=\"me\"/&gt; &lt;bean id=\"bankDataAccessObject\" class=\"com.example.banking.persistence.BankDataAccessObject\" p:dataSource-ref=\"appDataSource\"/&gt; &lt;bean id=\"bank\" class=\"com.example.banking.model.Bank\" p:dataAccessObject-ref=\"bankDataAccessObject\"/&gt; &lt;/beans&gt; ... 위의 파일에서 각 빈(bean)은 마치 중첩된 러시아 인형과도 같다. 다음 그림 11.3을 살펴보자. 그림 11.3 DECORATOR의 ‘러시아 인형’ . Bank 도메인 객체는 DAO(자료 접근자 객체)로 프록시되었으며, DAO는 JDBC 드라이버 자료 소스로 프록시되었다. DAO는 비즈니스 로직과 데이터베이스 사이의 중간 계층 역할을 하며, 데이터 접근을 추상화하는 디자인 패턴이다. 쉽게 말해 애플리케이션이 데이터베이스와 소통할 때 사용하는 전용 통역사 역할을 한다. 따라서 클라이언트에서 Bank 객체의 getAccounts()를 호출할 때, 이것이 직접적으로 이루어질것이라고 믿지만 실제로는 Bank POJO(도메인에 초점이 맞추어진)의 기본 동작을 확장한 중첩 DECORATOR 객체 집합의 가장 외곽과 통신하는 것이다. DECORATOR 객체는 기존 객체에 새로운 기능을 동적으로 추가하거나 확장할 수 있게 해주는 래퍼(Wrapper) 객체를 뜻한다. 예를 들어 애플리케이션에서 DI 컨테이너에게 시스템 내 최상위 객체를 요청하려면 다음 코드가 필요하다. 해당 객체는 앞서 설명한 프로젝트 기반구조를 구현하는 설정파일(XML)에 포함되어 있다. XmlBeanFactory bf = new XmlBeanFactory(new ClassPathResource(\"app.dxml\", getClass())); Bank bank = (Bank) bf.getBean(\"bank\") . 위의 코드에서 스프링 관련 자바 코드는 거의 필요없다. 따라서 사실상 스프링과 독립적이게 된다. 즉, EJB2 시스템이 지녔던 강한 결합(tight-coupling)이라는 문제가 모두 사라진다. 이렇듯 XML과 같은 설정파일에 명시된 ‘정책’은 겉으로 보지이지 않지만 자동으로 생성되는 프록시나 관점 논리보다는 단순하다. 목록 11-5는 EJB3로 Bank 객체를 다시 작성한 코드다. EJB3은 XML 설정 파일과 자바 5 애너테이션 기능을 사용해 횡단 관심사를 선언적으로 지원하는 스프링 모델을 따른다. // 목록 11-5 EBJ3 Bank EJB package com.example.banking.model; import javax.persistence.*; import java.util.ArrayList; import java.util.Collection; @Entity @Table(name = \"BANKS\") public class Bank implements java.io.Serializable { @Id @GeneratedValue(strategy=GenerationType.AUTO) private int id; @Embeddable // Bank의 데이터베이스 행에 '인라인으로 포함된' 객체 public class Address { protected String streetAddr1; protected String streetAddr2; protected String city; protected String state; protected String zipCode; } @Embedded private Address address; @OneToMany(cascade = CascadeType.ALL, fetch = FetchType.EAGER, mappedBy=\"bank\") private Collection&lt;Account&gt; accounts = new ArrayList&lt;Account&gt;(); public int getId() { return id; } public void setId(int id) { this.id = id; } public void addAccount(Account account) { account.setBank(this); accounts.add(account); } public Collection&lt;Account&gt; getAccounts() { return accounts; } public void setAccounts(Collection&lt;Account&gt; accounts) { this.accounts = accounts; } } . 원래 EJB2 코드보다 위 코드가 훨씬 더 깨끗하다. 영속성과 같은 횡단 관심사가 애너테이션과 XML 파일에 포함되어있기 때문이다. 이러한 관심사를 비즈니스 로직과 분리하였기에 EJB2에 비해 해로운 문제가 발생할 가능성이 훨씬 적다. ",
    "url": "/chapter11-system.html#%EC%88%9C%EC%88%98-%EC%9E%90%EB%B0%94-aop-%ED%94%84%EB%A0%88%EC%9E%84%EC%9B%8C%ED%81%AC",
    
    "relUrl": "/chapter11-system.html#순수-자바-aop-프레임워크"
  },"28": {
    "doc": "11장 시스템",
    "title": "AspectJ 관점",
    "content": "마지막으로, 관심사를 관점으로 분리하는 가장 강력한 도구는 AspectJ 언어다. AspectJ는 언어 차원에서 관점을 모듈화 구성으로 지원하는 자바 언어 확장이다. AspectJ에 대한 상세한 설명은 이 책 범위를 벗어나므로, 자세한 내용은 AspectJ, Colyer, Spring 을 참조한다. ",
    "url": "/chapter11-system.html#aspectj-%EA%B4%80%EC%A0%90",
    
    "relUrl": "/chapter11-system.html#aspectj-관점"
  },"29": {
    "doc": "11장 시스템",
    "title": "테스트 주도 시스템 아키텍처 구축",
    "content": "관점으로 관심사를 분리하는 방식은 그 위력이 막강하다. 애플리케이션에서 도메인 논리(비즈니스 논리)를 POJO로 작성할 수 있다면, 즉 코드 수준에서 아키텍처 관심사를 분리할 수 있다면, 진정한 테스트 주도 아키텍처 구축이 가능해진다. BDUF(Big Design Up Front, 구현을 시작하기 전에 앞으로 벌어질 모든 상황을 설계하는 기법)를 추구할 필요가 없다. 다시말해, 우선 단순하게 분리된 아키텍처로 결과물을 빠르게 출시 후, 기반 구조를 추가하며 조금씩 화장해 나가도 괜찮다는 말이다. 그렇게 하려면 프로젝트를 시작할때 일반적인 범위, 목표, 일정, 시스템의 일반적인 구조를 생각하되 변하는 환경에 대처해 진로를 변경할 능력도 구사할 수 있어야한다. 최선의 시스템 구조는 각기 POJO (또는 다른) 객체로 구현되는 모듈화된 관심사 영역(도메인)으로 구성된다. 이렇게 서로 다른 영역은 해당 영역 코드에 최소한의 영향을 미치는 관점이나 유사한 도구를 사용해 통합한다. 이런 구조 역시 코드와 마찬가지로 테스트 주도 기법을 적용할 수 있다. ",
    "url": "/chapter11-system.html#%ED%85%8C%EC%8A%A4%ED%8A%B8-%EC%A3%BC%EB%8F%84-%EC%8B%9C%EC%8A%A4%ED%85%9C-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98-%EA%B5%AC%EC%B6%95",
    
    "relUrl": "/chapter11-system.html#테스트-주도-시스템-아키텍처-구축"
  },"30": {
    "doc": "11장 시스템",
    "title": "의사 결정을 최적화하라",
    "content": "모듈을 나누고 관심사를 분리하면 지엽적인 관리와 결정이 가능해진다. 아주 큰 시스템에서는 한 사람이 모든 결정을 내리기 어렵다. 따라서 가장 적합한 사람에게 책임을 맡기면 가장 좋다. 우리는 때때로 가능한 마지막 순간까지 결정을 미루는 방법이 최선이라는 사실을 까먹곤한다. 최대한 정보를 모아 최적의 사람이 최선의 결정을 내리기 위해, 좀 더 고민하는 것은 좋다. 관심사를 모듈로 분리한 POJO 시스템은 기민함을 제공한다. 이런 기민함 덕택에 최신 정보에 기반해 최선의 시점에 최적의 결정을 내리기가 쉬워진다. 또한 결정의 복잡성도 줄어든다. ",
    "url": "/chapter11-system.html#%EC%9D%98%EC%82%AC-%EA%B2%B0%EC%A0%95%EC%9D%84-%EC%B5%9C%EC%A0%81%ED%99%94%ED%95%98%EB%9D%BC",
    
    "relUrl": "/chapter11-system.html#의사-결정을-최적화하라"
  },"31": {
    "doc": "11장 시스템",
    "title": "명백한 가치가 있을 때 표준을 현명하게 사용하라",
    "content": "표준을 사용할 때 명백한 가치와 근거가 있는지 고민하고 사용해야한다. EJB2는 단지 표준이라는 이유만으로 많은 팀이 사용했다. 가볍고 간단한 설계로 충분했을 프로젝트에서도 말이다. 이렇듯 아주 과장되게 포장된 표준에 집착하는 바람에 고객 가치가 뒷전으로 밀려난 사례들이 많이 있다. 표준을 사용하면 아이디어와 컴포넌트를 재사용하기 쉽고, 적절한 경험을 가진 사람을 구하기 쉬우며, 좋은 아이디어를 캡슐화하기 쉽고, 컴포넌트를 엮기 쉽다. 하지만 때로는 표준을 만드는 시간이 너무 오래 걸려 업계가 기다리지 못한다. 어떤 표준은 원래 표준을 제정한 목적을 잊어버리기도 한다. ",
    "url": "/chapter11-system.html#%EB%AA%85%EB%B0%B1%ED%95%9C-%EA%B0%80%EC%B9%98%EA%B0%80-%EC%9E%88%EC%9D%84-%EB%95%8C-%ED%91%9C%EC%A4%80%EC%9D%84-%ED%98%84%EB%AA%85%ED%95%98%EA%B2%8C-%EC%82%AC%EC%9A%A9%ED%95%98%EB%9D%BC",
    
    "relUrl": "/chapter11-system.html#명백한-가치가-있을-때-표준을-현명하게-사용하라"
  },"32": {
    "doc": "11장 시스템",
    "title": "시스템은 도메인 특화 언어가 필요하다.",
    "content": "도메인 특화 언어(DSL)은 간단한 스크립트 언어나 표준 언어로 구현한 API를 가리킨다. 좋은 DSL은 도메인 개념과 코드 사이의 의사소통 간극을 줄여준다. 프로젝트 이해관계자와 개발자 사이의 의사소통 간극을 줄여주듯 말이다. 따라서 DSL은 효과적으로 사용한다면 추상화 수준을 코드 관용구나 디자인 패턴 이상으로 끌어올린다. 그래서 개발자가 적절한 추상화 수준에서 코드 의도를 표현할 수 있다. 도메인 특화 언어를 사용하면 고차원 정책에서 저차원 세부사항에 이르기까지 모든 추상화 수준과 모든 도메인을 POJO로 표현할 수 있다. ",
    "url": "/chapter11-system.html#%EC%8B%9C%EC%8A%A4%ED%85%9C%EC%9D%80-%EB%8F%84%EB%A9%94%EC%9D%B8-%ED%8A%B9%ED%99%94-%EC%96%B8%EC%96%B4%EA%B0%80-%ED%95%84%EC%9A%94%ED%95%98%EB%8B%A4",
    
    "relUrl": "/chapter11-system.html#시스템은-도메인-특화-언어가-필요하다"
  },"33": {
    "doc": "11장 시스템",
    "title": "결론",
    "content": "시스템 역시 깨끗해야한다. 깨끗하지 못한 아키텍처는 도메인 논리를 흐린다. 도메인 논리가 흐려지면 버그가 끼어들기 쉬워지고, 이는 기민성과 생산성을 낮춘다. 이는 결국 TDD가 제공하는 장점을 무효화한다. 모든 추상화 단계에서 의도는 명확히 표현해야 한다. 그러려면 POJO를 작성하고, 관점 혹은 관점과 유사한 메커니즘을 사용해 각 구현 관심사를 분리해야한다. 시스템을 설계하든 개별 모듈을 설계하든, 실제로 돌아가는 가장 단순한 수단을 사용해야 한다는 사실을 명심하자. ",
    "url": "/chapter11-system.html#%EA%B2%B0%EB%A1%A0",
    
    "relUrl": "/chapter11-system.html#결론"
  },"34": {
    "doc": "12장 창발성",
    "title": "12장 창발성",
    "content": ". | 주요 내용 . | 단순한 설계 규칙에 대해 설명 | ",
    "url": "/chapter12-emergence.html",
    
    "relUrl": "/chapter12-emergence.html"
  },"35": {
    "doc": "12장 창발성",
    "title": "중복을 삭제하는 방식",
    "content": "| . | . ",
    "url": "/chapter12-emergence.html#%EC%A4%91%EB%B3%B5%EC%9D%84-%EC%82%AD%EC%A0%9C%ED%95%98%EB%8A%94-%EB%B0%A9%EC%8B%9D",
    
    "relUrl": "/chapter12-emergence.html#중복을-삭제하는-방식"
  },"36": {
    "doc": "12장 창발성",
    "title": "창발적 설계로 깔끔한 코드를 구현하자",
    "content": "켄트 벡이 말하는 단순하게 설계하는 규칙 . | 모든 테스트를 실행한다. | 중복을 없앤다. | 프로그래머 의도를 표현한다. | 클래스와 메서드 수를 최소로 줄인다. | . 우리는 위 규칙을 지키면, 소프트웨어 설계 품질을 크게 높여준다고 믿는다. ",
    "url": "/chapter12-emergence.html#%EC%B0%BD%EB%B0%9C%EC%A0%81-%EC%84%A4%EA%B3%84%EB%A1%9C-%EA%B9%94%EB%81%94%ED%95%9C-%EC%BD%94%EB%93%9C%EB%A5%BC-%EA%B5%AC%ED%98%84%ED%95%98%EC%9E%90",
    
    "relUrl": "/chapter12-emergence.html#창발적-설계로-깔끔한-코드를-구현하자"
  },"37": {
    "doc": "12장 창발성",
    "title": "단순한 설계 규칙 1: 모든 테스트를 실행하라",
    "content": "테스트는 중요하다: 테스트의 중요성 . | 가장 중요한 것: 설계는 의도한 대로 돌아가는 시스템, 검증이 불가능하다면 인정받기 어려움 | 검증 방법: 시스템의 테스트 | 테스트가 불가능한 시스템 = 검증할 수 없는 시스템 | . 테스트 코드 작성의 이점: 테스트가 가능한 시스템을 만들기 위해 노력하다보면, 설계 품질이 좋아짐 . | 설계 품질이 낮으면 테스트가 어렵기 떄문에, 테스트를 쉽게 작성하기 위해 설계 품질이 높아지는 방향으로 개발 . | DIP, 인터페이스, 추상화 등의 도구를 이용해 결합도를 낮추고 응집력을 높임 = 객체 지향 방법론이 지향하는 목표 | . | 테스트 케이스가 많으면 테스트 코드를 쉽게 작성하게 되서, 더 다양한 테스트 코드를 작성하게 됨 | . ",
    "url": "/chapter12-emergence.html#%EB%8B%A8%EC%88%9C%ED%95%9C-%EC%84%A4%EA%B3%84-%EA%B7%9C%EC%B9%99-1-%EB%AA%A8%EB%93%A0-%ED%85%8C%EC%8A%A4%ED%8A%B8%EB%A5%BC-%EC%8B%A4%ED%96%89%ED%95%98%EB%9D%BC",
    
    "relUrl": "/chapter12-emergence.html#단순한-설계-규칙-1-모든-테스트를-실행하라"
  },"38": {
    "doc": "12장 창발성",
    "title": "단순한 설계 규칙 2~4: 리팩터링",
    "content": "테스트 케이스를 모두 작성했으면, 점진적으로 리팩토링을 진행 . 리팩토링을 하며 시스템이 망가질까 걱정할 이유가 없음 . | 이미 작성되어있는 테스트 코드가 이를 확인할 수 있도록 하기 때문에 | . ",
    "url": "/chapter12-emergence.html#%EB%8B%A8%EC%88%9C%ED%95%9C-%EC%84%A4%EA%B3%84-%EA%B7%9C%EC%B9%99-24-%EB%A6%AC%ED%8C%A9%ED%84%B0%EB%A7%81",
    
    "relUrl": "/chapter12-emergence.html#단순한-설계-규칙-24-리팩터링"
  },"39": {
    "doc": "12장 창발성",
    "title": "중복을 없애라",
    "content": "중복의 위험성 . | 중복은 추가작업, 추가 위험, 불필요한 복잡도를 뜻함 | . 중복은 여러 형태로 표출됨: 구현 중복도 중복 . 단 몇 줄이라도 중복을 제거하겠다는 의지가 필요함 . 중복을 제거한 예시 . | 구현 중복은 제거 int size(){ ... } boolean isEmpty(){ return 0 == size(); } . | 다른 코드 중복 제거 예시 . | 기존 public void scaleToOneDimension(float desiredDimension, float imageDeimension){ if(Math.abs(desiredDimension - imageDeimension) &lt; errorThreshold) return; float scalingFactor = desiredDimension / imageDeimension; scalingFactor = (float) (Math.floor(scalingFactor * 100) * 0.01f); RenderedOp newImage = ImageUtilities.getScaledImage(image, scalingFactor, scalingFactor); image.dispose();// 동일한 부분 System.gc(); image = newImage; } public synchronized void rotate(int degrees){ RenderedOp newImage = ImageUtilities.getRotatedImage(image, degrees); image.dispose();// 동일한 부분 System.gc(); image = newImage; } . | 변경 public void scaleToOneDimension(float desiredDimension, float imageDeimension){ if(Math.abs(desiredDimension - imageDeimension) &lt; errorThreshold) return; float scalingFactor = desiredDimension / imageDeimension; scalingFactor = (float) (Math.floor(scalingFactor * 100) * 0.01f); replaceImage( ImageUtilities.getScaledImage(image, scalingFactor, scalingFactor) ); } public synchronized void rotate(int degrees){ replaceImage( ImageUtilities.getRotatedImage(image, degrees) ); } private void replaceImage(RenderedOp newImage){ // 공통 로직 메서드 추출 RenderedOp newImage = ImageUtilities.getRotatedImage(image, degrees); image.dispose(); System.gc(); image = newImage; } . | 특징 . | 위와 같은 소규모 재사용은 시스템 복잡도를 극적으로 줄여줌 | 소규모 재사용을 제대로 익혀야 대규모 재사용이 가능함 | . | . | . Template method 패턴 . | Template method 패턴은 고차원 중복을 제거할 목적으로 자주 사용됨 | 기존 public class VacationPolicy{ public void accrueUSDivisionVacation(){ // 미국 버전 // 지금까지 근무한 시간을 바탕으로 휴일 일수를 계산하는 코드 // 휴가 일수가 미국 최소 법정 일수를 만족하는지 확인하는 코드 // 휴가 일수를 급여 대장에 적용하는 코드 } public void accrueEUDivisionVacation(){ // 유럽 버전 // 지금까지 근무한 시간을 바탕으로 휴일 일수를 계산하는 코드 // 휴가 일수가 유럽연합 최소 법정 일수를 만족하는지 확인하는 코드 // 휴가 일수를 급여 대장에 적용하는 코드 } } . | 변경 abstract public class VacationPolicy{ public void accrueVacation(){ // 공통 버전 a(); // 지금까지 근무한 시간을 바탕으로 휴일 일수를 계산하는 함수 정의 b(); // 휴가 일수가 최소 법정 일수를 만족하는지 확인하는 코드 -&gt; 변경 부분이 있는 곳만 abstract으로 처리 c(); // 휴가 일수를 급여 대장에 적용하는 코드 } } public USVacationPolicy extends VacationPolicy{ // 미국 버전으로 // 휴가 일수가 최소 법정 일수를 만족하는지 확인하는 코드 @Override b(){ // abstract 부분만 구현 ... } } public EUVacationPolicy extends VacationPolicy{ // 미국 버전으로 // 휴가 일수가 최소 법정 일수를 만족하는지 확인하는 코드 @Override b(){ // abstract 부분만 구현 ... } } . | . ",
    "url": "/chapter12-emergence.html#%EC%A4%91%EB%B3%B5%EC%9D%84-%EC%97%86%EC%95%A0%EB%9D%BC",
    
    "relUrl": "/chapter12-emergence.html#중복을-없애라"
  },"40": {
    "doc": "12장 창발성",
    "title": "표현하라",
    "content": "코드는 개발자의 의도를 분명이 표현해야함 . | 소프트웨어 프로젝트 비용 중 대다수는 장기적인 유지보수에 투자되는데, 유지보수 개발자가 제대로 이해하기 위해서 | . 코드 표현력을 높이는 방법: 가장 좋은 방법은 노력하는 것 . | 좋은 이름을 선택 | 함수와 클래스 크기는 가능한 줄이기 | 표준 명칭 사용(e.g. 표준 패턴 사용시, 클래스 이름에 넣음) | 단위 테스트 케이스를 꼼꼼히 작성 | . ",
    "url": "/chapter12-emergence.html#%ED%91%9C%ED%98%84%ED%95%98%EB%9D%BC",
    
    "relUrl": "/chapter12-emergence.html#표현하라"
  },"41": {
    "doc": "12장 창발성",
    "title": "클래스와 메서드 수를 최소로 줄여라",
    "content": "가능한 독단적인 견해는 멀리하고 실용적인 방법을 택한다. | 중복 제거, 의도 표현, SRP 등의 기본적인 개념도 극단으로 치달으면 득보다 실이 커짐 | 하지만 위의 방법보다는 우선순위가 낮다. | . ",
    "url": "/chapter12-emergence.html#%ED%81%B4%EB%9E%98%EC%8A%A4%EC%99%80-%EB%A9%94%EC%84%9C%EB%93%9C-%EC%88%98%EB%A5%BC-%EC%B5%9C%EC%86%8C%EB%A1%9C-%EC%A4%84%EC%97%AC%EB%9D%BC",
    
    "relUrl": "/chapter12-emergence.html#클래스와-메서드-수를-최소로-줄여라"
  },"42": {
    "doc": "13장 동시성",
    "title": "13장 동시성",
    "content": "동시성과 깔끔한 코드는 양립하기 어렵다. 스레드 하나만 사용하는 코드는 작성하기 쉽지만, 동시성을 구현하려면 많은 고려가 필요하다. 동시성 문제는 시스템이 부하를 받기 전까지는 잘 드러나지 않으며, 한 번 발생하면 재현하기도 어렵다. ",
    "url": "/chapter13-concurrency.html",
    
    "relUrl": "/chapter13-concurrency.html"
  },"43": {
    "doc": "13장 동시성",
    "title": "동시성이 필요한 이유?",
    "content": "동시성은 결합을 없애는 전략이다. 즉, 무엇과 언제를 분리하는 전략이다. 무엇(What) . 프로그램이 해야 하는 작업 자체 → \"파일 다운로드\", \"DB에 저장\", \"로그 출력\" . 언제(When) . 그 작업을 실행하는 시점 → \"지금 바로 실행할지\", \"나중에 실행할지\", \"특정 조건이 충족될 때 실행할지\" . | 스레드가 하나인 프로그램에서는 무엇과 언제가 밀접하다. | 무엇과 언제를 분리하면 애플리케이션 구조와 효율이 크게 향상된다. | 예: 서블릿 . | 서블릿은 EJB 컨테이너가 동시성을 일부 관리해 준다. | 프로그래머는 모든 웹 요청을 직접 관리하지 않아도 된다. | 각 서블릿 스레드는 독립적으로 동작한다. | . | . | . 동시성이 필요한 상황 . | 구조적 개선을 위해 도입하는 경우도 있지만 | 주로 응답 시간, 처리량 등의 요구사항으로 동시성이 불가피한 경우도 있다. | 정보 수집기 | 사용자 수가 많은 시스템 | 대량의 데이터를 처리하는 시스템 | . | . 미신과 오해 . | 동시성을 항상 성능을 높여준다. → X: 대기 시간이 충분히 길거나 독립적 계산이 많을 때만 그렇다. | 동시성을 구현해도 설계는 변하지 않는다 . → X: 무엇과 언제를 분리하면 시스템 설계 자체가 달라진다. | 웹 또는 EJB 컨테이너를 사용하면 동시성을 이해할 필요가 없다. → X: 컨테이너 동작 방식, 동시 수정/데드락 회피 방법을 이해해야 한다. | . 동시성의 어려운 이유 . | 성능 부하: 락, 컨텍스트 스위칭 등으로 오버헤드 발생. | 복잡성 증가: 단순한 문제도 동시성 때문에 어렵다. | 버그 재현 어려움: 잠복 버그는 재현이 매우 힘들어 무시되기 쉽다. | 설계 복잡성: 근본적인 설계 전략부터 재검토해야 한다. | . ",
    "url": "/chapter13-concurrency.html#%EB%8F%99%EC%8B%9C%EC%84%B1%EC%9D%B4-%ED%95%84%EC%9A%94%ED%95%9C-%EC%9D%B4%EC%9C%A0",
    
    "relUrl": "/chapter13-concurrency.html#동시성이-필요한-이유"
  },"44": {
    "doc": "13장 동시성",
    "title": "난관",
    "content": "동시성을 구현하기 어려운 이유는 . public class X { private int lastIdUsed; public int getNextId() { return ++lastIdUsed; } } . lastIdUsed = 42인 상태에서 두 스레드가 동시에 getNextId() 호출 시: . | A 스레드: 43 / B 스레드: 44 → lastIdUsed = 44 | A 스레드: 44 / B 스레드: 43 → lastIdUsed = 44 | A 스레드: 43 / B 스레드: 43 → lastIdUsed = 43 (⚠️) | . 스레드 간 동시 실행 경로는 수천~수만 개. 일부 경로에서 잘못된 결과가 발생한다. ",
    "url": "/chapter13-concurrency.html#%EB%82%9C%EA%B4%80",
    
    "relUrl": "/chapter13-concurrency.html#난관"
  },"45": {
    "doc": "13장 동시성",
    "title": "동시성 방어 원칙",
    "content": "단일 책임 원칙Single Responsibility Principle, SRP . 👉 동시성 관련 코드는 다른 코드와 분리해야 한다. | 동시성 자체만으로도 충분히 복잡하다. | 다른 코드에 섞이면 유지보수 난이도가 급격히 올라간다. | 동시성 코드(락, 스레드 관리, 동기화)는 별도의 모듈로 분리하라. | . 따름 정리corollary: 자료 범위를 제한하라 . 👉 자료를 캡슐화 하고, 공유 자료를 최대한 줄여라. 공유 자원은 가능하면 피하고, 꼭 필요하다면: . | synchronized 등으로 임계영역을 보호하라. | 임계영역의 범위를 최소화하라. | . 공유 자원을 수정하는 코드가 많을수록: . | 임계영역 보호를 빼먹기 쉽다. | 모든 임계영역을 올바르게 보호했는지 확인하는 데 많은 노력이 든다. | 찾기 어려운 동시성 버그는 더욱 찾기 어려워진다. | . 따름 정리: 자료 사본을 사용하라 . 가능한 경우, 공유하지 말고 복사본을 만들어 사용하라. | 읽기 전용 객체는 복사해 사용. | 각 스레드가 자신만의 사본을 만들어 독립적으로 작업. | 결과가 필요하면 한 스레드가 사본에서 최종 결과를 모은다. | . 예시 . | 불변 객체(Immutable Object) 사용. | 복사 생성자, 팩토리 메서드를 통한 복사. | Thread-Local Storage. | . 따름 정리: 스레드는 가능한 독립적으로 구현하라 . | 스레드 간 자료 공유를 피하라. | 각 스레드는 자신만의 데이터를 처리하도록 하라. | 로컬 변수만 사용하도록 설계하라. | . 예시: 서블릿의 doGet()/doPost() 메서드 . | HttpServlet의 doGet()과 doPost()는 요청별로 새로운 스레드에서 실행되며, 로컬 변수만 사용한다면 동기화 문제가 발생할 여지가 없다. | 각 요청 스레드가 독립적인 클라이언트 요청을 처리하고, 필요한 데이터는 비공유 출처에서 가져와 로컬 변수에 저장. | 결과적으로 스레드는 독립적이고 안전하게 동작한다. | . ",
    "url": "/chapter13-concurrency.html#%EB%8F%99%EC%8B%9C%EC%84%B1-%EB%B0%A9%EC%96%B4-%EC%9B%90%EC%B9%99",
    
    "relUrl": "/chapter13-concurrency.html#동시성-방어-원칙"
  },"46": {
    "doc": "13장 동시성",
    "title": "라이브러리를 이해하라",
    "content": "👉 언어가 제공하는 클래스를 검토하라. | 스레드 환경에 안전한 컬렉션을 사용한다. | Java 5 이상의 java.util.concurren 패키지 . | 이 컬렉션들은 다중 스레드 환경에서도 안전하게 동작하며, 성능까지 고려해 설계됨. | . | . | 서로 무관한 작업을 수행할 때는 executor 프레임워크를 사용한다. | ExecutorService, ScheduledExecutorService | 장점 . | 스레드 생성, 관리, 종료를 추상화. | 작업 큐 관리, 스레드 재사용, 에러 처리 등을 간단하게 처리. | . | . | 가능하다면 스레드가 차단되지 않는 방법을 사용한다. | 락 대신 비차단 알고리즘 (lock-free, CAS 기반 연산 등) 사용. | CAS (Compare-And-Swap) : CAS는 원자적(atomic) 연산 제공 . AtomicInteger counter = new AtomicInteger(0); counter.compareAndSet(0, 1); // counter가 0이면 1로 변경 . | 락을 사용하지 않고도 안전하게 변수 변경 가능. 실패하면 다시 시도 . | . | 동시성 유틸리티 (Atomic* 클래스, LongAdder 등) 활용. | 불필요한 대기를 줄이면 성능과 응답성이 향상됨. | . | 일부 클래스 라이브러리는 스레드에 안전하지 못하다. | ArrayList, HashMap, SimpleDateFormat 등. | 이런 클래스들을 사용할 때는: . | 외부에서 동기화를 직접 구현하거나, | 가능하면 스레드 안전한 대안으로 교체 (ConcurrentHashMap, DateTimeFormatter ). | . | . | . 스레드 환경에 안전한 컬렉션 . 👉 언어가 제공하는 클래스를 검토하라. | Java는 동시성 라이브러리를 제공한다. | 직접 구현하기 전에: . | 표준 라이브러리에 유사 기능이 있는지 확인. | 성능, 안전성, 유지보수 측면에서 검증된 라이브러리를 우선 사용. | . | . ",
    "url": "/chapter13-concurrency.html#%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC%EB%A5%BC-%EC%9D%B4%ED%95%B4%ED%95%98%EB%9D%BC",
    
    "relUrl": "/chapter13-concurrency.html#라이브러리를-이해하라"
  },"47": {
    "doc": "13장 동시성",
    "title": "실행 모델을 이해하라",
    "content": "동시성 유형 . | 문제 | 설명 | . | 한정된 자원(Bound Resource) | 다중 스레드 환경에서 사용되는 크기나 수량이 제한된 자원은 기다림, 블로킹, 경쟁 조건 등을 유발 가능 (데이터베이스 연결, 읽기/쓰기 버퍼) | . | 상호 배제 (Mutual Exclusion) | 한 번에 한 스레드만 공유 자원/자료에 접근 가능. | . | 기아 (Starvation) | 특정 스레드가 자원을 계속 얻지 못해 영원히 기다림.예: 짧은 작업에 우선순위를 주면 긴 작업은 계속 기다리게 됨. | . | 데드락 (Deadlock) | 여러 스레드가 서로의 자원을 기다리며 진행 불가.모든 스레드가 멈춘 상태. | . | 라이브락 (Livelock) | 각 스레드가 진행하려 하지만 서로 양보/회피하다가 계속 교착 상태에 빠짐.진행은 되지만 아무것도 끝나지 않음. | . 생산자-소비자Producer-Consumer . | 생산자 스레드: 데이터를 생성해 대기열(버퍼)에 넣음. | 소비자 스레드: 대기열에서 데이터를 꺼내 처리. | 문제 . | 생산자는 버퍼가 가득 차면 대기해야 함. | 소비자는 버퍼가 비면 대기해야 함. | 생산자와 소비자가 서로 시그널을 잘못 처리하면 둘 다 기다리는 상태에 빠질 수 있음. | . | . 읽기-쓰기 . 다수의 읽기 스레드는 공유 자원 읽기 가능하지만 하나의 쓰기 스레드는 공유 자원을 갱신한다고 할 때 . | 문제 . | 처리율을 강조하면 기아 현상이나 오래된 정보가 쌓이고, 갱신을 허용하면 처리율에 영향을 미친다. | 처리율과 일관성의 균형 필요. | . | 해결 방법 . | 읽기 우선 . | 쓰기 스레드는 읽기 스레드가 모두 끝나야 실행 가능. | 쓰기 스레드 기아(starvation) 위험. | . | 쓰기 우선 . | 읽기 스레드는 쓰기 스레드가 끝나야 실행 가능. | 쓰기 스레드가 연속 실행되면 전체 처리율 저하. | . | . | . 식사하는 철학자들 . N명의 철학자가 식탁에 앉아 있다. 각 철학자는 양쪽 포크를 모두 잡아야 식사를 할 수 있다. 인접 철학자가 포크를 들고 있다면 기다려야 한다. 여러 프로세스가 자원을 얻으려 경쟁하기 때문에 주의해서 설계하지 않으면 문제가 발생한다. 발생 가능한 문제 . | 데드락: 서로 포크를 기다리며 멈춤. | 라이브락: 포크를 놓았다 잡았다 반복하며 진행 못함. | 처리율 저하, 기아 등. | . 👉 위에서 설명한 기본 알고리즘과 각 해법을 이해하라. 동시성 문제를 단순히 “락 걸기”로만 해결하려 하지 말고: . | 자원 관리의 특성과 제한 이해. | 데드락, 기아, 라이브락 가능성 고려. | 표준 알고리즘/패턴 적용: . | 생산자-소비자 → BlockingQueue, Condition 사용. | 읽기-쓰기 → ReadWriteLock. | 식사하는 철학자 → 리소스 순서 지정, 타임아웃 도입 등 | . | . 을 고려해본다. ",
    "url": "/chapter13-concurrency.html#%EC%8B%A4%ED%96%89-%EB%AA%A8%EB%8D%B8%EC%9D%84-%EC%9D%B4%ED%95%B4%ED%95%98%EB%9D%BC",
    
    "relUrl": "/chapter13-concurrency.html#실행-모델을-이해하라"
  },"48": {
    "doc": "13장 동시성",
    "title": "동기화하는 메서드 사이에 존재하는 의존성을 이해하라",
    "content": "👉 원칙: 공유 객체 하나에는 동기화 메서드 하나만 사용하라. 공유 클래스의 여러 동기화 메서드가 서로 의존하면, 예상치 못한 문제가 발생할 수 있다. 멀티스레드 환경의 버그는 재현이 어렵고, 디버깅이 매우 힘들기 때문에 공유 객체는 하나의 메서드만 외부에서 접근 가능하도록 제한한다. 공유 객체 하나에 여러 메서드가 필요한 상황이라면? . | 방법 | 설명 | . | 클라이언트에서 잠금 | 클라이언트가 첫 번째 메서드 호출 전에 락을 획득하고, 마지막 메서드 호출 후 락 해제. | . | 서버에서 잠금 | 서버(공유 객체)에서 여러 메서드를 묶어서 락을 걸고 하나의 통합 메서드 제공. | . | 연결 서버 | 잠금을 담당하는 중간 계층(Wrapper, Facade)을 만들어서 관리. 서버 코드 수정 최소화. | . ",
    "url": "/chapter13-concurrency.html#%EB%8F%99%EA%B8%B0%ED%99%94%ED%95%98%EB%8A%94-%EB%A9%94%EC%84%9C%EB%93%9C-%EC%82%AC%EC%9D%B4%EC%97%90-%EC%A1%B4%EC%9E%AC%ED%95%98%EB%8A%94-%EC%9D%98%EC%A1%B4%EC%84%B1%EC%9D%84-%EC%9D%B4%ED%95%B4%ED%95%98%EB%9D%BC",
    
    "relUrl": "/chapter13-concurrency.html#동기화하는-메서드-사이에-존재하는-의존성을-이해하라"
  },"49": {
    "doc": "13장 동시성",
    "title": "동기화하는 부분을 작게 만들어라",
    "content": "같은 락으로 감싼 모든 코드 영역은 한 번에 한 스레드만 실행이 가능하다. synchronized로 감싼 코드가 클수록: . | 락 대기 시간이 증가 | 스레드 간 병목 현상 발생 | . 해결 방법 . | 임계영역(Critical Section)은 최소화 . // 불필요한 전체 메서드 락 public synchronized void update() { somethingLong(); // 오래 걸리는 작업 sharedList.add(\"data\"); // 실제 임계영역 } // 동기화 구간 최소화 public void updateData() { somethingLong(); // 동기화 필요 없음 synchronized (sharedList) { sharedList.add(\"data\"); } } . | . ",
    "url": "/chapter13-concurrency.html#%EB%8F%99%EA%B8%B0%ED%99%94%ED%95%98%EB%8A%94-%EB%B6%80%EB%B6%84%EC%9D%84-%EC%9E%91%EA%B2%8C-%EB%A7%8C%EB%93%A4%EC%96%B4%EB%9D%BC",
    
    "relUrl": "/chapter13-concurrency.html#동기화하는-부분을-작게-만들어라"
  },"50": {
    "doc": "13장 동시성",
    "title": "올바른 종료 코드는 구현하기 어렵다",
    "content": "👉 종료 코드는 초기에 설계한다. 종료 처리는 나중에 붙이는 게 아니라 처음부터 고려하고, 동작하는 형태로 작성해야 한다. 스레드 종료 처리는 단순히 종료 신호를 보내는 것으로 끝나지 않는다. 잘못된 종료 코드의 문제 . | 데드락 (Deadlock) | 무한 대기 (스레드가 신호를 못 받아 영원히 블로킹) | 자원 해제 누락 (락, 파일, DB 연결 등) | . 부모-자식 스레드 종료 문제 . 부모 스레드가 여러 자식 스레드를 생성 → 자식 스레드 종료를 기다림 → 자원 해제 후 종료 . | 문제 . | 자식 스레드 중 하나가 데드락 상태 → 부모는 영원히 대기 → 프로그램 종료 불가 | . | . 생산자-소비자 종료 문제 . | 소비자 스레드가 생산자의 시그널(데이터) 을 기다림 | 부모 스레드가 종료 신호를 보내도, 소비자는 생산자의 데이터가 없으므로 차단 상태 | 결국 소비자는 종료 신호를 못 받고, 생산자도 소비자가 데이터를 가져갈 때까지 차단 . 👉 데드락 발생 . | . ",
    "url": "/chapter13-concurrency.html#%EC%98%AC%EB%B0%94%EB%A5%B8-%EC%A2%85%EB%A3%8C-%EC%BD%94%EB%93%9C%EB%8A%94-%EA%B5%AC%ED%98%84%ED%95%98%EA%B8%B0-%EC%96%B4%EB%A0%B5%EB%8B%A4",
    
    "relUrl": "/chapter13-concurrency.html#올바른-종료-코드는-구현하기-어렵다"
  },"51": {
    "doc": "13장 동시성",
    "title": "스레드 코드 테스트하기",
    "content": ". | 말이 안 되는 실패는 잠정적인 스레드 문제로 취급하라 | 다중 스레드를 고려하지 않은 순차 코드부터 제대로 돌게 만들자 | 다중 스레드를 쓰는 코드 부분을 다양한 환경에 쉽게 끼워 넣을 수 있도록 스레드 코드를 구현하라 | 다중 스레드를 쓰는 코드 부분을 상황에 맞춰 조정할 수 있게 작성하라 | 프로세서 수보다 많은 스레드를 돌려보라 | 다른 플랫폼에서 돌려보라 | 코드에 보조 코드를 넣어 돌려라. 강제로 실패를 일으켜라. | . 말이 안 되는 실패는 잠정적인 스레드 문제로 취급하라 . | 다중 스레드 코드는 때때로 말이 안 되는 오류를 일으킨다. | 스레드 버그는 수백만 번에 한 번씩 드러나기도 한다. | 실패를 재현하기는 아주 어렵다. | 일회성 문제를 무시하지 말자 | . 다중 스레드를 고려하지 않은 순차 코드부터 제대로 돌게 만들자 . | 스레드 환경 밖에서 생기는 버그와 스레드 환경에서 생기는 버그를 동시에 디버깅하지 않고 스레드 환경 밖에서 코드가 제대로 도는지 반드시 확인한다. | 스레드가 호출하는 POJO를 만든다. POJO는 스레드를 모르기 때문에 스레드 환경 밖에서 테스트 가능하다. | . 다중 스레드를 쓰는 코드 부분을 다양한 환경에 쉽게 끼워 넣을 수 있게 스레드 코드를 구현하라 . | 한 스레드로 실행하거나, 여러 스레드로 실행하거나, 실행 중 스레드 수를 바꿔본다. | 스레드 코드를 실제 환경이나 테스트 환경에서 돌려본다. | 테스트 코드를 빨리, 천천히, 다양한 속도로 돌려본다. | 반복 테스트가 가능하도록 테스트 케이스를 작성한다. | 다양한 설정에서 실행한 목적은 다른 환경에 쉽게 끼워 넣을 수 있게 만드는 것. | . 다중 스레드를 쓰는 코드 부분을 상황에 맞게 조율할 수 있게 작성하라 . | 적절한 스레드 개수를 파악하려면 시행착오가 필요하다. | 다양한 설정으로 프로그램의 성능을 측정하는 방법을 강구하라. | 스레드 개수를 조율하기 쉽게 코드를 구현하라. | 프로그램이 돌아가는 도중에 스레드 개수를 변경하는 방법도 고려하라. | 프로그램 처리율과 효율에 따라 스스로 스레드 개수를 조율하는 코드도 고민하라. | . 프로세서 수보다 많은 스레드를 돌려보라 . | 시스템이 스레드를 스와핑할 때 문제가 발생할 수 있다. | 스와핑을 일으키려면 프로세서 수보다 많은 스레드를 돌려라. | 스와핑이 잦을수록 임계영역을 빼먹은 코드나 데드락을 일으키는 코드를 찾기 쉬워진다. | . 다른 플랫폼에서 돌려보라 . | 다중 스레드 코드는 플랫폼에 따라 다르게 돌아간다. | 코드가 돌아갈 가능성이 있는 플랫폼 전부에서 테스트를 수행해야 한다. | . 코드에 보조 코드를 넣어 돌려라. 강제로 실패를 일으키게 해보라 . | 스레드 코드는 간단한 테스트로는 버그가 드러나지 않는다. | 스레드 버그는 실패하는 경로가 실행될 확률이 극도로 저조하다. | 버그를 발견하고 찾아내기가 아주 어렵다. | 보조 코드를 추가해 코드가 실행되는 순서를 바꿔 코드의 다양한 순서를 실행하라. | wait(), sleep(), yield(), priority()… | 각 메서드는 스레드가 실행되는 순서에 영향을 미치고 버그가 드러날 가능성도 높아진다. 잘못된 코드라면 가능한 초반에 가능한 자주 실패하는 편이 좋다. | . | . 코드에 보조 코드를 추가하는 방법 . | 직접 구현 . | 코드에다 직접 wait(), sleep(), yield(), priority() 메서드를 추가한다. public synchronized String nextUrlOrNull() { if (hasNext()) { String url = urlGenerator.next(); Thread.yield(); // 테스트를 위해 추가 updateHasNext(); return url; } return null; } . | 문제 . | 보조 코드를 삽입할 적정 위치를 직적 찾아야 한다. | 어던 함수를 어디서 호출해야 적당한지 어떻게 알지? | 배포 환경에 보조 코드를 그대로 남겨두면 프로그램 성능이 떨어진다. | 무작위적이다. 오류가 드러날지도 모르고 드러나지 않을지도 모른다. | 실행할 때마다 설정을 바꿔줄 방법도 필요하다. 그래야 전체적으로 오류가 드러날 확률이 높아진다. | . | . | 자동화 . | AOF, CGLIB, ASM 등 도구를 사용해 자동화할 수 있다. public class ThreadJigglePoint { public static void jiggle() { // sleep, yield, nop 무작위 수행 } } public synchronized String nextUrlOrNull() { if (hasNext()) { ThreadJigglePoint.jiggle(); String url = urlGenerator.next(); ThreadJigglePoint.jiggle(); updateHasNext(); ThreadJigglePoint.jiggle(); return url; } return null; } . | ThreadJigglePoint.jiggle() 호출은 무작위로 sleep(), yield(), nop(아무 동작 안 함) 중 하나를 수행한다. | jiggle() 메서드를 비워두고 배포 환경에서 사용한다. | 무작위로 nop, sleep, yield 등을 테스트 환경에서 수행한다. | . | . | . 결론 . | 다중 스레드 코드는 올바르게 구현하기 어렵다. | 다중 스레드 코드를 작성한다면 각별히 깨끗하게 코드를 짜야 한다. | SRP(단일 책임 원칙)를 준수하여 스레드를 아는 코드와 스레드를 모르는 코드로 분리한다. | 스레드 코드를 테스트할 때는 전적으로 스레드만 테스트한다. | 스레드 코드는 최대한 집약되고 작아야 한다. | 동시성 오류를 일으키는 잠정적인 원인을 철저히 이해해야 한다. | 사용하는 라이브러리의 기본 알고리즘을 이해해야 한다. | 보호할 코드 영역을 찾아내는 방법과 코드 영역을 잠그는 방법을 이해해야 한다. | 초반에 드러나지 않는 문제를 일회성으로 치부해 무시하면 안 된다. | 스레드 코드는 많은 플랫폼에서 많은 설정으로 반복해서 계속 테스트해야 한다. | 보조 코드를 추가해 오류가 드러날 가능성을 크게 높인다. | . ",
    "url": "/chapter13-concurrency.html#%EC%8A%A4%EB%A0%88%EB%93%9C-%EC%BD%94%EB%93%9C-%ED%85%8C%EC%8A%A4%ED%8A%B8%ED%95%98%EA%B8%B0",
    
    "relUrl": "/chapter13-concurrency.html#스레드-코드-테스트하기"
  },"52": {
    "doc": "14장 점진적인 개선",
    "title": "14장 점진적인 개선",
    "content": " ",
    "url": "/chapter14-incremental-improvement.html",
    
    "relUrl": "/chapter14-incremental-improvement.html"
  },"53": {
    "doc": "14장 점진적인 개선",
    "title": "Args 구현",
    "content": "Args.class : 명령행 인수를 정의된 형식(schema)에 따라 파싱하고, 해당 값을 타입별로 쉽게 조회할 수 있게 해주는 유틸리티 클래스 . public static void main(String[] args) { try { Args arg = new Args(\"l,p#,d*\", args); boolean logging = arg.getBoolean('l'); int port = arg.getInt('p'); String directory = arg.getString('d'); executeApplication(logging, port, directory); } catch (ArgsException e) { System.out.printf(\"Argument error: %s\\n\", e.errorMessage()); } } . 매개변수 \"l,p#,d*\": 명령행 인수의 스키마. 각각의 문자는 인수의 이름과 타입을 나타낸다. | l → boolean 값 (true/false) | p# → 정수형 인수 | d* → 문자열 인수 | . 두 번째 매개변수: 실제 명령행에서 받은 인수 배열. 파싱해서 각 타입에 맞게 저장한다. 파싱이 성공적으로 끝나면 메서드(getBoolean, getInt, getString)를 통해 인수 값을 조회할 수 있다. Args 핵심 . | 구성 요소 | 책임 | . | Args | 스키마 해석, 인수 파싱 | . | ArgumentMarshaler | 인수 유형 인터페이스 | . | `ArgumentMarshaler` | 실제 파싱 로직 | . | ArgsException | 오류 처리 | . public class Args { private Map&lt;Character, ArgumentMarshaler&gt; marshalers; private Set&lt;Character&gt; argsFound; private ListIterator&lt;String&gt; currentArgument; public Args(String schema, String[] args) throws ArgsException { marshalers = new HashMap&lt;&gt;(); argsFound = new HashSet&lt;&gt;(); parseSchema(schema); parseArgumentStrings(Arrays.asList(args)); } . | marshalers: 각 인수 이름(l, p, d)에 대응하는 처리 객체를 저장하는 Map | argsFound: 실제 입력에서 발견된 인수 목록을 추적하는 Set | currentArgument: 인수를 순회하며 파싱할 때 사용 | . private void parseSchema(String schema) throws ArgsException { for (String element : schema.split(\",\")) if (element.length() &gt; 0) parseSchemaElement(element.trim()); } private void parseSchemaElement(String element) throws ArgsException { char elementId = element.charAt(0); String elementTail = element.substring(1); validateSchemaElementId(elementId); if (elementTail.length() == 0) marshalers.put(elementId, new BooleanArgumentMarshaler()); else if (elementTail.equals(\"*\")) marshalers.put(elementId, new StringArgumentMarshaler()); else if (elementTail.equals(\"#\")) marshalers.put(elementId, new IntegerArgumentMarshaler()); else if (elementTail.equals(\"##\")) marshalers.put(elementId, new DoubleArgumentMarshaler()); else if (elementTail.equals(\"[*]\")) marshalers.put(elementId, new StringArrayArgumentMarshaler()); else throw new ArgsException(INVALID_ARGUMENT_FORMAT, elementId, elementTail); } } . | 형식 문자열은 쉼표로 구분된 각 인수 정의(l, p#, d* )로 나눈다. | parseSchemaElement()는 각 정의를 파싱하여 해당 타입에 맞는 ArgumentMarshaler를 marshalers에 등록한다. | . private void parseArgumentStrings(List&lt;String&gt; argsList) throws ArgsException { for (currentArgument = argsList.listIterator(); currentArgument.hasNext();) { String argString = currentArgument.next(); if (argString.startsWith(\"-\")) { parseArgumentCharacters(argString.substring(1)); } else { currentArgument.previous(); break; } } . 실제 명령행 인수를 순회하면서 -로 시작하는 항목을 발견하면 해당 인수 문자를 분해해 파싱한다. | p 8080이라면 p를 찾아서 IntegerArgumentMarshaler에 값을 설정한다. | . ArgumentMarshaler 인터페이스와 파생 클래스 . public interface ArgumentMarshaler { void set(Iterator&lt;String&gt; currentArgument) throws ArgsException; } . 모든 인수 타입은 이 인터페이스를 구현한다. 각 타입별 구현 클래스는 다음과 같다: . | BooleanArgumentMarshaler : 단순히 true로 설정 | StringArgumentMarshaler : 다음 인수를 문자열로 저장 | IntegerArgumentMarshaler : 다음 인수를 정수로 변환 | DoubleArgumentMarshaler : 다음 인수를 실수로 변환 | StringArrayArgumentMarshaler : 문자열 배열로 저장 ([*] 형식) | . 각 클래스는 getValue()라는 static 메서드로 결과를 조회할 수 있도록 한다. 독자는 코드를 위에서 아래로 순차적으로 읽을 수 있다. ArgsException : 에러 처리 . public class ArgsException extends Exception { // ... public enum ErrorCode { OK, INVALID_ARGUMENT_FORMAT, UNEXPECTED_ARGUMENT, INVALID_ARGUMENT_NAME, MISSING_STRING, MISSING_INTEGER, INVALID_INTEGER, MISSING_DOUBLE, INVALID_DOUBLE } public String errorMessage() { switch (errorCode) { case OK: return \"TILT: Should not get here.\"; case UNEXPECTED_ARGUMENT: return String.format(\"Argument -%c unexpected.\", errorArgumentId); // 생략... } } } . 에러 상황을 명확히 구분하기 위해 열거형 ErrorCode를 사용하며, 사용자에게 전달할 수 있는 에러 메시지 . 설계 특징 . | 가독성이 좋다: 위에서 아래로 순차적으로 읽히며 흐름이 자연스럽다. | 확장에 유리하다: 새 인수 유형을 추가하려면 ArgumentMarshaler를 확장하고 parseSchemaElement()에 한 줄만 추가하면 된다. | 책임 분리가 명확하다: 스키마 파싱, 인수 파싱, 타입별 처리, 예외 처리 등이 잘 나뉘어 있다. | . 어떻게 짰느냐고? . 프로그래밍은 과학이라기보다는 공예에 가깝다. 처음부터 깔끔한 코드가 나오는 경우는 거의 없다. 일단 동작하는 지저분한 코드를 짠 뒤, 계속해서 다듬고 정리해서 최종 버전을 만든다. 대부분의 초보자는 코드가 “돌아가기만” 하면 만족하고 다음 단계로 넘어간다. 하지만 숙련된 개발자는 돌아가는 코드가 아니라, 읽기 좋고 고치기 좋은 코드가 진짜 코드라는 걸 안다. ",
    "url": "/chapter14-incremental-improvement.html#args-%EA%B5%AC%ED%98%84",
    
    "relUrl": "/chapter14-incremental-improvement.html#args-구현"
  },"54": {
    "doc": "14장 점진적인 개선",
    "title": "Args: 1차 초안",
    "content": "import java.text.ParseException; import java.util.*; public class Args { private String schema; private String[] args; private boolean valid = true; private Set&lt;Character&gt; unexpectedArguments = new TreeSet&lt;Character&gt;(); private Map&lt;Character, Boolean&gt; booleanArgs = new HashMap&lt;Character, Boolean&gt;(); private Map&lt;Character, String&gt; stringArgs = new HashMap&lt;Character, String&gt;(); private Map&lt;Character, Integer&gt; intArgs = new HashMap&lt;Character, Integer&gt;(); private Set&lt;Character&gt; argsFound = new HashSet&lt;Character&gt;(); private int currentArgument; private char errorArgumentId = '\\0'; private String errorParameter = \"TILT\"; private ErrorCode errorCode = ErrorCode.OK; private enum ErrorCode { OK, MISSING_STRING, MISSING_INTEGER, INVALID_INTEGER, UNEXPECTED_ARGUMENT} public Args(String schema, String[] args) throws ParseException { this.schema = schema; this.args = args; valid = parse(); } private boolean parse() throws ParseException { if (schema.length() == 0 &amp;&amp; args.length == 0) return true; parseSchema(); try { parseArguments(); } catch (ArgsException e) { } return valid; } private boolean parseSchema() throws ParseException { for (String element : schema.split(\",\")) { if (element.length() &gt; 0) { String trimmedElement = element.trim(); parseSchemaElement(trimmedElement); } } return true; } private void parseSchemaElement(String element) throws ParseException { char elementId = element.charAt(0); String elementTail = element.substring(1); validateSchemaElementId(elementId); if (isBooleanSchemaElement(elementTail)) parseBooleanSchemaElement(elementId); else if (isStringSchemaElement(elementTail)) parseStringSchemaElement(elementId); else if (isIntegerSchemaElement(elementTail)) parseIntegerSchemaElement(elementId); else throw new ParseException(String.format(\"Argument: %c has invalid format: %s.\", elementId, elementTail), 0); } } private void validateSchemaElementId(char elementId) throws ParseException { if (!Character.isLetter(elementId)) { throw new ParseException(\"Bad character:\" + elementId + \"in Args format: \" + schema, 0); } } private void parseBooleanSchemaElement(char elementId) { booleanArgs.put(elementId, false); } private void parseIntegerSchemaElement(char elementId) { intArgs.put(elementId, 0); } private void parseStringSchemaElement(char elementId) { stringArgs.put(elementId, \"\"); } private boolean isStringSchemaElement(String elementTail) { return elementTail.equals(\"*\"); } private boolean isBooleanSchemaElement(String elementTail) { return elementTail.length() == 0; } private boolean isIntegerSchemaElement(String elementTail) { return elementTail.equals(\"#\"); } private boolean parseArguments() throws ArgsException { for (currentArgument = 0; currentArgument &lt; args.length; currentArgument++) { String arg = args[currentArgument]; parseArgument(arg); } return true; } private void parseArgument(String arg) throws ArgsException { if (arg.startsWith(\"-\")) parseElements(arg); } private void parseElements(String arg) throws ArgsException { for (int i = 1; i &lt; arg.length(); i++) parseElement(arg.charAt(i)); } private void parseElement(char argChar) throws ArgsException { if (setArgument(argChar)) argsFound.add(argChar); else unexpectedArguments.add(argChar); errorCode = ErrorCode.UNEXPECTED_ARGUMENT; valid = false; } private boolean setArgument(char argChar) throws ArgsException { if (isBooleanArg(argChar)) setBooleanArg(argChar, true); else if (isStringArg(argChar)) setStringArg(argChar); else if (isIntArg(argChar)) setIntArg(argChar); else return false; return true; } private boolean isIntArg(char argChar) { return intArgs.containsKey(argChar); } private void setIntArg(char argChar) throws ArgsException { currentArgument++; String parameter = null; try { parameter = args[currentArgument]; intArgs.put(argChar, new Integer(parameter)); } catch (ArrayIndexOutOfBoundsException e) { valid = false; errorArgumentId = argChar; errorCode = ErrorCode.MISSING_INTEGER; throw new ArgsException(); } catch (NumberFormatException e) { valid = false; errorArgumentId = argChar; errorParameter = parameter; errorCode = ErrorCode.INVALID_INTEGER; throw new ArgsException(); } } private void setStringArg(char argChar) throws ArgsException { currentArgument++; try { stringArgs.put(argChar, args[currentArgument]); } catch (ArrayIndexOutOfBoundsException e) { valid = false; errorArgumentId = argChar; errorCode = ErrorCode.MISSING_STRING; throw new ArgsException(); } } private boolean isStringArg(char argChar) { return stringArgs.containsKey(argChar); } private void setBooleanArg(char argChar, boolean value) { booleanArgs.put(argChar, value); } private boolean isBooleanArg(char argChar) { return booleanArgs.containsKey(argChar); } public int cardinality() { return argsFound.size(); } public String usage() { if (schema.length() &gt; 0) return \"-[\" + schema + \"]\"; else return \"\"; } public String errorMessage() throws Exception { switch (errorCode) { case OK: throw new Exception(\"TILT: Should not get here.\"); case UNEXPECTED_ARGUMENT: return unexpectedArgumentMessage(); case MISSING_STRING: return String.format(\"Could not find string parameter for -%c.\", errorArgumentId); case INVALID_INTEGER: return String.format(\"Argument -%c expects an integer but was '%s'.\", errorArgumentId, errorParameter); case MISSING_INTEGER: return String.format(\"Could not find integer parameter for -%c.\", errorArgumentId); } return \"\"; } private String unexpectedArgumentMessage() { StringBuffer message = new StringBuffer(\"Argument(s) -\"); for (char c : unexpectedArguments) { message.append(c); } message.append(\" unexpected.\"); return message.toString(); } private boolean falseIfNull(Boolean b) { return b != null &amp;&amp; b; } private int zeroIfNull(Integer i) { return i == null ? 0 : i; } private String blankIfNull(String s) { return s == null ? \"\" : s; } public String getString(char arg) { return blankIfNull(stringArgs.get(arg)); } public int getInt(char arg) { return zeroIfNull(intArgs.get(arg)); } public boolean getBoolean(char arg) { return falseIfNull(booleanArgs.get(arg)); } public boolean has(char arg) { return argsFound.contains(arg); } public boolean isValid() { return valid; } private class ArgsException extends Exception { } } . 그래서 멈췄다 . | 타입별 처리 로직이 스키마 파싱, 인수 파싱, 값 조회의 세 곳에 중복되어 있음 | 새로운 타입을 추가하려면 세 군데 이상 수정해야 함 | Map&lt;Character, Type&gt;이 여러 개 존재해 응집도가 낮고 중복됨 | ArgsException이 실질적인 정보 전달에 활용되지 않음 | . 인수 유형은 다양하지만 모두가 유사한 메서드를 제공. 👉 인터페이스스 ArgumentMarshaler 탄생 . 점진적으로 개선하다 . 프로그램을 망치는 가장 빠른 방법 중 하나는 ‘개선’이라는 이름 아래 구조를 무리하게 뒤엎는 것이다. 그렇게 구조를 크게 바꾼 프로그램은 대개 다시는 정상으로 돌아오지 못한다. 변경 후에도 시스템이 이전과 정확히 같은 방식으로 동작하는 것이 정말 어려워지기 때문이다. 👉 테스트 주도 개발(TDD) . TDD는 항상 시스템이 정상적으로 동작해야 한다는 원칙을 기반으로 한다. 즉, 어떤 변경을 하든 간에 프로그램은 여전히 잘 돌아가야 한다. 변경 이후에도 프로그램이 이전과 동일한 결과를 보장해야만 한다. 이걸 보장하려면 언제든 실행 가능한 자동화 테스트가 필수다. 리팩토링을 할 때는 코드를 최소로 건드리는, 가장 단순한 변경 부터 시작한다. 구조 변경을 최소화하면서도 코드를 점점 더 좋은 방향으로 개선해 나가도 TDD 덕분에 언제든 테스트로 변경이 안전함을 검증할 수 있었고, 덕분에 과감한 구조 개선도 시도할 수 있다. | Map&lt;Character, Boolean&gt;→ Map&lt;Character, ArgumentMarshaler&gt;로 변경 | . // 전: boolean 값을 직접 저장 private Map&lt;Character, Boolean&gt; booleanArgs = new HashMap&lt;&gt;(); // 후: ArgumentMarshaler 객체 저장 private Map&lt;Character, ArgumentMarshaler&gt; booleanArgs = new HashMap&lt;&gt;(); . // 전: 스키마 요소 파싱 시 true로 저장 private void parseBooleanSchemaElement(char elementId) { booleanArgs.put(elementId, false); // 기본값 } // 후: BooleanArgumentMarshaler 객체 저장 private void parseBooleanSchemaElement(char elementId) { booleanArgs.put(elementId, new BooleanArgumentMarshaler()); } . // 전: 값 설정 private void setBooleanArg(char argChar, boolean value) { booleanArgs.put(argChar, value); } // 후: BooleanArgumentMarshaler 내부에 값 설정 private void setBooleanArg(char argChar, boolean value) { booleanArgs.get(argChar).setBoolean(value); } . // 전: 값 조회 public boolean getBoolean(char arg) { Boolean value = booleanArgs.get(arg); return value != null &amp;&amp; value; } // 후: BooleanArgumentMarshaler에서 값 꺼내기 public boolean getBoolean(char arg) { ArgumentMarshaler am = booleanArgs.get(arg); return am != null &amp;&amp; am.getBoolean(); } . ",
    "url": "/chapter14-incremental-improvement.html#args-1%EC%B0%A8-%EC%B4%88%EC%95%88",
    
    "relUrl": "/chapter14-incremental-improvement.html#args-1차-초안"
  },"55": {
    "doc": "14장 점진적인 개선",
    "title": "String 인수",
    "content": "나머지 인수 추가 과정은 boolean 인수 처리 방식과 유사하다. | 우선 HashMap에 관련 정보를 저장하도록 하고, parse, set, get 함수를 수정 | 모든 인수 유형에 대한 처리를 ArgumentMarshaler에 넣고, | 파생 클래스로 분리 | . 이렇게 하면 프로그램 구조를 점진적으로 개선하면서도 정상 동작을 유지할 수 있다. 기존 예외 코드의 문제 . | 코드가 흉하고 읽기 어렵다. | Args 클래스와 무관한 책임을 떠안고 있다. | ParseException을 던지지만, 이는 Args 모듈에 소속되지 않는다. | . 👉 모든 예외 처리를 ArgsException이라는 독립 클래스로 . | Args 모듈과 예외/오류 처리 로직을 분리 | . public class ArgsException extends Exception { private char errorArgumentId = '\\0'; private String errorParameter = \"TILT\"; private ErrorCode errorCode = ErrorCode.OK; public ArgsException() {} public ArgsException(String message) {super(message);} public ArgsException(ErrorCode errorCode) { this.errorCode = errorCode; } public ArgsException(ErrorCode errorCode, String errorParameter) { this.errorCode = errorCode; this.errorParameter = errorParameter; } public ArgsException(ErrorCode errorCode, char errorArgumentId, String errorParameter) { this.errorCode = errorCode; this.errorParameter = errorParameter; this.errorArgumentId = errorArgumentId; } public char getErrorArgumentId() { return errorArgumentId; } public void setErrorArgumentId(char errorArgumentId) { this.errorArgumentId = errorArgumentId; } public String getErrorParameter() { return errorParameter; } public void setErrorParameter(String errorParameter) { this.errorParameter = errorParameter; } public ErrorCode getErrorCode() { return errorCode; } public void setErrorCode(ErrorCode errorCode) { this.errorCode = errorCode; } public String errorMessage() throws Exception { switch (errorCode) { case OK: throw new Exception(\"TILT: Should not get here.\"); case UNEXPECTED_ARGUMENT: return String.format(\"Argument -%c unexpected.\", errorArgumentId); case MISSING_STRING: return String.format(\"Could not find string parameter for -%c.\", errorArgumentId); case INVALID_INTEGER: return String.format(\"Argument -%c expects an integer but was '%s'.\", errorArgumentId, errorParameter); case MISSING_INTEGER: return String.format(\"Could not find integer parameter for -%c.\", errorArgumentId); case INVALID_DOUBLE: return String.format(\"Argument -%c expects a double but was '%s'.\", errorArgumentId, errorParameter); case MISSING_DOUBLE: return String.format(\"Could not find double parameter for -%c.\", errorArgumentId); } return \"\"; } public enum ErrorCode { OK, INVALID_FORMAT, UNEXPECTED_ARGUMENT, INVALID_ARGUMENT_NAME, MISSING_STRING, MISSING_INTEGER, INVALID_INTEGER, MISSING_DOUBLE, INVALID_DOUBLE } } . | 에러 코드(ErrorCode)를 열거형으로 정의. | 인수 식별자, 파라미터 값을 저장. | 오류 메시지를 생성하는 errorMessage() 메서드 포함. | SRP(Single Responsibility Principle) 준수 | . ",
    "url": "/chapter14-incremental-improvement.html#string-%EC%9D%B8%EC%88%98",
    
    "relUrl": "/chapter14-incremental-improvement.html#string-인수"
  },"56": {
    "doc": "14장 점진적인 개선",
    "title": "결론",
    "content": "그저 돌아가기만 하는 코드는 부족하다. 나쁜 코드보다 개발 프로젝트에 더 심각한 악영향을 끼친다. | 나쁜 일정은 다시 계획하면 된다. | 나쁜 요구사항은 다시 정의하면 된다. | 나쁜 팀 역학은 복구할 수 있다. | . 시간이 지날수록 무게가 늘어나고 팀의 발목을 잡는다. 물론 나쁜 코드도 깨끗한 코드로 바꿀 수는 있지만 그 비용은 크다. | 코드가 썩어가면서 뒤엉키는 모듈들 | 수없이 생기는 숨겨진 의존성 | 그 의존성을 찾아 깨는 데는 막대한 시간과 인내 | . 처음부터 깨끗하게 유지하는 것은 상대적으로 쉽다. 아침에 엉망으로 만든 코드를 오후에 정리하는 건 어렵지 않다. 더 나아가, 5분 전에 만든 엉망진창 코드는 바로 지금 정리하는 게 가장 쉽다. 코드는 언제나 최대한 깔끔하고 단순하게 유지해야 한다. 절대로 썩어가도록 방치해서는 안 된다. ",
    "url": "/chapter14-incremental-improvement.html#%EA%B2%B0%EB%A1%A0",
    
    "relUrl": "/chapter14-incremental-improvement.html#결론"
  },"57": {
    "doc": "15장 JUnit",
    "title": "15장 JUnit",
    "content": " ",
    "url": "/chapter15-junit.html",
    
    "relUrl": "/chapter15-junit.html"
  },"58": {
    "doc": "15장 JUnit",
    "title": "JUnit 프레임워크",
    "content": "기존 . public class Comparisoncompactor{ private static final String ELLIPSIS = \"...\"; private static final String DELTA_END = \"]\"; private static final String DELTA_START = \"[\"; private int fContextLength; private String fExpected; private String fActual; private int fPrefix; private int fSuffix; public ComparisonCompactor(int contextLength, String expected, String actual){ fContextLength = contextLength; fExpected = expected; fActual = actual; } public String compact(String message) { if(fExpected == null || fActual == null || areStringsEqual()) return Assert.format(message, fExpected, fActual); findCommonPrefix(); findCommonSuffix(); String expected = comapactString(fExpected); String actual = comapactString(fActual); return Assert.format(message, expected, actual); } private String compactString(String source){ String result = DELTA_START + source.substring(fPrefix, source.length() - fSuffix + 1) + DELTA_END; if(fPrefix &gt; 0) result = computeCommonPrefix() + result; if(fSuffix &gt; 0) result = result + computeCommonSuffix(); return result; } private void findCommonPrefix(){ fPrefix = 0; int end = Math.min(fExpected.length(), fActual.length()); for(; fPrefix &lt; end; fPrefix++){ if(fExpected.charAt(fPrefix) != fActual.charAt(fPrefix)) break; } } private void findCommonSuffix(){ int expectedSuffix = fExpected.length()-1; int actualSuffix = fActual.length()-1; for(; actualSuffix &gt;= fPrefix &amp;&amp; expectedSuffix &gt;= fPrefix; actualSuffix--, expectedSuffix--){ if(fExpected.charAt(expectedSuffix) != fActual.charAt(actualSuffix)) break; } fSuffix = fExpected.length() - expectedSuffix; } private String computeCommonPrefix(){ return (fPrefix &gt; fContextLength ? ELLIPSIS : \"\") + fExpected.substring(Math.max(0, fPrefix - fContextLegnth), fPrefix); } private String computeCommonSuffix(){ int end = Math.min(fExepcted.legngth() - fSuffix - fContextLength, fExpected.length()); return fExpected.substirng(fExpected.length() - fSuffix +1, end) + (fExpected.length() - fSuffix +1 &lt; fExpected.length() - fContextLength ? ELLIPSIS :\"\") } private boolean areStringEqual(){ return fExpected.equals(fActual); } } . | 접두어 f 제거: 오늘날에는 접두어가 따로 필요하지 않다. | 지역변수와 접두어f를 제거한 변수명 구분을 위해 더욱 명확한 네이밍 | . | 조건문 캡슐화: 의도를 명확하게 하기 위해서는 조건문을 캡슐화 | 조건문을 긍정문으로 변경 | 조건문을 명확한 이름으로 캡슐화 | 숨겨진 시간적인 결합을 외부에 노출: findCommonPrefix() 후 findCommonSuffix()를 호출해야함 . | 순서를 지정한 새로운 함수 정의: findCommonPrefixAndSuffix() | findCommonPrefixAndSuffix() 내에 시간적인 결합 내용을 정의 | . | index와 length의 차이: 0부터 시작하는가? . | 만약 length를 구하기 위해 계속해서 +1 연산을 한다면, 차라리 index로 네이밍하자 | . | . 결과 . public class ComparisonCompactor{ private static final String ELLIPSIS = \"...\"; private static final String DELTA_END = \"]\"; private static final String DELTA_START = \"[\"; private int contextLength; private String expected; private String actual; private int prefixLength; public ComparisonCompactor(int contextLength, String expected, String actual){ this.contextLength = contextLength; this.expected = expected; this.actual = actual; } public String formatCompactedComparison(String message){ String compactExpected = expected; String compactActual = actual; if(shouldBeCompacted()){ findCommonPrefixAndSuffix(); compactExpected = comapactString(expected); compactActual = comapactString(actual); } return Assert.format(message, compactExpected, compactActual); } private boolean shouldBeCompacted(){ return !shouldNotBeCompacted(); } private boolean shouldBeCompacted(){ return expected == null || actual == null || expected.equals(actual); } private void findCommonPrefixAndSuffix(){ findCommonPrefix(); suffixLength = 0; for(; suffixOverlapsPrefix(suffixLength); suffixLength++){ if(charFromEnd(expected, suffixLength) != charFromEnd(actual, suffixLength)) break; } } private char charFromEnd(String s, int i){ return s.charAt(s.length() -i -1); } private boolean suffixOverlapsPrefix(int suffixLength){ return actual.length() - suffixLength &lt;= prefixLength || expected.length() - suffixLength &lt;= prefixLength; } private void findCommonPrefixAndSuffix(){ prefixLength = 0; int end = Math.min(expected.length(), actual.length()); for(; prefixLength &lt; end; prefixLength ++) if(expected.chatAt(prefixLength) != actual.charAt(prefixLength)) break; } private String compact(String s){ return new StringBuilder() .append(startingEllipsis()) .append(startingContext()) .append(DELTA_START) .append(delta(s)) .append(DELTA_END) .append(endingContext()) .append(endingEllipsis()) .toString(); } private String startingEllipsis(){ return prefixLength &gt; contextLength ? ELLIPSIS : \"\"; } private String startingContext(){ int contextStart = Math.max(0, prefixLength = contextLength); int contextEnd = prefixLength; return expected.substring(contextStart, contextEnd); } private String delta(String s){ int dletaStart = prefixLength; int deltaEnd = s.length() - suffixLenth; return s.substring(deltaStart, deltaEnd); } private String endContext(){ int contextStart = expected.length() - suffixLength; int contextEnd = Math.min(contextStart + contextLength, expected.length()); return expected.substring(contextStart, contextEnd); } private String endingEllipsis(){ return (suffixLength &gt; contextLenth ? ELLIPSIS :\"\"); } } . | 리팩토링을 진행하다보면 어느 수준에 이를 때까지 시행착오를 반복하는 작업이다. | . ",
    "url": "/chapter15-junit.html#junit-%ED%94%84%EB%A0%88%EC%9E%84%EC%9B%8C%ED%81%AC",
    
    "relUrl": "/chapter15-junit.html#junit-프레임워크"
  },"59": {
    "doc": "16장 SerialDate 리팩토링",
    "title": "16장 SerialDate 리팩토링",
    "content": " ",
    "url": "/chapter16-SerialDate-refactoring.html",
    
    "relUrl": "/chapter16-SerialDate-refactoring.html"
  },"60": {
    "doc": "16장 SerialDate 리팩토링",
    "title": "첫째, 돌려보자",
    "content": "확인한 내용 . | 테스트 케이스는 실패하지 않고 있지만, 코드의 전체 범위를 점검하지 않고 있음 | 아마도 실패하는 테스트 케이스는 주석으로 처리한 듯 | stringToWeekdayCode()는 대소문자를 구분해 통과하게 되어있다. | getFollowingDayOfWeek() 메서드의 버그: 다음 토요일을 가져올 때, 연도가 바뀌면 정확하게 가져오지 못함 = 경계 조건 오류 | . ",
    "url": "/chapter16-SerialDate-refactoring.html#%EC%B2%AB%EC%A7%B8-%EB%8F%8C%EB%A0%A4%EB%B3%B4%EC%9E%90",
    
    "relUrl": "/chapter16-SerialDate-refactoring.html#첫째-돌려보자"
  },"61": {
    "doc": "16장 SerialDate 리팩토링",
    "title": "둘째, 고쳐보자",
    "content": ". | 코드를 고칠 때마다 JCommon 단위 테스트와 새로 작성한 테스트를 실행 | . 문제점 . | 클래스 이름이 SerialDate인 이유는 일련번호를 사용해 클래스를 구현 . | 일련번호라는 용어가 정확하지 못함, 상대 오프셋(relative offset)이나 서수(Ordinal)가 더 적절하다 | . | 클래스의 이름을 들었을 때에는 구현 클래스같이 느껴지지만, 실제로는 추상 클래스이기 때문에 추상적인 이름 Date가 적절하지만 이는 java와 겹칠 수 있어 DayDate라고 변경 . | MonthConstants는 상수 모음이기 때문에 enum으로 정의 . | isValidMonthCode 메서드 삭제: enum으로 받기 때문에 | monthCodeToQuarter 메서드 삭제: enum으로 받기 때문에 | . | . | serialVersionUID: 직렬화를 제어하는 변수로, 값을 변경시 이전 소프트웨어에서 직렬화한 DayDate를 인식하지 못한다. | 변수를 선언하지 않으면, 컴파일러가 자동으로 생성하는데 이 방법이 더 안전하다고 느껴짐 -&gt; 만약 누군가 변경하지 않아서 생긴 버그를 찾는 것보다 이게 더 나을 것이라는 의견 | . | EARLIEDST_DATE_ ORDINAL의 값이 0이 아닌 2인 이유는 마이크로소프트 엑셀에서 날짜를 표현하는 방식과 관련이 있음 -&gt; 하지만 이 내용은 excel과 관련이 없어보임 . | DayDate에 속하지 않으며,SpreadsheetDate 클래스로 옮겨져야 한다고 생각 | . | 기반 클래스는 파생 클래스를 몰라야 바람직함, 그래서 ABSTRACT FACTORY 패턴을 적용해 DayDateFactory를 생성 . | final 제거 . | 로버트 시몬스: 코드 전체에 final을 사용하라고 강력 권장 | 저자: 상수 몇군데를 제하면 별다른 가치가 없고, 코드만 복잡하게 만듬, 테스트 커버로 final 부분을 다 커버함 | . | 첫번째 getMonths는 두번째 getMonths를 호출 -&gt; 하나로 합쳐 단순화 . | monthCodeToQuarter(): 기능 욕심으로 보임 . | 출력 형식을 선택하는 플래그는 가급적 피하는 것이 좋음 . | add와 plus: addDays가 date 객체를 변경한다고 생각하게 함, plus가 더 적절한 이름 . | 논리적 의존성: 서수 날짜 시작일의 요일에 암시적으로 의존, 0번째 날짜의 요일에 의존 . | 논리적 의존을 물리적 의존으로 드러내자 | . | . ",
    "url": "/chapter16-SerialDate-refactoring.html#%EB%91%98%EC%A7%B8-%EA%B3%A0%EC%B3%90%EB%B3%B4%EC%9E%90",
    
    "relUrl": "/chapter16-SerialDate-refactoring.html#둘째-고쳐보자"
  },"62": {
    "doc": "16장 SerialDate 리팩토링",
    "title": "결론",
    "content": " ",
    "url": "/chapter16-SerialDate-refactoring.html#%EA%B2%B0%EB%A1%A0",
    
    "relUrl": "/chapter16-SerialDate-refactoring.html#결론"
  },"63": {
    "doc": "17장 냄새와 휴리스틱",
    "title": "17장 냄새와 휴리스틱",
    "content": "아래 목록들은 다양한 프로그램을 리팩터링하는 과정에서, 수정할 때마다 “왜?”라고 자문하고 그 답을 기록한 결과이다. 즉 아래 목록들은 코드를 수정해야 하는 이유인 냄새(나쁜 냄새)를 풍기는 요소들이며, 지양해야 하는 요소들이다. ",
    "url": "/chapter17-smell-and-heuristic.html",
    
    "relUrl": "/chapter17-smell-and-heuristic.html"
  },"64": {
    "doc": "17장 냄새와 휴리스틱",
    "title": "주석",
    "content": "C1: 부적절한 정보 . | 다른 시스템(e.g. 소스 코드 관리 시스템, 이슈 추적 시스템 등)에 저장할 정보는 주석으로 적절치 못하다. | 주석은 코드와 설계에 기술적인 설명을 부연하는 수단이다. | . C2: 쓸모없는 주석 . | 오래된, 엉뚱한, 잘못된 주석은 쓸모없다. | 쓸모없는 주석은 아예 달지 않거나, 발견하는 즉시 삭제하는 편이 좋다. | . C3: 중복된 주석 . | 중복된 주석은 코드만으로 충분한데 구구절절 설명하는 주석이다. | 다음은 중복된 주석의 예이다. | i++; // i 증가 . 혹은, 함수 서명만 달랑 기술하는 Javadoc이다. | ```java /** . | @param sellRequest | @return | @throws ManagedComponentException */ public SellResponse beginSellItem(SellRequest sellRequest) throws ManagedComponentException ``` | . | . | 다시 한 번, 주석은 코드만으로 다하지 못하는 설명을 부연하는 역할이다. | . C4: 성의 없는 주석 . | 주석을 작성하려면, 공을 들여서 작성해야 한다. | 단어는 신중하게 선택하고, 당연한 소리를 반복하지 않는다. | 간결하고 명료하게 작성한다. | . C5: 주석 처리된 코드 . | 주석 처리된 코드는 흉물 그 자체다. 그러니 발견 즉시 지워버려라. | 소스 코드 관리 시스템이 기억한다. | 주석 처리된 코드는 얼마나 오래되었는지, 사용하는 코드인지 아무도 알 수가 없다. | . ",
    "url": "/chapter17-smell-and-heuristic.html#%EC%A3%BC%EC%84%9D",
    
    "relUrl": "/chapter17-smell-and-heuristic.html#주석"
  },"65": {
    "doc": "17장 냄새와 휴리스틱",
    "title": "환경",
    "content": "E1: 여러 단계로 빌드해야 한다 . | 빌드는 간단히 한 단계로 끝나야 한다. | 소스 코드 관리 시스템에서 이것저것 체크아웃할 필요가 없어야 한다. | 또한 불가해한 명령이나 스크립트를 잇달아 실행해 각 요소를 따로 빌드할 필요가 없어야 한다. | . E2: 여러 단계로 테스트해야 한다 . | 모든 단위 테스트는 한 명령으로 돌려야 한다. | IDE에서 버튼 하나로 모든 테스트를 돌린다면 가장 이상적이다. | . ",
    "url": "/chapter17-smell-and-heuristic.html#%ED%99%98%EA%B2%BD",
    
    "relUrl": "/chapter17-smell-and-heuristic.html#환경"
  },"66": {
    "doc": "17장 냄새와 휴리스틱",
    "title": "함수",
    "content": "F1: 너무 많은 인수 . | 함수에서 인수 개수는 작을수록 좋다. | 인수가 넷 이상이라면 의심하고 최대한 피한다. | . F2: 출력 인수 . | 일반적으로 인수는 입력으로 간주된다. 따라서 출력 인수는 직관적으로 이해하기 매우 어렵다. | 함수에서 뭔가의 상태를 변경해야 한다면, 함수가 속한 객체의 상태를 변경한다. | . F3: 플래그 인수 . | 플래그 인수는 그 함수가 둘 이상의 일을 수행한다는 명백한 증거이므로 피해야 한다. | . F4: 죽은 함수 . | 아무도 호출하지 않는 함수는 과감히 삭제하라. | . ",
    "url": "/chapter17-smell-and-heuristic.html#%ED%95%A8%EC%88%98",
    
    "relUrl": "/chapter17-smell-and-heuristic.html#함수"
  },"67": {
    "doc": "17장 냄새와 휴리스틱",
    "title": "일반",
    "content": "G1: 한 소스 파일에 여러 언어를 사용한다 . | 오늘날 프로그래밍 환경은 한 소스 파일 내에서 다양한 언어를 지원한다. | 가능한 소스 파일 하나에 언어 하나만 사용하는 방식이 가장 좋다. | 현실적으로 여러 언어가 불가피하지만 각별한 노력을 기울여 최대한 줄이도록 노력한다. | . G2: 당연한 동작을 구현하지 않는다 . | 최소 놀람의 원칙에 의거해 함수나 클래스는 다른 프로그래머가 당연하게 여길 만한 동작과 기능을 제공해야 한다. | 소프트웨어 설계에서 시스템이 사용자의 예상에 최대한 부합하도록 설계해야 한다는 원칙 . | . | 예를 들어, 요일 문자열에서 요일을 나타내는 enum으로 변환하는 함수를 살펴보자. | Day day = DayDate.StringToDay(String dayName); . | 우리는 함수가 ‘Monday’를 Day.MONDAY로 변환하리라 기대한다. 또한 일반적으로 쓰는 요일 약어도 올바로 변환하리라 기대한다. | . | 당연한 동작을 구현하지 않으면 독자는 더 이상 함수 이름만으로 기능을 직관적으로 예상하기 어려워진다. | . G3: 경계를 올바로 처리하지 않는다 . | 자신의 직관에 의존하지 말고, 부지런히 모든 경계 조건, 모든 예외를 살펴보자. | 모든 경계 조건을 찾아내고, 그것들을 테스트하는 테스트 케이스를 작성하라. | . G4: 안전 절차 무시 . | 예를 들어 컴파일러 경고 일부를 꺼버리면 빌드가 쉬워질지 모르지만, 자칫하면 끝없는 디버깅에 시달릴 수 있다. | 실패하는 테스트 케이스를 일단 제쳐두고 나중에 미루는 태도는 아주 위험하다. | . G5: 중복 . | 이 책에 나오는 가장 중요한 규칙 중 하나이므로 심각하게 숙고해야 한다. | 코드에서 중복을 발견할 때마다 추상화할 기회로 간주하라. 중복된 코드를 하위 루틴이나 다른 클래스로 분리하라. | ",
    "url": "/chapter17-smell-and-heuristic.html#%EC%9D%BC%EB%B0%98",
    
    "relUrl": "/chapter17-smell-and-heuristic.html#일반"
  },"68": {
    "doc": "17장 냄새와 휴리스틱",
    "title": "어디서든 중복을 발견하면 없애라.",
    "content": "| 유형 1: 똑같은 코드가 여러 차례 나온다. 이런 중복은 간단한 함수로 교체한다. | 유형 2: 여러 모듈에서 분기문으로 똑같은 조건을 거듭 확인하는 중복이다. 이런 중복은 다형성으로 대체해야 한다. | ",
    "url": "/chapter17-smell-and-heuristic.html#%EC%96%B4%EB%94%94%EC%84%9C%EB%93%A0-%EC%A4%91%EB%B3%B5%EC%9D%84-%EB%B0%9C%EA%B2%AC%ED%95%98%EB%A9%B4-%EC%97%86%EC%95%A0%EB%9D%BC",
    
    "relUrl": "/chapter17-smell-and-heuristic.html#어디서든-중복을-발견하면-없애라"
  },"69": {
    "doc": "17장 냄새와 휴리스틱",
    "title": "유형 3: 알고리즘이 유사하나 코드가 서로 다른 중복이다. 이는 TEMPLATE METHOD 패턴이나, STRATEGY 패턴으로 중복을 제거한다.",
    "content": "| . G6: 추상화 수준이 올바르지 못하다 . | 추상화로 개념을 분리할 때는 철저해야 한다. 모든 저차원 개념은 파생 클래스에 넣고, 모든 고차원 개념은 기초 클래스에 넣는다. | 기초 클래스는 구현 정보에 무지해야 한다. 예를 들어, 세부 구현과 관련한 상수, 변수, 유틸리티 함수 등은 기초 클래스에 넣으면 안 된다. | . public interface Stack { Object pop() throws EmptyException; /* ... */ double percentFull(); /* ... */ } . | percentFull()은 추상화 수준이 올바르지 못하다. 이유는 Stack을 구현하는 방법은 다양해, percent full(백분율)이라는 개념은 구현하는 방식에 따라 적합할 수도, 그렇지 않을 수도 있다. 따라서 해당 개념은 특정한 파생 인터페이스에 넣어야 마땅하다. | . G7: 기초 클래스가 파생 클래스에 의존한다 . | 일반적으로 기초 클래스는 파생 클래스를 아예 몰라야 마땅하다. 고차원 개념을 저차원 개념으로부터 분리하는 것이 기초/파생 클래스를 나누는 이유이기 때문이다. | 하지만 예외는 있다. 예를 들어 파생 클래스 개수가 확실히 고정되었다면 기초 클래스에 파생 클래스를 선택하는 코드가 들어간다. | 이러한 경우 기초 클래스와 파생 클래스를 각기 다른 파일로 배포하는 편이 좋다. | 각기 다른 파일로 배포될 경우, 시스템에서 각기 개별 컴포넌트 단위로 배치할 수 있기 때문이다. | . | . G8: 과도한 정보 . | 잘 정의된 모듈은 인터페이스가 아주 작다. 부실한 모듈은 구질구질하다. | 잘 정의된 인터페이스는 많은 함수를 제공하지 않아 결합도가 낮다. 부실한 인터페이스는 반드시 호출해야 하는 함수들을 제공한다. | 정보를 제한해 인터페이스를 매우 작게 만들어라. 결합도를 낮추어라. | 자료와 유틸리티 함수를 숨겨라. 상수와 임시 변수를 숨겨라. | . | . G9: 죽은 코드 . | 실행되지 않는 코드를 가리킨다. | 예를 들어, . | 불가능한 조건을 확인하는 if, switch/case 문 | throw 문이 없는 try 문에서 catch 블록 | . | 죽은 코드는 설계가 변하거나, 새로운 규칙이나 표기법이 생겨도 제대로 수정되지 않는다. | 발견 시 제거하라. | . G10: 수직 분리 . | 변수와 함수는 사용되는 위치에 가깝게 정의한다. 선언한 위치로부터 몇백 줄 아래에서 사용하면 안 된다. | 비공개 함수는 처음으로 호출한 직후에 정의한다. | . G11: 일관성 부족 . | 어떤 개념을 특정 방식으로 구현했다면 유사한 개념도 같은 방식으로 구현한다. | . G12: 잡동사니 . | 아무도 사용하지 않는 변수, 아무도 호출하지 않는 함수, 정보를 제공하지 못하는 주석. 모두 잡동사니이다. 제거해라. | . G13: 인위적 결합 . | 서로 무관한 개념을 인위적으로 결합하지 않는다. | 뚜렷한 목적 없이 변수, 상수, 함수를 당장 편한 위치에 넣어버린 결과이다. 올바른 위치를 고민하자. | . G14: 기능 욕심 . | 클래스 메서드는 자기 클래스의 변수와 함수에 관심을 가져야지 다른 클래스의 변수와 함수에 관심을 가져서는 안 된다. | 메서드가 다른 객체의 내용을 조작하는 것은, 그 객체 클래스의 범위를 욕심내는 것이다. | 기능 욕심은 한 클래스의 속사정을 다른 클래스에 노출하므로, 별다른 문제가 없다면 제거하는 편이 좋다. | 다음은 기능 욕심에 관한 예제이다. | . public class HourlyPayCalculator { public Money calculateWeeklyPay(HourlyEmployee e) { int tenthRate = e.getTenthRate().getPennies(); int tenthsWorked = e.getTenthsWorked(); int straightTime = Math.min(400, tenthsWorked); int overTime = Math.max(0, tenthsWorked - straightTime); int straightPay = straightTime * tenthRate; int overtimePay = (int) Math.round(overTime * tenthRate * 1.5); return new Money(straightPay + overtimePay); } } . calculateWeeklyPay 메서드는 HourlyEmployee 객체에서 온갖 정보를 가져온다. 즉, calculateWeeklyPay 메서드는 HourlyEmployee 클래스의 범위를 욕심 낸다. G15: 선택자 인수 . | 선택자 인수는 큰 함수를 작은 함수 여럿으로 쪼개지 않으려는 게으름의 소산이다. 다음 코드를 살펴보자. | . public int calculateWeeklyPay(boolean overtime) { int tenthRate = getTenthRate(); int tenthsWorked = getTenthsWorked(); int straightTime = Math.min(400, tenthsWorked); int overTime = Math.max(0, tenthsWorked - straightTime); int straightPay = straightTime * tenthRate; double overtimeRate = overtime ? 1.5 : 1.0 * tenthRate; int overtimePay = (int) Math.round(overTime * overtimeRate); return straightPay + overtimePay; } . | 독자는 calculateWeeklyPay(false)라는 코드를 발견할 때마다 인수의 의미를 떠올리느라 골치를 앓는다. | enum, int 등 함수 동작을 제어하려는 인수 또한 바람직 하지 않다. | 인수를 넘겨 동작을 선택하는 대신, 새로운 함수를 만드는 편이 좋다. | . G16: 모호한 의도 . | 코드를 짤 때는 의도르르 최대한 분명히 밝힌다. | 행을 바꾸지 않는 수식, 헝가리식 표기법, 매직 번호 등은 모두 저자의 의도를 흐린다. | . G17: 잘못 지운 책임 . | 코드를 배치하는 기준은 독자가 자연스럽게 기대할 만한 곳이다. 이는 역시 최소 놀람의 원칙을 적용한다. | . G18: 부적절한 static 함수 . | Math.max() 는 좋은 static 메서드다. 메서드를 소유하는 객체에서 가져오는 정보가 아니며, 해당 메서드를 재정의할 가능성이 없기 때문이다. | 하지만 다음 예를 살펴보자. HourlyPayCalculator.calculatePay(employee, overtimeRate); . 언뜻보면 적절해보이지만, 함수를 재정의할 가능성이 존재한다. 혹은 수당을 계산하는 알고리즘이 여러 개일 수도 있다. | 일반적으로 static 함수보다 인스턴스 함수가 더 좋다. static 함수를 정의해야 할 때는 재정의할 가능성이 없는지 살펴보자. | . 다음 목록부터는 휴리스틱을 중점적으로 다룬다. 휴리스틱은 복잡하거나 불확실한 문제 상황에서, 제한된 시간이나 정보로 인해 합리적이고 체계적인 판단이 어렵거나 굳이 필요하지 않을 때 사용하는 간편하고 실용적인 문제 해결 방법 또는 추론 전략 이다. G19: 서술적 변수 . | 프로그램 가독성을 높이는 가장 효과적인 방법 중 하나가 계산을 여러 단계로 나누고 중간 값으로 서술적인 변수 이름을 사용하는 방법이다. Matcher match = headerPattern.matcher(line); if(match.find()) { String key = match.group(1); String value = match.group(2); headers.put(key.toLowerCase(), value); } . | 서술적인 이름을 사용한 탓에 key 와 value 로 원하는 정보가 명확하게 드러난다. | . G20: 이름과 기능이 일치하는 함수 . | 이름만으로 분명하지 않은 함수는 구현을 살펴보거나 문서를 뒤적여야 한다. | 기능을 정확하게 표현하는 이름을 짓는다. | . G21: 알고리즘을 이해하라 . | 구현이 끝났다고 선언하기 전에 함수가 돌아가는 방식을 확실히 이해하는 지 확인하라. 이것은 테스트 케이스를 모두 통과하는 것과는 별개의 이야기이다. G22: 논리적 의존성은 물리적으로 드러내라 . | 의존하는 모듈이 상대 모듈에 대해 뭔가를 가정하면 안된다. 의존하는 모든 정보를 명시적으로 요청하는 편이 좋다. | 예를 들어, 근무시간 보고서를 가공되지 않은 상태로 출력하는 함수를 구현한다고 가정하자. HourlyReporter라는 클래스는 모든 정보를 모아 HourlyReportFormatter에 적당한 형태를 넘긴다. HourlyReportFormatter는 넘어온 정보를 출력한다. | . public class HourlyReporter { private HourlyReportFormatter formatter; private List&lt;LineItem&gt; page; private final int PAGE_SIZE = 55; public HourlyReporter(HourlyReportFormatter formatter) { this.formatter = formatter; page = new ArrayList&lt;LineItem&gt;(); } public void generateReport(List&lt;HourlyEmployee&gt; employees) { for (HourlyEmployee e : employees) { addLineItemToPage(e); if (page.size() == PAGE_SIZE) printAndClearItemList(); } if (page.size() &gt; 0) printAndClearItemList(); } private void printAndClearItemList() { formatter.format(page); page.clear(); } private void addLineItemToPage(HourlyEmployee e) { LineItem item = new LineItem(); item.name = e.getName(); item.hours = e.getTenthsWorked() / 10; item.tenths = e.getTenthsWorked() % 10; page.add(item); } public class LineItem { public String name; public int hours; public int tenths; } } . 위에서 논리적인 의존성은 PAGE_SIZE 이다. HourlyReporter가 페이지의 크기를 알 필요는 없다. 페이지 크기는 HourlyReportFormatter가 책임질 정보다. 이는 잘못 지운 책임에 해당된다. HourlyReportFormatter 에 getMaxPageSize() 라는 메서드를 추가하면 논리적인 의존성이 물리적인 의존성으로 변한다. G23: If/Else 혹은 Switch/Case 문보다 다형성을 사용하라 . | 대부분 switch/case 문을 선택하는 이유는 당장 가장 손쉬운 선택이기 때문 이다. 그러므로 먼저 다형성을 고려해보자. | 선택 유형 하나에는 switch 문을 한번만 사용한다. | 같은 선택을 수행하는 다른 코드에서는 다형성 객체를 생성해 switch 문을 대신한다. | . G24: 표준 표기법을 따르라 . | 팀은 업계 표준에 기반한 구현 표준을 따라야 한다. | 팀이 정한 표준은 팀원들 모두가 따라야 한다. | . G25: 매직 숫자는 명명된 상수로 교체하라 . | 이미 오래된 규칙이다. 코드에서 숫자를 사용하지 말라는 규칙이다. | 매직 숫자는 단순히 숫자만 의미하지 않는다. 의미가 분명하지 않은 토큰을 모두 가리킨다. assertEquals(7777, Employee.find(\"John Doe\").employeeNumber()); . 위 코드에서 매직 숫자는 “7777”, “John Doe” 이다. 둘 다 의미가 분명하지 않기 때문이다. 다음과 같이 수정해보자. assertEqulas(HOURLY_EMPLOYEE_ID, Employee.find(HOURLY_EMPLOYEE_NAME).employeeNumber()); . | . G26: 정확하라 . | 코드에서 뭔가를 결정할 때는 정확히 결정한다. 결정을 내리는 이유와 예외를 처리할 방법을 분명히 알아야 한다. | 예를 들어, . | 호출하는 함수가 null 을 반환할지 모른다면 null 을 반드시 점검한다. | 조회 결과가 하나뿐이라고 짐작한다면 하나인지 확실히 확인한다. | 동시에 갱신할 가능성이 있다면 적절한 잠금 매커니즘을 구현한다. | . | . G27: 관례보다 구조를 사용하라 . | 설계 결정을 강제할 때는 규칙보다 관례를 사용한다. | 예를 들어, enum 변수가 멋진 switch/case 문보다 추상 메서드가 있는 기초 클래스 가 더 좋다. | switch/case 문을 매번 똑같이 구현하게 강제하기는 어렵지만, 파생 클래스는 추상 메서드를 모두 구현하지 않으면 안 되기 때문이다. | . _G28: 조건을 캡슐화하라 . | 부울 논리는 이해하기 어렵다. 조건의 의도를 분명히 밝히는 함수로 표현하라. | 예를 들어, . | if (shouldBeDeleted(timer)) . 라는 코드는 다음 코드보다 좋다. | if (timer.hasExpired() &amp;&amp; !timer.isRecurrent()) . | . | . G29: 부정 조건은 피하라 . | 부정 조건은 긍정 조건보다 이해하기 어렵다. 가능하면 긍정 조건으로 표현한다. | 예를 들어, . | if (buffer.shouldCompact()) . 라는 코드가 아래 코드보다 좋다. | if (!buffer.shouldNotCompact()) . | . | . G30: 함수는 한 가지만 해야 한다 . | 함수를 짜다 보면, 한 함수안에서 일련의 작업을 수행하고픈 유혹에 빠진다. 하지만 이는 각각의 작업을 담당하는 여럿의 함수로 나누어야한다. G31: 숨겨진 시간적인 결합 . | 때로는 시간적인 결합이 필요하다. 함수를 짤 때는 함수 인수를 적절히 배치해 함수가 호출되는 순서를 명백히 드러낸다. 다음 코드를 살펴보자. | . public class MoogDiver { Gradient gradient; List&lt;Spline&gt; splines; public void dive(String reason) { saturatedGradient(); reticulateSplines(); diverForMoog(reason); } ... } . 위 코드에서는 세 함수가 실행되는 순서가 중요하다. 먼저 gradient를 처리하기 위해 saturatedGradient()를 호출하고 나서, reticulateSplines()를, 마지막으로 diverForMoog()를 수행한다. 하지만 위의 코드는 시간적인 결합을 강제하지 않는다. 따라서, 도중에 오류가 발생해도 막을 도리가 없다. 다음 코드가 더 좋다. public class MoogDiver { Gradient gradient; List&lt;Spline&gt; splines; public void dive(String reason) { Gradient gradient = saturateGradient(); List&lt;Spline&gt; splines. = reticulateSplines(gradient); diveForMoog(Splines, reason); } } . 위 코드는 함수의 인자를 일종의 연결 소자로써 사용하여 시간적인 결합을 노출한다. G32: 일관성을 유지하라 . | 코드 구조를 잡을 때는 이유를 고민하라. 그리고 그 이유를 코드 구조로 명백히 표현하라. | 시스템 전반에 걸친 구조가 일관성이 있다면, 남도 일관성을 따르고 보존한다. | . G33: 경계 조건을 캡슐화하라 . | 경계 조건은 별도로 한곳에서 처리한다. if(level + 1 &lt; tags.length&gt;) { parts = new Parse(body, tags, level + 1, offset + endTag); body = null; } . | . 위의 코드에서 level + 1 은 여기 저기에 나온다. 이러한 경계 조건은 캡슐화하는 편이 좋다. int nextLevel = level + 1; if(nextLevel &lt; tags.length) { parts = new Parse(body, tags, nextLevel, offset + endTag); body = null; } . G34: 함수는 추상화 수준을 한 단계만 내려가야 한다 . | 함수 내 모든 문장은 추상화 수준이 동일해야 한다. 그리고 그 수준은 함수 이름이 의미하는 작업보다 한 단계 더 낮아야 한다.(작업이 더 구체적이어야 한다.) | 함수에서 추상화 수준을 분리하면 드러나지 않았던 새로운 추상화 수준이 드러나는 경우가 빈번하다. | . public String render() throws Exception { StringBuffer html = new StringBuffer(\"&lt;hr\"); if (size &gt; 0) { html.append(\" size=\\\"\").append(size + 1).append(\"\\\"\"); } html.append(\"&gt;\"); return html.toString(); } . 위 함수에는 추상화 수준이 최소한 두 개가 섞여 있다. 첫째는 수평선에 크기가 있다는 개념이다. 둘째는 HR 태그 자체의 문법이다. 위 코드를 다음과 같이 수정해보자. size 변수 이름은 목적을 반영하게 적절히 변경했다. size 변수는 추가된 대시 개수를 저장한다. render함수는 HR 태그만 생성하며, 구체적인 문법은 전혀 상관하지 않는다. 추상화 수준을 분리되었다. public String render() throws Exception { HtmlTag hr = new HtmlTag(\"hr\"); if (extraDashes &gt; 0) { hr.addAttribute(\"size\", hrSize(extraDashes)); } return hr.html(); } private String hrSize(int height) { int hrSize = height + 1; return String.format(\"%d\", hrSize); } . G35: 설정 정보는 최상위 단계에 둬라 . | 추상화 최상위 단계에 둬야 할 기본값 상수나 설정 관련 상수를 저차원 함수에 숨겨서는 안 된다. | 대신 고차원 함수에서 저차원 함수를 호출할 때 인수로 넘긴다. | . | 설정 정보를 최상위 단계에 둬야 찾기도, 변경하기도 쉽다. ```java public static void main(String [] args) throws Exception { Arguments arguments = parseCommandLine(args); … } | . public class Arguments { // 설정 정보 public static final String DEFAULT_APTH = “.”; public static final String default_root = “FitNesseRoot”; … } . ### _G36: 추이적 탐색을 피하라_ - 일반적으로 한 모듈은 주변 모듈을 모를수록 좋다. - A가 B를 사용하고, B가 C를 사용한다 해서, A가 C를 알아야 할 필요는 없다는 뜻이다. - 이를 디미터 법칙이라고 부른다. - 여러 모듈에서 `a.getB().getC()` 라는 형태를 사용한다면 설계와 아키텍처를 바꿔 B와 C사이에 Q를 넣기 쉽지않다. - 원하는 기능을 찾아 객체를 따라 시스템 전체를 탐색할 필요가 없어야 한다. ## 자바 ### _J1: 긴 import 목록을 피하고 와일드 카드를 사용하라_ - 패키지에서 클래스를 둘 이상 사용한다면 와일드카드를 사용해 패키지 전체를 가져오라. - 명시적으로 사용하는 import 문은 강한 의존성을 생성하지만, 와일드카드는 그렇지 않다. ```java import package.*; . | 와일드카드가 이름 충돌이나 모호성을 초래할 경우에는 명시적으로 import 문을 사용한다. 아니면 코드에서 클래스를 사용할 때 전체 경로를 명시한다. | . J2: 상수는 상속하지 않는다 . | 상수를 상속하는 것은 언어의 범위 규칙을 속이는 행위다. | 대신 static import 를 사용하라. | . J3: 상수 대 Enum . | enum은 이름이 부여된 열거체에 속한다. | 메서드와 필드도 사용할 수 있다. int 보다 훨씬 더 유연하고 서술적인 강력한 도구다. 맘껏 사용하라. | . ",
    "url": "/chapter17-smell-and-heuristic.html#%EC%9C%A0%ED%98%95-3-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98%EC%9D%B4-%EC%9C%A0%EC%82%AC%ED%95%98%EB%82%98-%EC%BD%94%EB%93%9C%EA%B0%80-%EC%84%9C%EB%A1%9C-%EB%8B%A4%EB%A5%B8-%EC%A4%91%EB%B3%B5%EC%9D%B4%EB%8B%A4-%EC%9D%B4%EB%8A%94-template-method-%ED%8C%A8%ED%84%B4%EC%9D%B4%EB%82%98-strategy-%ED%8C%A8%ED%84%B4%EC%9C%BC%EB%A1%9C-%EC%A4%91%EB%B3%B5%EC%9D%84-%EC%A0%9C%EA%B1%B0%ED%95%9C%EB%8B%A4",
    
    "relUrl": "/chapter17-smell-and-heuristic.html#유형-3-알고리즘이-유사하나-코드가-서로-다른-중복이다-이는-template-method-패턴이나-strategy-패턴으로-중복을-제거한다"
  },"70": {
    "doc": "17장 냄새와 휴리스틱",
    "title": "이름",
    "content": "N1: 서술적인 이름을 사용하라 . | 소프트웨어 가독성의 90%는 이름이 결정한다. 그러니 이름을 정할 때는 시간을 들여 현명하게 선택한다. | 신중하게 선택한 이름은 추가 설명이 필요하지 않다. private boolean isStrike(int frame) { return rolls[frame] == 10; } . N2: 적절한 추상화 수준에서 이름을 선택하라 . | 구현을 드러내는 이름은 피하라. | 작업 대상 클래스나 함수가 위치하는 추상화 수준을 반영하는 이름을 선택하라. | . public interface Modem { boolean dial(String phoneNumber); boolean disconnect(); boolean send(char c); char recv(); String getConnectedPhoneNumber(); } . Modem 관련 인터페이스이다. 얼핏 문제 없어 보이지만 전화선에 일부 연결되지 않는 모뎀을 생각해보자. 그렇다면 전화번호라는 개념은 추상화 수준이 틀렸다. 다음과 같이 수정하면, 연결 대상은 전화로 제한되지 않는다. public interface Modem { boolean connect(String connectionLocator); boolean disconnect(); boolean send(char c); char recv(); String getConnectedPhoneNumber(); } . N3: 가능하다면 표준 명명법을 사용하라 . | 예를 들어, DECORATOR 패턴을 활용하는 클래스 이름에는 Decorator라는 단어를 사용해야 한다. | 패턴은 한 가지 표준에 불과하다. 이러한 경우 이름은 관례에 따르는 편이 좋다. | 프로젝트에 유효한 의미가 담긴 이름을 많이 사용할수록 독자가 코드를 이해하기 쉬워진다. | . N4: 명확한 이름 . | 함수나 변수의 목적을 명확히 밝히는 이름을 선택한다. | 길어도 좋으며, 길다는 단점은 서술성이 충분히 메꿀수 있다. N5: 긴 범위는 긴 이름을 사용하라 . | 이름 길이는 범위 길이에 비례해야 한다. 범위가 작으면 아주 짧은 이름을 사용해도 괜찮다. 하지만 범위가 길어지면 긴 이름을 사용한다. | 이름범위가 길어질 수록 이름을 정확하고 길게 짓는다. | 범위가 5줄 안팎이라면 i나 j와 같은 변수 이름도 괜찮다. | . private void rollMany(int n, int pins) { for (int i=0; i&lt;n; i++) g.roll(pins); } . 만일 i 대신 rollCount라고 썼다면 더 헷갈렸을 것이다. N6: 인코딩을 피하라 . | 이름에 유형 정보나 범위 정보를 넣어서는 안된다. | 예를 들어 오늘날 개발 환경에서, m_ 이나 f 와 같은 접두어는 불필요하다. N7: 이름으로 부수 효과를 설명하라 . | 이름에 부수 효과를 숨기지 않는다. | . public ObjectOutprStream getOos() throws IOException { if (m_oos == null) { m_oos = new ObjectOutprStream(m_socket.getOutputStream()); } return m_oos; } . 위 함수는 단순히 “oos”만 가져오지 않고, 없으면 생성하기도 한다. 그러므로 createOrReturnOos 라는 이름이 더 적합하다. ",
    "url": "/chapter17-smell-and-heuristic.html#%EC%9D%B4%EB%A6%84",
    
    "relUrl": "/chapter17-smell-and-heuristic.html#이름"
  },"71": {
    "doc": "17장 냄새와 휴리스틱",
    "title": "테스트",
    "content": "T1: 불충분한 테스트 . | 테스트 케이스는 잠재적으로 깨질 만한 부분을 모두 테스트 해야한다. | 테스트 케이스가 확인하지 않는 조건이나 검증하지 않는 계산이 있다면 그 테스트는 불완전하다. | . T2: 커버리지 도구를 사용하라! . | 커버리지 도구는 테스트가 빠뜨리는 공백을 알려준다. | 커버리지 도구를 사용하면 테스트가 불충분한 모듈, 클래스, 함수를 찾기가 쉬워진다. | . T3: 사소한 테스트를 건너 뛰지 마라 . | 사소한 테스트는 짜기 쉽다. | 사소한 테스트가 제공하는 문서적 가치는 구현에 드는 비용을 넘어선다. | . T4: 무시한 테스트는 모호함을 뜻한다 . | 때로는 요구사항이 불분명해 프로그램이 돌아가는 방식을 확신하기 어렵다. | 이러한 경우 테스트 케이스를 주석 처리하거나, @Ignore를 붙여 표현한다. | . | . T5: 경계 조건을 테스트하라 . | 경계 조건은 각별히 신경 써서 테스트 한다. | . T6: 버그 주변은 철저히 테스트하라 . | 버그는 서로 모이는 경향이 있다. | 한 함수 에서 버그를 발견했다면 그 함수를 철저히 테스트하는 편이 좋다. | . T7: 실제 패턴을 살펴라 . | 때로는 테스트 케이스가 실패하는 패턴으로 문제를 진단할 수 있다. | 합리적인 순서로 정렬된 꼼꼼한 테스트 케이스들은 실패 패턴을 드러낸다. | . T8: 테스트 커버리지 패턴을 살펴라 . | 통과하는 테스트나 실행하거나 실행하지 않는 코드를 살펴보면 실패하는 테스트 케이스의 실패 원인이 드러난다. | . T9: 테스트는 빨라야 한다 . | 느린 테스트 케이스는 실행하지 않게 된다. 그러므로 테스트 케이스는 최대한 빨리 돌아가게 노력한다. | . ",
    "url": "/chapter17-smell-and-heuristic.html#%ED%85%8C%EC%8A%A4%ED%8A%B8",
    
    "relUrl": "/chapter17-smell-and-heuristic.html#테스트"
  },"72": {
    "doc": "17장 냄새와 휴리스틱",
    "title": "결론",
    "content": "이 장에서 소개한 휴리스틱과 냄새 목록이 완전하다 말하기는 어렵다. 하지만 완전한 목록이 목표가 아닌, 가치 체계를 피력한다. 사실상 가치 체계는 이 책의 주제이자 목표다. 일군의 규칙만 따른다고 깨끗한 코드가 얻어지지 않는다. 휴리스틱 목록을 익힌다고 소프트웨어 장인이 되지는 못한다. 장인 정신은 가치에서 나온다. 그 가치에 기반한 규율과 절제가 필요하다. ",
    "url": "/chapter17-smell-and-heuristic.html#%EA%B2%B0%EB%A1%A0",
    
    "relUrl": "/chapter17-smell-and-heuristic.html#결론"
  },"73": {
    "doc": "2장 의미 있는 이름",
    "title": "2장 의미 있는 이름",
    "content": "❝코드는 남을 위해서 읽기 좋게 쓰는 것❞ . ❝이름은 짧을수록 좋지만, 짧은 대신 의미가 선명해야 한다. 길어도 되는 이유는, 코드보다 주석보다 이름이 더 중요하기 때문이다.❞ . ",
    "url": "/chapter2-meaningful-names.html",
    
    "relUrl": "/chapter2-meaningful-names.html"
  },"74": {
    "doc": "2장 의미 있는 이름",
    "title": "좋은 이름을 위한 원칙",
    "content": "원칙 1: 읽는 사람이 쉽게 이해할 수 있어야 한다 . 👉 “이름만 보고 용도를 유추할 수 있어야 한다.” . | 의도를 분명히 밝혀라 . | 나쁜 예 | 좋은 예 | — | — | int d; | int daysSinceCreation; | . | 변수명, 함수명, 클래스가 무엇을 하는지 정확하게 드러나야 한다. | 존재 이유 | 수행 기능 | 사용 방법 | . | . | 의미 있게 구분하라 . | 나쁜 예 | 좋은 예 | — | — | state | addressState, userState | . | 의미가 모호한 단어는 맥락에 따라 명확히 구분해야 한다. | 이름이 달라야 한다면 의미도 달라야 한다. | 불용어를 사용한 이름은 아무런 정보도 제공하지 못한다. | ex) a1, a2, a3 … an | . | 읽는 사람이 알 수 있도록 구분되는 의미가 담겨야 한다. | accountData vs account | . | . | . | 검색 가능한 이름을 써라 . | 나쁜 예 | 좋은 예 | — | — | int e; | int employeeCount; | 5 | MAX_CLASSES | . | 이름이 짧거나 모호한 변수, 상수는 코드 검색이 매우 어렵다. | . | . 원칙 2: 그릇된 정보를 피하라 . // Set인데 이름은 List라 혼란을 유발 Set&lt;Account&gt; accountList = new HashSet&lt;&gt;(); . | 이름이 데이터의 구조나 역할과 다르면 오해를 일으킨다. | List라는 이름을 붙였는데 실제 자료형이 Set이라면 읽는 사람은 중복이 허용된다고 착각할 수 있다. | . | . | 나쁜 예 | 좋은 예 | | — | — | — | userInfo, userData | userRequest, userResponse | 서로 다른 역할인데 이름만 보면 유사하게 느껴짐 | dataManager, dataController | cacheManager, httpController | 실제 책임이 다르다면 이름도 구분 지어야 함 | processHandler, processManager | taskScheduler, taskRunner | 추상적인 이름은 구체적인 역할로 바꾸자 | . | 비슷하지만 다른 역할을 하는 이름에는 서로 확실히 다른 이름을 붙여야 한다. | . | 나쁜 예 | 좋은 예 | | — | — | — | getUser(), fetchMember() | getUser(), getMember() | 동작은 동일한데 표현만 다르면 통일성 떨어짐 | saveUser(), storeMember() | saveUser(), saveMember() | 동사는 하나로 통일해주는 게 좋음 | calculateSum(), computeAverage() | calculateSum(), calculateAverage() | 같은 역할이면 접두사도 일치하는게 좋음 | . | 반대로, 역할이나 용도가 비슷하다면 이름도 일관성 있게 유지해야 혼란을 줄일 수 있다. | . ❗이름에 잘못된 정보나 혼동을 줄 수 있는 표현은 피한다. | 헷갈리기 쉬운 철자는 피하는 것이 좋다. | l(소문자 L)과 1(숫자 1) | O(대문자 알파벳 O)와 0(숫자 0) | . | 잘못된 암시를 주는 단어도 혼동을 야기한다. | accountList → 실제는 Set&lt;Account&gt; | isAvailable → 실은 항상 false인 플래그 | . | 복수형/단수형 이름의 오용도 주의 . | users가 User 하나만 담고 있는 경우 혼동을 준다. | . | . 원칙 3: 발음하기 쉬운 이름을 써라 . | 나쁜 예 | 좋은 예 | — | — | genymdhms | generationTimestamp | . | 말로 설명하기 어려운 이름은 피한다. | 뉴비도 이해하기 쉽도록 만든다. | . 원칙 4: 인코딩을 피하라(불필요한 접두어를 제거) . | 나쁜 예 | 좋은 예 | — | — | class CProductInfo | class Product | strName, iCount | name, count | . | 클래스명, 변수명에 헝가리안 표기법(C, M, S 등) 같은 접두어를 붙이면 오히려 가독성을 해친다. | . 원칙 5: 명사/동사 구분을 명확히 하라 . | 구분 | 예시 | — | — | 클래스 (명사) | User, Invoice, Product | 함수 (동사) | calculateTotal(), saveUser() | . | 역할에 맞게 자연스러운 문장처럼 읽히게 구성한다. | 클래스/변수는 명사, 함수는 동사로 이름을 짓는다. | . | 역할에 따라 이름 패턴을 정하면 자연스러운 코드 흐름을 만든다. | 생성자를 중복정의할 때는 정적 팩토리 메서드를 사용한다. | . 원칙 6: 한 개념에 한 단어를 사용하라 . | 나쁜 예 | 좋은 예 | | — | — | — | fetchData(), retrieveUser() | getData(), getUser() | 같은 역할이면 동사를 통일해 혼란을 줄인다 | . | 같은 동작에는 같은 표현을 반복해서 사용한다. | 예측 가능한 코드가 되고, 학습 비용이 줄어든다. | 주석을 보지 않아도 프로그래머가 올바른 메서드를 선택할 수 있다. | . | . ",
    "url": "/chapter2-meaningful-names.html#%EC%A2%8B%EC%9D%80-%EC%9D%B4%EB%A6%84%EC%9D%84-%EC%9C%84%ED%95%9C-%EC%9B%90%EC%B9%99",
    
    "relUrl": "/chapter2-meaningful-names.html#좋은-이름을-위한-원칙"
  },"75": {
    "doc": "3장 함수",
    "title": "3장 함수",
    "content": "프로그래밍 초창기에는 시스템을 루틴과 하위 루틴으로 나눴다. 포트란과 PL/1 시절에는 시스템을 프로그램, 하위 프로그램, 함수로 나눴다. 지금은 함수만 살아남아, 어떤 프로그램이든 가장 기본적인 단위가 함수이게 되었다. 이 장은 함수를 만드는 법을 소개한다. 다음의 코드는 FitNesse 라고하는 오픈 소스 테스트 도구를 구성하는 함수이다. 다음 함수를 2번의 리팩터링을 거친 함수들을 보며, 함수를 깨끗하고 잘 만드는 법에 대해 배워보겠다. FitNesse 에 익숙하지 않아 코드를 100% 이해하기 어려운 것을 감안하더라도, 다음 함수는 무슨 역할을 하는 지 알기 어렵다. 이유는 다음과 같다. | 추상화 수준이 다양하다. | 코드가 길다. | if 문이 중첩되어 가독성이 좋지않다. | 각 변수(플래그, 문자열, 함수)의 의미가 불명확하다. | 하나의 함수에서 하는 일이 많다. | . ",
    "url": "/chapter3-function.html",
    
    "relUrl": "/chapter3-function.html"
  },"76": {
    "doc": "3장 함수",
    "title": "더러운 함수 (목록 3-1 함수)",
    "content": "// 목록 3-1 HtmlUtil.java public static String testableHtml(PageData pageData, boolean includeSuiteSetup) throws Exception { WikiPage wikiPage = pageData.getWikiPage(); StringBuffer buffer = new StringBuffer(); if (pageData.hasAttribute(\"Test\")) { if (includeSuiteSetup) { WikiPage suiteSetup = PageCrawlerImpl.getInheritedPage( SuiteResponder.SUITE_SETUP_NAME, wikiPage ); if (suiteSetup != null) { WikiPagePath pagePath = suiteSetup.getPageCrawler().getFullPath(suiteSetup); String pagePathName = PathParser.render(pagePath); buffer.append(\"!include -setup.\") .append(pagePathName) .append(\"\\n\"); } } WikiPage setup = PageCrawlerImpl.getInheritedPage(\"SetUp\", wikiPage); if (setup != null) { WikiPagePath setupPath = wikiPage.getPageCrawler().getFullPath(setup); String setupPathName = PathParser.render(setupPath); buffer.append(\"!include -setup.\") .append(setupPathName) .append(\"\\n\"); } } buffer.append(pageData.getContent()); if (pageData.hasAttribute(\"Test\")) { WikiPage teardown = PageCrawlerImpl.getInheritedPage(\"TearDown\", wikiPage); if (teardown != null) { WikiPagePath tearDownPath = wikiPage.getPageCrawler().getFullPath(teardown); String tearDownPathName = PathParser.render(tearDownPath); buffer.append(\"\\n\") .append(\"!include -teardown.\") .append(tearDownPathName) .append(\"\\n\"); } if (includeSuiteSetup) { WikiPage suiteTeardown = PageCrawlerImpl.getInheritedPage( SuiteResponder.SUITE_TEARDOWN_NAME, wikiPage ); if (suiteTeardown != null) { WikiPagePath pagePath = suiteTeardown.getPageCrawler().getFullPath(suiteTeardown); String pagePathName = PathParser.render(pagePath); buffer.append(\"!include -teardown.\") .append(pagePathName) .append(\"\\n\"); } } } pageData.setContent(buffer.toString()); return pageData.getHtml(); } . ",
    "url": "/chapter3-function.html#%EB%8D%94%EB%9F%AC%EC%9A%B4-%ED%95%A8%EC%88%98-%EB%AA%A9%EB%A1%9D-3-1-%ED%95%A8%EC%88%98",
    
    "relUrl": "/chapter3-function.html#더러운-함수-목록-3-1-함수"
  },"77": {
    "doc": "3장 함수",
    "title": "refactoring 버전 (목록 3-2 함수)",
    "content": "// 목록 3-2 HtmlUtil.java (리팩터링한 버전) public static String renderPageWithSetupsAndTeardowns( PageData pageData, boolean isSuite ) throws Exception { boolean isTestPage = pageData.hasAttribute(\"Test\"); if (isTestPage) { WikiPage testPage = pageData.getWikiPage(); StringBuffer newPageContent = new StringBuffer(); includeSetupPages(testPage, newPageContent, isSuite); newPageContent.append(pageData.getContent()); includeTeardownPages(testPage, newPageContent, isSuite); pageData.setContent(newPageContent.toString()); } return pageData.getHtml(); } . ",
    "url": "/chapter3-function.html#refactoring-%EB%B2%84%EC%A0%84-%EB%AA%A9%EB%A1%9D-3-2-%ED%95%A8%EC%88%98",
    
    "relUrl": "/chapter3-function.html#refactoring-버전-목록-3-2-함수"
  },"78": {
    "doc": "3장 함수",
    "title": "re-refactoring 버전 (목록 3-3 함수)",
    "content": "// 목록 3-3 HtmlUtil.java (리-리팩터링한 버전) public static String renderPageWithSetupsAndTeardowns( PageData pageData, boolean isSuite) throws Exception { if (isTestPage(pageData)) includeSetupAndTeardownPages (pageData, isSuite); return pageData.getHtml(); } . ",
    "url": "/chapter3-function.html#re-refactoring-%EB%B2%84%EC%A0%84-%EB%AA%A9%EB%A1%9D-3-3-%ED%95%A8%EC%88%98",
    
    "relUrl": "/chapter3-function.html#re-refactoring-버전-목록-3-3-함수"
  },"79": {
    "doc": "3장 함수",
    "title": "작게 만들어라!",
    "content": "함수를 만드는 규칙은 다음과 같다. | ‘작게!’ 만든다. | ‘더 작게!’ 만든다. | . 그렇다면 얼마나 짧아야 좋을까? 목록 3-1의 코드는 총 70줄이었다. 목록 3-2로 리팩터링하며 많이 줄였지만 일반적으로 이보다도 짧아야한다. 목록 3-3 정도 줄여야 마땅하다. ",
    "url": "/chapter3-function.html#%EC%9E%91%EA%B2%8C-%EB%A7%8C%EB%93%A4%EC%96%B4%EB%9D%BC",
    
    "relUrl": "/chapter3-function.html#작게-만들어라"
  },"80": {
    "doc": "3장 함수",
    "title": "블록과 들여쓰기",
    "content": "목록 3-1은 if 문/else 문이 3단으로 중첩되어있다. 코드를 이해하기 어렵게하는 요소이다. if (pageData.hasAttribute(\"Test\")) { if (includeSuiteSetup) { WikiPage suiteSetup = PageCrawlerImpl.getInheritedPage( SuiteResponder.SUITE_SETUP_NAME, wikiPage ); if (suiteSetup != null) { /* ... */ . 중첩 구조가 생길만큼 함수가 커져서는 안된다. 함수에서 들여쓰기 수준은 1단이나 2단을 넘어서면 안된다. 다시 말해, if 문/else 문/while 문 등에 들어가는 블록은 한 줄이어야 한다는 의미다. 대게 거기서 함수를 호출한다. 그러면 바깥을 감싸는 함수(enclosing function)가 작아질 뿐 아니라, 블록 안에서 호출하는 함수 이름을 적절히 짓는다면, 코드를 이해하기도 쉬워진다. ",
    "url": "/chapter3-function.html#%EB%B8%94%EB%A1%9D%EA%B3%BC-%EB%93%A4%EC%97%AC%EC%93%B0%EA%B8%B0",
    
    "relUrl": "/chapter3-function.html#블록과-들여쓰기"
  },"81": {
    "doc": "3장 함수",
    "title": "한 가지만 해라!",
    "content": "목록 3-1은 여러 가지를 처리한다. 이는 함수가 정확히 어떤 역할을 하는지 의미를 불명확하게 한다. | 버퍼를 생성 | 페이지 가져오기 | 상속된 페이지를 검색 | 경로를 렌더링 | HTML 생성 | . 반면 목록 3-3은 한 가지만 처리한다. 설정 페이지와 해제 페이지를 테스트 페이지에 넣는 일을 한다. 함수는 한가지를 해야 한다. 그 한 가지를 잘 해야 한다. 그 한 가지만을 해야 한다. ",
    "url": "/chapter3-function.html#%ED%95%9C-%EA%B0%80%EC%A7%80%EB%A7%8C-%ED%95%B4%EB%9D%BC",
    
    "relUrl": "/chapter3-function.html#한-가지만-해라"
  },"82": {
    "doc": "3장 함수",
    "title": "한 가지의 기준",
    "content": "위의 충고에서 문제라면 그 ‘한 가지’가 무엇인지 알기 어렵다는 점이다. 목록 3-3이 진정 한가지만 하는가? 다음과 같이 세가지를 한다고 볼 수도 있다. | 페이지가 테스트 페이지인지 판단한다. | 만약 그렇다면, 설정 페이지와 해제 페이지를 넣는다. | 페이지를 HTML로 렌더링 한다. | . 이는 TO 문단으로 기술하면 다음과 같다. TO 는 LOGO 라는 언어에서 사용되는 함수를 설계하는 방식이다. TO RenderPageWithSetupsAndTeardowns, 페이지가 테스트 페이지인지 확인한 후 테스트 페이지면 설정 페이지와 해제 페이지를 넣는다. 테스트 페이지든 아니든 페이지를 HTML로 렌더링한다. 위의 TO 문단으로 기술한 작업 내용은 추상화 수준이 하나인 단계만 수행한다. 위의 의미를 유지하면서 목록 3-3을 더이상 줄이기는 힘들다. 즉 단순히 다른 표현이아니라, 완전히 다른 의미있는 이름으로 다른 함수를 추출할 수 있다면 그 함수는 여러작업을 하는 것이다. 함수 당 추상화 수준은 하나로! . 함수가 확실히 ‘한 가지’ 작업만 하려면 함수 내 모든 문장의 추상화 수준이 동일해야한다. 목록 3-1은 다양한 추상화 수준에서 여러 단계를 처리한다. 예를 들어, . | getHtml()은 추상화 수준이 아주 높다. | String pagePathName = PathParser.render(pagepath);는 추상화 수준이 중간이다. | .appedn(\"\\n\")와 같은 코드는 추상화 수준이 아주 낮다. | . 이처럼 한 함수 내에 추상화 수준이 섞여있으면, 코드를 읽는 사람이 헷갈린다. 특정 표현이 근본 개념인지, 아니면 세부사항인지 구분하기 어려운 탓이다. 위에서 아래로 코드 읽기: 내려가기 규칙 . 코드는 위에서 아래로 이야기처럼 읽혀야 좋다. 한 함수 다음에는 추상화 수준이 한 단계 낮은 함수가 온다. 즉 이러한 프로그램은 위에서 아래로 갈수록 추상화 수준이 낮아진다. 이것을 내려가기 규칙이라 부른다. 다르게 표현하면, 일련의 TO 문단을 읽듯 프로그램이 읽혀야한다는 의미이다. 다음 예제를 살펴보자. 이는 앞서 보았던 함수의 추상화 수준을 설명한다. T0 설정 페이지와 해제 페이지를 포함하려면, 설정 페이지를 포함하고, 테스트 페이지 내용을 포함하고, 해제 페이지를 포함한다. TO 설정 페이지를 포함하려면, 슈트이면 슈트 설정 페이지를 포함한 후 일반 설정 페이지를 포함한다. TO 슈트 설정 페이지를 포함하려면, 부모 계층에서 \"SuiteSetUp\" 페이지를 찾 아 include 문과 페이지 경로를 추가한다. TO 부모 계층을 검색하려면,... 위처럼 위에서 아래로 TO 문단을 읽어내려 가듯이 코드를 구현하면 추상화 수준을 일관되게 유지하기가 쉬워진다. ",
    "url": "/chapter3-function.html#%ED%95%9C-%EA%B0%80%EC%A7%80%EC%9D%98-%EA%B8%B0%EC%A4%80",
    
    "relUrl": "/chapter3-function.html#한-가지의-기준"
  },"83": {
    "doc": "3장 함수",
    "title": "Switch 문",
    "content": "switch 문은 작게 만들기 어렵다. 불행하게도 switch 문을 완전히 피할 방법은 없다. 하지만 각 switch 문을 저차원 클래스에 숨기고 절대로 반복하지 않는 방법은 있다. 물론 다형성을 이용한다. 목록 3-4를 살펴보자. 직원 유형에 따라 다른 값을 계산해 반환하는 함수다. // 목록 3-4 Payroll.java public Money calculatePay(Employee e) throws InvalidEmployeeType { switch (e.type) { case COMMISSIONED: return calculateCommissionedPay(e); case HOURLY: return calculateHourlyPay(e); case SALARIED: return calculateSalariedPay(e); default: throw new InvalidEmployeeType(e.type); } } . 위 함수에는 문제가 몇가지 있다. | 함수가 길다. 새 직원 유형을 추가할때마다 길어진다. | ‘한 가지’작업만 수행하지 않는다. | SRP(“한 클래스는 하나의 책임만 가져야 한다”는 원칙)를 위반한다. 코드를 변경할 이유가 여럿이기 때문이다. | OCP(“소프트웨어 요소는 확장에는 열려 있으나 변경에는 닫혀 있어야 한다”는 원칙)를 위반한다. 새 직원 유형을 추가할 때마다 코드를 변경하기 때문이다. | . 하지만 무엇보다 심각한 문제라면, 위 함수와 구조가 동일한 함수가 무한정 존재할 수 있다는 사실이다. 예를 들면 다음과 같은 함수가 가능하다. isPayday(Employee e, Date date);, deliverPay(Employee e, Money pay); 등 등 . // deliverPay() 예시 public Money deliverPay(Employee e, Money pay) throws InvalidEmployeeType { switch (e.type) { case COMMISSIONED: return deliverCommissionedPay(e, pay); case HOURLY: return deliverHourlyPay(e, pay); case SALARIED: return deliverSalariedPay(e, pay); default: throw new InvalidEmployeeType(e.type); } } . 등 가능성은 무한하다. 이를 목록 3-5 코드가 해결한다. 팩토리는 switch 문을 사용해 적절한 Employee 파생 클래스(CommissionedEmployee, HourlyEmployee …)의 인스턴스를 생성한다. calculatePay, isPayday, deliverPay 등과 같은 함수는 Employee 인터페이스를 거쳐 호출된다. 그러면 다형성으로 인해 실제 파생 클래스 의 함수가 실행된다. // 목록 3-5 Employee and Factory public abstract class Employee { public abstract boolean isPayday(); public abstract Money calculatePay(); public abstract void deliverPay(Money pay); } /* ------------------------------------------- */ public interface EmployeeFactory { public Employee makeEmployee(EmployeeRecord r) throws InvalidEmployeeType; } /* ------------------------------------------- */ public class EmployeeFactoryImpl implements EmployeeFactory { public Employee makeEmployee(EmployeeRecord r) throws InvalidEmployeeType { switch (r.type) { case COMMISSIONED: return new CommissionedEmployee(r); case HOURLY: return new HourlyEmployee(r); case SALARIED: return new SalariedEmployee(r); default: throw new InvalidEmployeeType(r.type); } } } . ",
    "url": "/chapter3-function.html#switch-%EB%AC%B8",
    
    "relUrl": "/chapter3-function.html#switch-문"
  },"84": {
    "doc": "3장 함수",
    "title": "서술적인 이름을 사용하라!",
    "content": "좋은 이름이 주는 가치는 아무리 강조해도 지나치지 않는다. 한 가지만 하는 작은 함수에 좋은 이름을 붙인다면 아래와 같은 원칙을 달성함에 있어 이미 절반은 성공했다. 코드를 읽으면서 짐작했던 기능을 각 루틴이 그대로 수행한다면 깨끗한 코드라 불러도 되겠다. - 위드 . 길고 서술적인 이름이 짧고 어려운 이름보다 좋다. 함수 이름을 정할 때는 여러 단어가 쉽게 읽히는 명명법을 사용한다. 그런 다음, 여러 단어를 사용해 함수 기능을 잘 표현하는 이름을 선택한다. 목록 3-7에서 예제 함수 이름 tetableHtml을 SetupTeardownIncluder.render 로 변경했다. 함수가 하는 일을 좀 더 잘 표현하므로 훨씬 좋은 이름이다. 시간이 오래걸려도 좋으니, IDE 를 활용하는 방법도 좋다. 이름을 붙일때는 일관성이 있어야한다. 모듈 내에서 함수 이름은 같은 문구, 명사, 동사를 사용한다. 목록 3-1,2,3 을 예시로 들면 모두 include 라는 단어를 사용했다. ",
    "url": "/chapter3-function.html#%EC%84%9C%EC%88%A0%EC%A0%81%EC%9D%B8-%EC%9D%B4%EB%A6%84%EC%9D%84-%EC%82%AC%EC%9A%A9%ED%95%98%EB%9D%BC",
    
    "relUrl": "/chapter3-function.html#서술적인-이름을-사용하라"
  },"85": {
    "doc": "3장 함수",
    "title": "함수 인수",
    "content": "함수에서 이상적인 인수 개수는 0게(무항)다. 다음은 1개(단항), 2개(이항) 순이다. 3개(삼항)은 되도록 피하는 편이 좋다. 4개 이상(다항)은 특별한 이유가 필요하다. 하지만 특별한 이유가 있어도 사용하면 안된다. 그 이유는, 인수는 개념을 이해하기 어렵게 만드는 요소이다. 함수에서 전달한 인수를 발견할때마다 그 의미를 해석해야한다. 혹은, 함수 이름과 인수 사이의 추상화 수준이 다를 수 있다. 테스트 관점에서 보면 인수는 더 어렵다. 인수가 많을 수록 갖가지 인수 조합으로 함수를 검증하는 테스트 케이스는 늘어나야한다. 출력 인수는 입력 인수보다 이해하기 어렵다. 흔히 우리는 함수에다 인수로 입력을 넘기고 반환값으로 출력을 받는다는 개념에 익숙하지, 인수로 결과를 받으리라 기대하지 않기 때문이다. 출력 인수는 함수의 결과를 돌려받기 위한 인수이다. 객체지향 언어에서는 ‘this’가 출력인수 역할을 하기 때문에, 출력인수를 사용할 필요가 거의 없다. ",
    "url": "/chapter3-function.html#%ED%95%A8%EC%88%98-%EC%9D%B8%EC%88%98",
    
    "relUrl": "/chapter3-function.html#함수-인수"
  },"86": {
    "doc": "3장 함수",
    "title": "많이 쓰는 단항 형식",
    "content": "함수에 인수 1개를 넘기는 이유로 가장 흔한 경우는 두 가지다. 하나는 인수에 질문을 던지는 경우다. boolean fileExists(\"MyFile\")이 좋은 예다. 다른 하나는 인수를 뭔가로 변환해 결과를 반환하는 경우다. InputStream fileOpen(\"MyFile\")은 String 형의 파일 이름을 InputStream으로 변환한다. 함수 이름을 지을 때는 두 경우를 분명히 구분한다. 또한 언제나 일관적인 방식으로 두 형식을 사용한다. 다소 드물게 사용하지만 그래도 아주 유용한 단항 함수 형식이 이벤트다. 이벤트 함수는 입력 인수만 있다. 출력 인수는 없다. 프로그램은 함수 호출을 이벤트로 해석해 입력 인수로 시스템 상태를 바꾼다. 이벤트 함수는 조심해서 사용한다. 이벤트라는 사실이 코드에 명확히 드러나야 한다. 그러므로 이름과 문맥을 주의해서 선택한다. 지금까지 설명한 경우가 아니라면 단항 함수는 가급적 피한다. 입력 인수를 변환하는 함수라면 변환 결과는 반환값으로 돌려준다. StringBuffer transform(StringBuffer in)이 void transform(StringBuffer out)보다 낫다. StringBuffer transform(StringBuffer in)이 입력 인수를 그대로 돌려주는 함수라 할지라도 변환 함수 형식을 따르는 편이 좋다. 변환 함수에서 출력 인수를 사용하면 혼란을 일으킨다. 적어도 변환 형태는 유지하기 때문이다. ",
    "url": "/chapter3-function.html#%EB%A7%8E%EC%9D%B4-%EC%93%B0%EB%8A%94-%EB%8B%A8%ED%95%AD-%ED%98%95%EC%8B%9D",
    
    "relUrl": "/chapter3-function.html#많이-쓰는-단항-형식"
  },"87": {
    "doc": "3장 함수",
    "title": "플래그 인수",
    "content": "함수로 부울 값을 넘기는 플래그 인수는 정말로 끔찍하다. 이는 함수가 한꺼번에 여러 가지를 처리한다는 의미이기 때문이다. (참이면 A 실행, 거짓이면 B 실행). 다시 한번, 함수는 ‘한 가지’만 수행해야한다. ",
    "url": "/chapter3-function.html#%ED%94%8C%EB%9E%98%EA%B7%B8-%EC%9D%B8%EC%88%98",
    
    "relUrl": "/chapter3-function.html#플래그-인수"
  },"88": {
    "doc": "3장 함수",
    "title": "이항 함수",
    "content": "인수가 2개인 함수는 1개인 함수보다 더 이해하기 어렵다. 예를 들어, 첫 인수가 불필요할 수 있는 경우 이를 무시해야한다는 사실을 깨닫는 시간이 필요할 수 있다. 혹은, 2개의 인수에서 실수로 값을 넣는 경우도 발생한다. 이렇게 주춤하게 만드는 상황들은 인지적으로 거슬린다는 의미이며, 이는 문제를 일으킨다. 물론 이항 함수가 적절한 경우도 있다. Point p = new Point(0, 0)가 좋은 예다. 직교 좌표계 점은 일반적으로 인수 2개를 취한다.(x 좌표, y 좌표) 이는 사실상 하나의 정보를 표현하는 두 요소라고 볼 수 있다. 또한 이 두 인수 사이에는 자연적인 순서도 있다. 이항 함수가 무조건 나쁘다는 소리는 아니지만, 그만큼 위험이 따르니 가능한 단항 함수로 바꾸려고하는 노력이 필요하다. 인수로 들어가는 값을 클래스 구성원으로 만드는 것 등이 방법이 될 수 있다. ",
    "url": "/chapter3-function.html#%EC%9D%B4%ED%95%AD-%ED%95%A8%EC%88%98",
    
    "relUrl": "/chapter3-function.html#이항-함수"
  },"89": {
    "doc": "3장 함수",
    "title": "삼항 함수",
    "content": "인수가 3개인 함수는 훨씬 이해하기 어렵다. 그래서 삼항 함수를 만들때는 신중히 고려해야한다. 예를 들어 assertEquals(message, expected, actual)이라는 함수를 살펴보자. 첫 인수가 예상과 다르거나, 두번째, 세번째 인수가 예상과 달라 멈칫하고 주춤할 가능성이 커진다. 다시한번, 이러한 상황들이 문제를 일으킨다. ",
    "url": "/chapter3-function.html#%EC%82%BC%ED%95%AD-%ED%95%A8%EC%88%98",
    
    "relUrl": "/chapter3-function.html#삼항-함수"
  },"90": {
    "doc": "3장 함수",
    "title": "인수 객체",
    "content": "인수가 2-3개 필요하다면 일부를 독자적인 클래스 변수로 선언할 가능성을 짚어본다. Circle makeCircle(double x, double y, double radius); Circle makeCircle(Point center, double radius); . 객체를 생성해 인수를 줄이는 방법이 눈속임이라 여겨질지 모르지만 그렇지 않다. 위 예제에서 x와 y를 묶었듯이 변수를 묶어 넘기려면 이름을 붙여야 하므로 결국은 개념을 표현하게 된다. ",
    "url": "/chapter3-function.html#%EC%9D%B8%EC%88%98-%EA%B0%9D%EC%B2%B4",
    
    "relUrl": "/chapter3-function.html#인수-객체"
  },"91": {
    "doc": "3장 함수",
    "title": "인수 목록",
    "content": "때로는 인수 개수가 가변적인 함수도 필요하다. String.format 메서드가 좋은 예다. String.format(\"%s worked %.2f hours.\", name, hours); . 위 예제처럼 가변 인수 전부를 동등하게 취급하면 List 형 인수 하나로 취급할 수 있다. 이런 논리로 따져보면 String.format은 사실상 이항 함수다. 실제로 String.format 선언부를 살펴보면 이항 함수라는 사실이 분명히 드러난다. public String format(String format, Object... args) . 가변 인수를 취하는 모든 함수에 같은 원리가 적용된다. 가변 인수를 취하는 함수는 단항, 이항, 삼항 함수로 취급할 수 있다. ",
    "url": "/chapter3-function.html#%EC%9D%B8%EC%88%98-%EB%AA%A9%EB%A1%9D",
    
    "relUrl": "/chapter3-function.html#인수-목록"
  },"92": {
    "doc": "3장 함수",
    "title": "동사와 키워드",
    "content": "함수의 의도나 인수의 순서와 의도를 제대로 표현하려면 좋은 함수 이름이 필수다. 단항 함수는 함수와 인수가 동사/명사 쌍을 이뤄야 한다. 예를 들어, write(name)은 누구나 곧바로 이해한다. ‘이름(name)’이 무엇이든 ‘쓴다(write)’는 뜻이다. 좀 더 나은 이름은 writeField(name)이다. 그러면 ‘이름(name)’이 필드라는 사실이 분명히 드러난다. 함수 이름에 키워드를 추가하는 형식이다. 즉, 함수 이름에 인수 이름을 넣는다. 예를 들어, assertEquals보다 assertExpectedEqualsActual(expected, actual)`이 더 좋다. 그러면 인수 순서를 기억할 필요가 없어진다. ",
    "url": "/chapter3-function.html#%EB%8F%99%EC%82%AC%EC%99%80-%ED%82%A4%EC%9B%8C%EB%93%9C",
    
    "relUrl": "/chapter3-function.html#동사와-키워드"
  },"93": {
    "doc": "3장 함수",
    "title": "부수 효과를 일으키지 마라!",
    "content": "부수 효과는 함수에서 ‘한 가지’를 하는 것 처럼 보이지만, 실제로 남몰래 다른 일도 일으킨다. 예를 들어 예상치 못하게 클래스 변수를 수정하거나, 함수로 넘어온 인수나 시스템 전역 변수를 수정한다. 다음 함수는 부수 효과를 일으킨다. 살펴보자. // 목록 3-6 UserValidator.java public boolean checkPassword(String userName, String password) { User user = UserGateway.findByName(userName); if (user != User.NULL) { String codedPhrase = user.getPhraseEncodedByPassword(); String phrase = cryptographer.decrypt(codedPhrase, password); if (\"Valid Password\".equals(phrase)) { Session.initialize(); return true; } return false; } } . 여기서, 함수가 일으키는 부수 효과는 Session.initialize()호출이다. checkPassword함수는 이름만 봐서는 세션을 초기화한다는 사실이 드러나지 않는다. 이런 부수 효과가 시간적인 결합을 초래한다. 시간적 결합(Temporal Coupling)은 소프트웨어 설계에서 특정 요소들이 시간이나 순서에 따라 의존하는 관계를 의미한다. 예를 들어, “메서드 A는 항상 메서드 B보다 먼저 호출되어야 한다”와 같이 실행 순서에 제약이 있는 경우를 말한다. 즉, checkPassword함수는 특정 상황에서만 호출이 가능하다. 다시 말해, 세션을 초기화해도 괜찮은 경우에만 호출이 가능하다. 자칫 잘못 호출하면 의도하지 않게 세션 정보가 날아간다. 이렇듯 시간적인 결합은 혼란을 일으킨다. 특히 부수 효과로 숨겨진 경우에는 더더욱 혼란이 커진다. 만약 시간적인 결합이 필요하다면 함수 이름에 분명히 명시한다. 따라서 목록 3-6은 checkPasswordAndInitializeSession이라는 이름이 훨씬 좋다. 물론 이는 함수가 ‘한 가지’만 한다는 규칙을 위반한다. ",
    "url": "/chapter3-function.html#%EB%B6%80%EC%88%98-%ED%9A%A8%EA%B3%BC%EB%A5%BC-%EC%9D%BC%EC%9C%BC%ED%82%A4%EC%A7%80-%EB%A7%88%EB%9D%BC",
    
    "relUrl": "/chapter3-function.html#부수-효과를-일으키지-마라"
  },"94": {
    "doc": "3장 함수",
    "title": "출력 인수",
    "content": "일반적으로 우리는 인수를 함수 입력으로 해석한다. 예를 들어 다음 함수를 보자. appendFooter(s); . 이 함수는 무언가에 s ‘를 바닥글로 첨부’ 할까? 아니면 s ‘에 바닥글을 첨부’ 할까? 즉, 인수 s 는 입력일까 출력일까? 이는 함수 선언부를 찾아보면 분명해진다. public void appendFooter(StringBuffer report) . 인수 s가 출력 인수라는 사실을 알았지만, 함수 선언부를 보고나서야 알게 되었다. 이는 주춤하게 하며 인지적으로 거슬리는 행위이다. 피해야하는 경우이다. 객체 지향 프로그램이이 나오기 전에는 출력 인수가 불가피한 경우도 있었다. 하지만 객체 지향 언어에서는 출력 인수를 사용할 필요가 거의 없다. ",
    "url": "/chapter3-function.html#%EC%B6%9C%EB%A0%A5-%EC%9D%B8%EC%88%98",
    
    "relUrl": "/chapter3-function.html#출력-인수"
  },"95": {
    "doc": "3장 함수",
    "title": "명령과 조회를 분리하라!",
    "content": "함수는 뭔가를 수행하거나 뭔가에 답하거나 둘 중 하나만 해야 한다. 둘 다 하면 안된다. 객체 상태를 변경하거나 아니면 객체 정보를 반환하거나 둘 중 하나이다. 다음 함수를 살펴보자. public boolean set(String attribute, String value); . 이 함수는 이름이 attribute인 속성을 조회해 값을 value로 설정한 후 성공하면 true를 반환하고 실패하면 false를 반환한다. 이 함수를 호출할 때 독자는 혼란이 온다. if (set(\"username\", \"unclebob\")) ... username이 unclebob으로 설정되어 있는지 확인하는 코드인가? 아니면 username을 unclebob으로 설정하는 코드인가? set이라는 단어가 동사인지 형용사인지 분간하기 어려운 탓이다. 함수를 구현한 개발자는 set을 동사로 의도했다. 하지만 if 문에 넣고 보면 형용사로 느껴진다. 그래서 if 문은 “username 속성이 unclebob으로 설정되어 있다면…“으로 읽힌다. “username을 unclebob으로 설정하는데 성공하면…“으로 읽히지 않는다. set이라는 함수 이름을 setAndCheckifExists라고 바꾸는 방법도 있지만 if 문에 넣고 보면 여전히 어색하다. 진짜 해결책은 명령과 조회를 분리해 혼란을 애초에 뿌리뽑는 방법이다. if (attributeExists(\"username\")) { setAttribute(\"username\", \"unclebob\"); } . ",
    "url": "/chapter3-function.html#%EB%AA%85%EB%A0%B9%EA%B3%BC-%EC%A1%B0%ED%9A%8C%EB%A5%BC-%EB%B6%84%EB%A6%AC%ED%95%98%EB%9D%BC",
    
    "relUrl": "/chapter3-function.html#명령과-조회를-분리하라"
  },"96": {
    "doc": "3장 함수",
    "title": "오류 코드보다 예외를 사용하라!",
    "content": "명령 함수에서 오류 코드를 반환하는 방식은 명령/조회 분리 규칙을 미묘하게 위반한다. 자칫하면 if 문에서 명령을 표현식으로 사용하기 쉬운 탓이다. if (deletePage(page) == E_OK) . 위 코드는 동사/형용사 혼란을 일으키지 않는 대신 여러 단계로 중첩되는 코드를 야기할 수 있다. 해당 함수는 오류 코드를 반환하기에, 호출자는 오류 코드를 곧바로 처리해야 하기 때문이다. 다음과 같이 3단으로 중첩된 코드를 야기한다. if (deletePage(page) == E_OK) { if (registry.deleteReference(page.name) == E_OK) { if (configkeys.deleteKey(page.name.makeKey()) == E_OK) { logger.log(\"page deleted\"); } else { logger.log(\"configKey not deleted\"); } } else { logger.log(\"deleteReference from registry failed\"); } } else { logger.log(\"delete failed\"); return E_ERROR; } . 이를 예외를 사용하면, 오류 처리 코드가 원래 코드에서 분리되므로 코드가 깔끔해진다. try { deletePage(page); registry.deleteReference(page.name); configKeys.deleteKey(page.name.makeKey()); } catch (Exception e) { logger.log(e.getMessage()); } . ",
    "url": "/chapter3-function.html#%EC%98%A4%EB%A5%98-%EC%BD%94%EB%93%9C%EB%B3%B4%EB%8B%A4-%EC%98%88%EC%99%B8%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%9D%BC",
    
    "relUrl": "/chapter3-function.html#오류-코드보다-예외를-사용하라"
  },"97": {
    "doc": "3장 함수",
    "title": "Try/Catch 블록 뽑아내기",
    "content": "try/catch 블록은 코드 구조에 혼란을 일으키며, 정상 동작과 오류 처리 동작을 뒤섞는다. 그러므로 try/catch 블록을 별도 함수로 뽑아내는 편이 좋다. 아래는 기존의 deletePage 에서 오류를 처리하는 delete 함수와 실제 페이지를 제거하는 함수인 deletePageAndAllReferences로 분리한다. public void delete(Page page) { try { deletePageAndAllReferences(page); } catch (Exception e) { logError(e); } } private void deletePageAndAllReferences(Page page) throws Exception { deletePage(page); registry.deleteReference(page.name); configKeys.deleteKey(page.name.makeKey()); } private void logError(Exception e) { logger.log(e.getMessage()); } . 위에서 delete 함수는 모든 오류를 처리한다. 그래서 코드를 이해하기 쉽다. 한 번 훑어보고 넘어가면 충분하다. 실제로 페이지를 제거하는 함수는 deletePageAndAllReferences다. deletePageAndAllReferences함수는 예외를 처리하지 않는다. 이렇게 정상 동작과 오류 처리 동작을 분리하면 코드를 이해하고 수정하기 쉬워진다. ",
    "url": "/chapter3-function.html#trycatch-%EB%B8%94%EB%A1%9D-%EB%BD%91%EC%95%84%EB%82%B4%EA%B8%B0",
    
    "relUrl": "/chapter3-function.html#trycatch-블록-뽑아내기"
  },"98": {
    "doc": "3장 함수",
    "title": "오류 처리도 한 가지 작업이다.",
    "content": "함수는 ‘한 가지’ 작업만 해야 한다. 오류 처리도 ‘한 가지’ 작업에 속한다. 그러므로 오류를 처리하는 함수는 오류만 처리해야 마땅하다. (위 예제에서 보았듯이) 함수에 키워드 try가 있다면 함수는 try 문으로 시작해 catch/finally 문으로 끝나야 한다는 말이다. ",
    "url": "/chapter3-function.html#%EC%98%A4%EB%A5%98-%EC%B2%98%EB%A6%AC%EB%8F%84-%ED%95%9C-%EA%B0%80%EC%A7%80-%EC%9E%91%EC%97%85%EC%9D%B4%EB%8B%A4",
    
    "relUrl": "/chapter3-function.html#오류-처리도-한-가지-작업이다"
  },"99": {
    "doc": "3장 함수",
    "title": "Error.java 의존성 자석",
    "content": "오류 코드를 반환한다는 이야기는, 클래스든 열거형 변수든, 어디선가 오류 코드를 정의한다는 뜻이다. public enum Error { OK, INVALID, NO_SUCH, LOCKED, OUT_OF_RESOURCES, WAITING_FOR_EVENT; } . 위와 같은 클래스는 의존성 자석(magnet)이다. Error enum이 변한다면 Error enum을 사용하는 클래스 전부를 다시 컴파일하고 다시 배치해야 한다. 그래서 Error 클래스 변경이 어려워진다. 그래서 새 오류 코드를 추가하는 대신 기존 오류 코드를 재사용한다. 이는 예외를 사용하여 해결할 수 있다. 오류 코드 대신 예외를 사용하면 새 예외는 Exception 클래스에서 파생된다. 따라서 재컴파일/재배치 없이도 새 예외 클래스를 추가할 수 있다. ",
    "url": "/chapter3-function.html#errorjava-%EC%9D%98%EC%A1%B4%EC%84%B1-%EC%9E%90%EC%84%9D",
    
    "relUrl": "/chapter3-function.html#errorjava-의존성-자석"
  },"100": {
    "doc": "3장 함수",
    "title": "반복하지 마라!",
    "content": "목록 3-1을 주의해서 읽어보면 네 번이나 반복되는 알고리즘이 보인다. 알고리즘 하나가 SetUp, SuiteSetUp, TearDown, SuiteTearDown에서 반복된다. 다른 코드와 섞이면서 모양이 조금씩 달라져 중복이 금방 드러나지는 않지만 중복은 문제이다. 목록 3-7 에서는 include함수로 중복을 없앤다. 중복을 없애면 모듈 가독성이 크게 높아진다. 어쩌면 중복은 소프트웨어에서 모든 악의 근원이다. 많은 원칙과 기법이 중복을 없애거나 제어할 목적으로 나왔다. | 예를 들어, E. F. 커드(E.F. Codd)는 자료에서 중복을 제거할 목적으로 관계형 데이터베이스에 정규 형식을 만들었다. | 객체 지향 프로그래밍은 코드를 부모 클래스로 몰아 중복을 없앤다. | 구조적 프로그래밍, AOP(Aspect Oriented Programming), COP(Component Oriented Programming) 모두 어떤 편에서 중복 제거 전략이다. | . 이처럼 하위 루틴을 발병한 이래로 소프트웨어 개발에서 지금까지 일어난 혁신은 소스 코드에서 중복을 제거하려는 지속적인 노력으로 보인다. ",
    "url": "/chapter3-function.html#%EB%B0%98%EB%B3%B5%ED%95%98%EC%A7%80-%EB%A7%88%EB%9D%BC",
    
    "relUrl": "/chapter3-function.html#반복하지-마라"
  },"101": {
    "doc": "3장 함수",
    "title": "구조적 프로그래밍",
    "content": "에츠허르 데이크스트라(Edsger Dijkstra)는 구조적 프로그래밍적은 측면에서 모든 함수와 함수 내 모든 블록에 입구(entry)와 출구가 하나만 존재해야 한다고 말했다. 즉, 함수는 return 문이 하나여야 한다는 말이다. 루프 안에서 break나 continue를 사용해선 안 되며 goto는 절대로, 절대로 안 된다. 하지만 이러한 함수가 작다면 위 규칙은 별 이익을 제공하지 못한다. 함수가 아주 클 때만 상당한 이익을 제공한다. 그러므로 함수를 작게 만든다면 간혹 return, break, continue를 여러 차례 사용해도 괜찮다. 오히려 때로는 단일 입/출구 규칙(single entry-exit rule)보다 의도를 표현하기 쉬워진다. 반면, goto 문은 큰 함수에서만 의미가 있으므로, 작은 함수에서는 피해야만 한다. ",
    "url": "/chapter3-function.html#%EA%B5%AC%EC%A1%B0%EC%A0%81-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D",
    
    "relUrl": "/chapter3-function.html#구조적-프로그래밍"
  },"102": {
    "doc": "3장 함수",
    "title": "함수를 어떻게 짜죠?",
    "content": "소프트웨어를 짜는 행위는 여느 글짓기와 비슷하다. 논문이나 기사를 작성할 때는 먼저 생각을 기록한 후 읽기 좋게 다듬는다. 초안은 대개 서투르고 어수선하므로 원하는 대로 읽힐 때까지 말을 다듬고 문장을 고치고 문단을 정리한다. 함수를 짤 때도 마찬가지다. 처음에는 길고 복잡하다. 들여쓰기 단계도 많고 중복된 루프도 많다. 인수 목록도 아주 길다. 이름은 즉흥적이고 코드는 중복된다. 하지만 나는 그 서투른 코드를 빠짐없이 테스트하는 단위 테스트 케이스도 만든다. 그런 다음 코드를 다듬고, 함수를 만들고, 이름을 바꾸고, 중복을 제거한다. 메서드를 줄이고 순서를 바꾼다. 때로는 전체 클래스를 쪼개기도 한다. 이 와중에도 코드는 항상 단위 테스트를 통과한다. 최종적으로는 이 장에서 설명한 규칙을 따르는 함수가 얻어진다. 처음부터 탁 짜내지 않는다. 그게 가능한 사람은 없으리라. ",
    "url": "/chapter3-function.html#%ED%95%A8%EC%88%98%EB%A5%BC-%EC%96%B4%EB%96%BB%EA%B2%8C-%EC%A7%9C%EC%A3%A0",
    
    "relUrl": "/chapter3-function.html#함수를-어떻게-짜죠"
  },"103": {
    "doc": "3장 함수",
    "title": "최종 re-re-refactoring 버전 (목록 3-7 함수)",
    "content": "package fitnesse.html; import fitnesse.responders.run.SuiteResponder; import fitnesse.wiki.*; public class SetupTeardownIncluder { private PageData pageData; private boolean isSuite; private WikiPage testPage; private StringBuffer newPageContent; private PageCrawler pageCrawler; public static String render(PageData pageData) throws Exception { return render(pageData, false); } public static String render(PageData pageData, boolean isSuite) throws Exception { return new SetupTeardownIncluder(pageData).render(isSuite); } private SetupTeardownIncluder(PageData pageData) { this.pageData = pageData; testPage = pageData.getWikiPage(); pageCrawler = testPage.getPageCrawler(); newPageContent = new StringBuffer(); } private String render(boolean isSuite) throws Exception { this.isSuite = isSuite; if (isTestPage()) includeSetupAndTeardownPages(); return pageData.getHtml(); } private boolean isTestPage() throws Exception { return pageData.hasAttribute(\"Test\"); } private void includeSetupAndTeardownPages() throws Exception { includeSetupPages(); includePageContent(); includeTeardownPages(); updatePageContent(); } private void includeSetupPages() throws Exception { if (isSuite) includeSuiteSetupPage(); includeSetupPage(); } private void includeSuiteSetupPage() throws Exception { include(SuiteResponder.SUITE_SETUP_NAME, \"-setup\"); } private void includeSetupPage() throws Exception { include(\"SetUp\", \"-setup\"); } private void includePageContent() throws Exception { newPageContent.append(pageData.getContent()); } private void includeTeardownPages() throws Exception { includeTeardownPage(); if (isSuite) includeSuiteTeardownPage(); } private void includeTeardownPage() throws Exception { include(\"TearDown\", \"-teardown\"); } private void includeSuiteTeardownPage() throws Exception { include(SuiteResponder.SUITE_TEARDOWN_NAME, \"-teardown\"); } private void updatePageContent() throws Exception { pageData.setContent(newPageContent.toString()); } private void include(String pageName, String arg) throws Exception { WikiPage inheritedPage = findInheritedPage(pageName); if (inheritedPage != null) { String pagePathName = getPathNameForPage(inheritedPage); buildIncludeDirective(pagePathName, arg); } } private WikiPage findInheritedPage(String pageName) throws Exception { return PageCrawlerImpl.getInheritedPage(pageName, testPage); } private String getPathNameForPage(WikiPage page) throws Exception { WikiPagePath pagePath = pageCrawler.getFullPath(page); return PathParser.render(pagePath); } private void buildIncludeDirective(String pagePathName, String arg) { newPageContent .append(\"\\n!include \") .append(arg) .append(\" .\") .append(pagePathName) .append(\"\\n\"); } } . ",
    "url": "/chapter3-function.html#%EC%B5%9C%EC%A2%85-re-re-refactoring-%EB%B2%84%EC%A0%84-%EB%AA%A9%EB%A1%9D-3-7-%ED%95%A8%EC%88%98",
    
    "relUrl": "/chapter3-function.html#최종-re-re-refactoring-버전-목록-3-7-함수"
  },"104": {
    "doc": "3장 함수",
    "title": "결론",
    "content": "모든 시스템은 특정 응용 분야 시스템을 기술할 목적으로 프로그래머가 설계한 도메인 특화 언어(Domain Specific Language, DSL)로 만들어진다. 함수는 그 언어에서 동사며, 클래스는 명사다. 요구사항 문서에 나오는 명사와 동사를 클래스와 함수 후보로 고려한다는 끔찍한 옛 규칙으로 역행하자는 이야기가 아니다. 아니, 이것은 오히려 훨씬 더 오래된 진실이다. 프로그래밍의 기술은 언제나 언어 설계의 기술이다. 예전에도 그랬고 지금도 마찬가지다. 대가(master) 프로그래머는 시스템을 “구현할” 프로그램이 아니라 “풀어갈” 이야기로 여긴다. 프로그래밍 언어라는 수단을 사용해 좀 더 풍부하고 좀 더 표현력이 강한 언어를 만들어 이야기를 풀어간다. 시스템에서 발생하는 모든 동작을 설명하는 함수 계층이 바로 그 언어에 속한다. 이 장은 함수를 잘 만드는 기교를 소개했다. 여기서 설명한 규칙을 따른다면 길이가 짧고, 이름이 좋고, 체계가 잡힌 함수가 나올 것이다. 하지만 진짜 목표는 시스템이라는 이야기를 풀어가는 데 있다는 사실을 명심해야한다. 작성하는 함수가 분명하고 정확한 언어로 깔끔하게 같이 맞아떨어져야 이야기를 풀어가기가 쉬워진다는 사실을 기억해야 한다. ",
    "url": "/chapter3-function.html#%EA%B2%B0%EB%A1%A0",
    
    "relUrl": "/chapter3-function.html#결론"
  },"105": {
    "doc": "4장 주석",
    "title": "4장 주석",
    "content": ". | 주요 내용 . | 어떤 내용을 주석으로 표시해야하는지 | 주석을 주의해서 달아야하는 이유 | 좋은 주석과 나쁜 주석의 종류와 예시 | 나쁜 주석을 개선하는 예시 | . | . ",
    "url": "/chapter4-annotation.html",
    
    "relUrl": "/chapter4-annotation.html"
  },"106": {
    "doc": "4장 주석",
    "title": "주석은 나쁜 코드를 보완하지 못한다",
    "content": "요약: 코드를 잘 작성한다면, 주석은 필요하지 않다. 그렇기에 주석을 다는 것보다 코드를 잘 작성하는 것이 좋다. | 코드로만 작성하는 것이 가장 좋다는 것을 이야기한다. 프로그래밍 언어 자체가 표현력이 풍부하다면, 아니 우리에게 프로그래밍 언어를 치밀하게 사용해 의도를 표현할 능력이 있다면, 주석은 거의 필요하지 않으리라. 아니, 전혀 필요하지 않으리라. | 보통 주석을 사용하는 이유는, 코드를 깨끗하게 작성하는 것을 실패해 주석을 사용한다. 우리는 코드로 의도를 표현하지 못해, 그러니까 실패를 만회하기 위해 주석을 사용한다. | 주석을 되도록이면 사용하지 않아야하는 큰 이유: 프로그래머들이 주석을 유지하고 보수하기란 현실적으로 불가능하다. 내가 이렇듯 주석을 무시하는 이유가 무엇이냐고? 거짓말을 하니까. 오래될수록 완전히 그릇될 가능성도 커진다. 이유는 단순하다. 프로그래머들이 주석을 유지하고 보수하기란 현실적으로 불가능하다. | 주석을 지양해야하는 이유로 부정확한 주석은 매우 좋지 않고, 코드만이 진실이기 때문임을 얘기한다. 부정확한 주석은 아예 없는 주석보다 훨씬 더 나쁘다. 부정화한 주석은 독자를 현혹하고 오도한다. 진실은 한곳에만 존재한다. 바로 코드다. | 주석은 나쁜 코드를 보완하지 못한다. 표현력이 풍부하고 깔끔하며 주석이 거의 없는 코드가, 복잡하고 어우선하며 주석이 많이 달린 코드보다 훨씬 좋다. 자신이 저지른 난장판을 주석으로 설명하려 얘스는 대신에 그 난장판을 깨끗이 치우는 데 시간을 보내라! . | . ",
    "url": "/chapter4-annotation.html#%EC%A3%BC%EC%84%9D%EC%9D%80-%EB%82%98%EC%81%9C-%EC%BD%94%EB%93%9C%EB%A5%BC-%EB%B3%B4%EC%99%84%ED%95%98%EC%A7%80-%EB%AA%BB%ED%95%9C%EB%8B%A4",
    
    "relUrl": "/chapter4-annotation.html#주석은-나쁜-코드를-보완하지-못한다"
  },"107": {
    "doc": "4장 주석",
    "title": "코드로 의도를 표현하라!",
    "content": "요약: 대부분의 주석은 코드로 작성할 수 있고, 이러한 방향이 더 좋다. | 코드로 의도를 작성하기 어려운 경우가 있지만, 이게 코드가 나쁜 수단이라는 의미가 아니다. 확실히 코드만으로 의도를 설명하기 어려운 경우가 존재한다. 불행히도 많은 개발자가 이를 코드는 훌륭한 수단이 아니라는 의미로 해석한다. 이는 분명히 잘못된 생각이다. | 주석을 코드로 변경하는 예시 . | 이전 // 직원에게 복지 혜택을 받을 자격이 있는지 검사한다. if((emoloyee.flags &amp; HOURLY_FLAG) &amp;&amp; (emoloyee.age &gt; 65)) . | 변경 if(emoloyee.isEligibleForFullBenefits()) . | . | . ",
    "url": "/chapter4-annotation.html#%EC%BD%94%EB%93%9C%EB%A1%9C-%EC%9D%98%EB%8F%84%EB%A5%BC-%ED%91%9C%ED%98%84%ED%95%98%EB%9D%BC",
    
    "relUrl": "/chapter4-annotation.html#코드로-의도를-표현하라"
  },"108": {
    "doc": "4장 주석",
    "title": "좋은 주석",
    "content": "법적인 주석 . | 저작권 정보, 소유권 정보와 같은 법적인 주석은 필요하다 표준에 맞춰 법적인 이유로 특정 주석을 넣으라고 명시한다. 각 소스 첫머리에 주석으로 들어가는 저작권 정보와 소유권 정보는 필요하고도 타당하다. | 예시 // Copyright (c) 2003,2004,2005 by object Mentor, rnc. All rights reserved. // GNU Generat Pubtic License 버전 2 이상 따르는 조건으로 배포한다. | . 정보를 제공하는 주석 . | 기본적인 정보를 제공하면 편리하지만, 이왕이면 변환 클래스나 메서드 이름으로 이를 잘 표현하는 등의 코드로 표현하는 것이 더 좋다. 때로는 기본적인 정보를 주석으로 제공하면 것은 편리하다. 위와 같은 주석이 유용하다 할지라도, 가능하다면, 함수 이름에 정보를 담는 편이 더 좋다. 이왕이면 시각과 날짜를 변환하는 클래스를 만들어 코드를 옮겨주면 더 좋고 더 깔끔하겠다. 그러면 주석이 필요 없어진다. | 예시 . | 테스트 코드 // 테스트 중인 Responder 인스턴스를 반환한다. protected abstract Responder responderInstance(); . | 정규식 // kk:mm:ss EEE, MMM dd, yyyy 형식이다. Pattern timeMatcher = Pattern.compile(\"\\\\d*:\\\\d*:\\\\d* \\\\w*, \\\\w* \\\\d* \\\\d*\"); . | . | . 의도를 설명하는 주석 . | 예시 . | 의도를 설명하지 않는 코드: 오른쪽 유형이 무엇인지를 설명하지 않아 어떤 정렬을 하려고 한건지 의도를 모름 public int compareTo(0bject o){ if (o instanceof WikiPagePath){ WikiPagePath p = (WlkiPagePath) o; String compressedr,lame = St ringUtil.join( names, \"\" ) ; String compressedArgumentName = St ringUtit.join( p. names, \"\") ; return comp ressedName. compareTo( compressedArgumentName ) ; } return 1; // 오른쪽 유형이므로 정렬 순위가 더 높다. } . | 의도를 설명하는 코드: 어떤 의도인지를 적어놓음으로써, 코드를 작성한 의도를 알게됨 pubtic void testConcurrentAddWidgets() throws Exception { WidgetBuilder widgetBuilder = new WidgetBuilder( new Class [] {BotdWidget.class} ) ; String text = \"'''\"bold text'''\"; ParentWidget parent = new BotdWidget(new MockWidgetRoot(), \"'''\"bold text'''\"); AtomicBootean faitFlag = new AtomicBooteanO ; failFlag.set(false) ; // 스레드를 대량 생성하는 방법으로 어떻게든 경쟁 조건을 만들려 시도한다. for (int i = 0; i &lt; 25000; i++) { WldgetBuilderThread widgetBuitderThread = new WidgetBuitderThread(widgetBui.lder, text, parent, failFlag) ; Thread thread = new Thread (widgetBuitderThread ) ; thread.start(); } assertEquats(false, failFlag. get( ) ) ; } . | . | . 의미를 명료하게 밝히는 주석 . | 코드를 변경할 수 없는 경우 의미를 명료하게 밝히는 주석, 하지만 위험하기에 주의해야한다. 표준 라이브러리나 변경하지 못하는 코드에 속한다면 의미를 명료하게 밝히는 주석이 유용하다. 그러므로 위와 같은 주석을 달 때는 더 나은 방법이 없는지 고민해보고 정확히 달도록 각별히 주의한다. | 예시 assertTure(a.compareTo(a) ==0 ); // a == a . | . 결과를 경고하는 주석 . | 다른 프로그래머에게 결과를 경고할 목적으로 주석을 사용한다. 때로 다른 프로그래머에게 결가를 경고할 목적으로 주석을 사용한다. | 예시 // SimpleDateFormat은 스레드에 안전하지 못하다. // 따라서 각 인스턴스를 독립적으로 생성해야 한다. SimpleDateFormat df = new SimpteDateFormat(\"EEE, dd MMM yyyy HH:nm:ss z\"); . | . TODO 주석 . | 앞으로 할 일을 TODO 주석으로 남기면 좋지만, 나쁜 코드를 남겨놓는 핑계로 사용해는 안된다. 앞으로 할 일을 TODO 주석으로 남겨두면 편하다. 하지만 어떤 용도로 사용하든 시스템에 나쁜 코드를 남겨 놓는 핑계가 되어서는 안 된다. | . 중요성을 강조하는 주석 . | 놓치기 쉬운 중요한 부분을 강조하는데 사용한다. 자칫 대수롭지 않다고 여겨질 뭔가의 중요성을 강조하기 위해서도 주석을 사용한다. | 예시 String listItemContent = match(3).trim(); // 여기서의 trim()은 정말 중요하다. trim 함수 문자열에서 시작 공백을 제거한다. // 문자열에 시작 공백이 있으면 다른 문자열로 인식되기 떄문이다. | . 공개 API에서 javadocs . | 공개 API를 구현한다면 javadocs를 작성해야하지만, 주의해야한다. 공개 API를 구현한다면 반드시 훌륭한 javadocs를 작성한다. 하지만 이 장에서 제시하는 나머지 충고도 명심하길 바란다. | . ",
    "url": "/chapter4-annotation.html#%EC%A2%8B%EC%9D%80-%EC%A3%BC%EC%84%9D",
    
    "relUrl": "/chapter4-annotation.html#좋은-주석"
  },"109": {
    "doc": "4장 주석",
    "title": "나쁜 주석",
    "content": "주절거리는 주석 . | 이해가 안되서 다른 모듈까지 확인해야하는 주석은 독자와 제대로 소통하지 못한 주석은 시간 낭비다. 주석을 달기로 결정했다면 충분한 시간을 들여 최고의 주석을 달도록 노력한다. 확실히 저자에게야 의미가 있겠지만 그 의미가 다른 사람들에게는 전해지지 않는다. 답을 알아내려면 다른 코드를 뒤져보는 수밖에 없다. 이해가 안 되어 다른 모듈까지 뒤져야 하는 주석은 독자와 제대로 소통하지 못하는 주석이다. | . 같은 이야기를 중복하는 주석 . | 코드와 같은 내용을 전달하는 주석으로, 코드 내용이 간단하다면 오히려 주석을 읽는데 시간이 더 걸린다. 헤더에 달린 주석이 같은 코드 내용을 그대로 중복한다. 자칫하면 코드보다 주석을 읽는 시간이 더 오래 걸린다. 코드보다 읽기 쉽지도 않다. | 예시 . | 내용이 메서드 내용과 같음 // this.closed가 true일 때 반환되는 유틸리티 메서드다. // 타임아웃에 도달하면 예외를 던진다. public synchronized void waitForClose(final long timeoutMillis) throws Exception{ if(!closed){ wait(timeoutMillis); if(!closed){ throw new Exception(\"MockResponseSender could not be closed\"); } } } . | 각 변수 이름을 해석한 것과 같음 public abstract class ContainerBase implements Contrainer, Lifecyle, Pipeline, MBeanRegistraion, Serializable{ /** * 이 컴포넌트의 프로세서 지연 값 */ protected int backgroundProcessorDelay = -1; /** * 이 컴포넌트를 위한 컨테이너 이벤트 Listener */ protected ArrayList listeners = new ArrayList(); ... } . | . | . 오해할 여지가 있는 주석 . | 오해할 여지가 있는 주석으로, 오류 발생시 오류의 원인을 다른 곳에서 찾게되어 시간이 더 소요될 수 있다. 떄떄로 의도는 좋았으나 프로그래머가 딱 맞을 정도로 엄밀하게 주석을 달지 못하기도 한다. (코드보다 읽기도 어려운) 주석에 담긴 “살짝 잘못된 정보”로 인해 어느 프로그래머가 경솔하게 함수를 호출할지도 모른다. | 예시 // this.closed가 true일 때 반환되는 유틸리티 메서드다. // 타임아웃에 도달하면 예외를 던진다. public synchronized void waitForClose(final long timeoutMillis) throws Exception{ if(!closed){ wait(timeoutMillis); if(!closed){ throw new Exception(\"MockResponseSender could not be closed\"); } } } . | . 의무적으로 다는 주석 . | 모든 함수에 javadocs를 넣는 규칙은 안좋다. 모든 함수에 javadocs를 달거나 모든 변수에 주석을 달아야 한다는 규칙은 어리석기 그지없다. 이런 주석은 코드를 복합하게 만들며, 거짓말을 퍼뜨리고, 혼동과 무질서를 초래한다. | . 이력을 기록하는 주석 . | 과거엔 모든 모듈 첫머리에 변경 이력을 관리하는게 바람직했지만 지금은 소스 관리 시스템을 이용하자. 예전에는 모든 모듈 첫 머리에 변경 이력을 관리하는 관례가 바람직 했다. 당시에는 소스 코드 관리 시스템이 없었으니까. 하지만 이제는 혼란만 가중할 뿐이다. 완전히 제거하는 편이 좋다. | 예시 ```java /** | 변경이력 | . | 11-Oct-2001 : 클래스를 다시 정리하고 새로운 패키지인 com.jrefinery.data로 옮겼다 (DG); … ``` | . 있으나 마나 한 주석 . | 너무 당연한 내용을 알려주는 주석 너무 당연한 사실을 언급하며 새로운 정보를 제공하지 못하는 주석 위와 같은 주석은 지나친 참견이라 개발자가 주석을 무시하는 습관에 빠진다. 있으나 마나 한 주석을 달려는 유혹에 벗어나 코드를 정리하라. 더 낫고, 행복한 프로그래머가 되는 지름길이다. | 예시 ```java /** . | 기본 생성자 */ protected AnnualDateRule(){ } ``` | . | . 무서운 잡음 . | javadocs를 꼭 제공해야한다는 생각으로 copy,paste를 이용해 작성하면 잡음이 생길 수 있다. 오히려 작성하지 않는 것이 좋다. | 예시 . /** the name */ private String name; /** the version */ -&gt; 중복 private String version; /** the licenceName */ private String licenceName; /** the version */ -&gt; 중복 private String info; . | . 함수나 변수로 표현할 수 있다면 주석을 달지 마라 . | 주석을 코드로 작성할 수 있으면 코드로 작성하자. 하지만 위와 같이 주석이 필요하지 않도록 코드를 개선하는 편이 더 좋았다. | 예시 . | 이전 // 전역 목록 &lt;smodule&gt;에 속하는 모듈은 우리가 속한 하위 시스템에 의존하는가? if(smodule.getDependSubsystems().contains(subSysMod.getSubSystem())) . | 이후 ArrayList moduleDependenees = smodule.getDependSubsystems(); String ourSubsystem = subSysMod.getSubsystem(); if (moduleDependees.contains(ourSubSystem)) . | . | . 위치를 표시하는 주석 . | 위치를 표시하기 위해 배너를 사용하는데, 반드시 필요할 때만 드물게 사용하자 너무 자주 사용하지 않는다면 배너는 눈에 띄며 주의를 환기한다. 그러므로 반드시 필요할 때만, 아주 드물게 사용하는 편이 좋다. 배너를 남용하면 독자가 흔한 잡음으로 여겨 무시한다. | 예시 // Actions ///////////////////////////////////////////////////////// . 닫는 괄호에 다는 주석 . | 중첩이 심한 경우 닫는 괄호에 주석을 달아놓는데, 주석보다 중첩을 제거하자. 그러므로 닫는 괄호에 주석을 달아야겠다는 생각이 든다면 대신에 함수를 줄이려 시도하자. | . 공로를 돌리거나 저자를 표시하는 주석 . | 저자를 표시하려는 주석은 소스 코드관리 시스템을 이용하자. 소스 코드 관리 시스템은 누가 언제 무엇을 추가했는지 귀신처럼 기억한다. 저자의 이름으로 코드를 오염시킬 필요가 없다. 위와 같은 정보는 소스 코드 관리 시스템에 저장하는 편이 좋다. | . 주석으로 처리한 코드 . | 주석으로 처리된 코드는 삭제하고, 소스 코드 관리 시스템을 이용하자. 하지만 우리는 오래전부터 우수한 소스 코드 관리 시스템을 사용해왔다. 소스 코드 관리 시스템이 우리를 대신해 코드를 기억해준다. | . HTML 주석 . | 주석을 뽑아 웹페이지에 올릴 작정이라면 HTML태그는 도구가 삽입해야한다. (javadocs와 같은) 도구로 주석을 뽑아 웹 페이지에 올릴 작정이라면 주석에 HTML 태그를 삽입해야 하는 책임은 프로그래머가 아니라 도구가 져야한다. | . 전역 정보 . | 주석은 전역정보가 아닌 근처에 있는 코드만 기술하라. 주석을 달아야 한다면 근처에 있는 코드만 기술하라. 코드 일부에 주석을 달면서 시스템의 전반적인 정보를 기술하지 마라. | 예시: 함수는 포트 기본값을 통제하지 못하는데, 작성되어 있음 | . /** * 적합성 테스트가 동작하는 포트: 기본값은&lt;b&gt;8082&lt;/b&gt; * @param fitnessePort */ public void setFintnessePort(int fitessePort){ this.fitnessePort = finessePort; } . 너무 많은 정보 . | 관련 없는 정보(역사 등)은 작성하지 마라. 주석에다 흥미로운 역사나 관련 없는 정보를 장황하게 늘어놓지 마라. | . 모호한 관계 . | 주석과 코드의 관게는 명확해야하고, 코드의 부족한 점이나 외의 관련 있는 부가정보를 제공해 독자가 이해해야한다. 주석과 주석이 설명하는 코드는 둘 사이 관계가 명백해야 한다. 주석을 다는 목적은 코드만으로 설명이 부족해서다. 주석 자체가 다시 설명을 요구하니 안타깝기 그지없다. | 예시: 이 주석과 코드를 보고 이해할 수 없음 . /** * 모든 픽셀을 담을 만큼 충분한 배열로 시작한다(여기에 필터 바이트를 더한다). * 그리고 헤더 정보를 위해 200바이트를 더한다. */ this.pngBytes - new byte[((this.width +1) * this.height *3 ) + 200]; . | . 함수 헤더 . | 짧은 함수은 주석이 필요 없고, 이름을 잘 지은 함수가 주석이 있는 함수보다 좋다. 짧은 함수는 긴 설명이 필요없다. 짧고 한 가지만 수행하며 이름을 잘 붙인 함수가 주석으로 헤더를 추가한 함수보다 훨씬 좋다. | . 비공개 코드에서 javadocs . | 비공개되는 코드라면 javadocs는 필요없다. 공개 API는 javadocs가 유용하지만 공개하지 않을 코드라면 javadocs는 쓸모가 없다. | . 예제 . | 이전 ```java /** . | 이 클래스는 사용자가 지정한 최대 값까지 소수를 생성한다. 사용된 알고리즘은 에라스토테네스의 체다. | -&gt; 삭제 . | 에라스토테네스: 기원전 276년에 리비아 키레네에서 출생, 기원전 194년에 사망, 지구 둘레를 최초로 계산한 사람이자 달력에 윤년을 도입한 사람. -&gt; 삭제 | -&gt; 삭제 . | 알고리즘은 상당히 단순하다. 2에서 시작하는 정수 배열을 대상으로 2의 배수를 모두 제거한다. 다음으로 남은 정수를 찾아 이 정수의 배수를 모두 지운다. | 최대 값의 제곱근이 될 때까지 이를 반복한다. * | @author Apphonse-&gt; 삭제 | @version 13 Fed 2002 atp-&gt; 삭제 / import java.util.; | . public class GeneratePrimes{ public static int[] generatePrimes(int maxValue){ if(maxValue &gt;= 2){ // 유일하게 유효한 경우 -&gt; maxValue &lt;2 인 경우를 먼저 Return // 선언-&gt; 전역으로 변경 int s = maxValue + 1; // 배열 크기 boolean[] f = new boolean[s]; int i; . // 배열을 참으로 초기화 -&gt; uncrossintegersUpTo(int maxValue)로 변경 for(i=0;i&lt;s;i++){ f[i] = true; } // 소수가 아닌 알려진 숫자를 제거 f[0] = f[1] = false; // 체 int j; for (i =2; i&lt;Math.sqrt(s)+1; i++){ if(f[i]){ // i가 남아있는 숫자라면 이 숫자의 배수를 구한다. for(j = 2 * i; j&lt;s; j+=i) f[j] = false; // 배수는 소수가 아니다. } } // 소수의 개수는? int count = 0; for(i =0; i&lt;s; i++){ if(f[i]) count++; // 카운트 증가 } int[] primes = new int[count]; // 소수를 결과 배열로 이동한다. for(i = 0, j=0; i&lt;s; i++){ if(f[i]) // 소수일 경우에 primes[j++] = i; } return primes; // 소수를 반환한다. } else // maxValue &lt; 2 return new int[0]; // 입력이 잘못되면 비어있는 배열을 반환한다. } } . | 이후 | . /** * 이 클래스는 사용자가 지정한 최대 값까지 소수를 구한다. * 알고리즘은 에라스토테네스의 체다. * 2에서 시작하는 정수 배열을 대상으로 작업한다. * 처음으로 남아 있는 정수를 찾아 배수를 모두 제거한다. * 배열에 더 이상 배수가 없을 때까지 반복하낟. */ public class PrimeGenerator{ private static boolean[] crossedOut; private static int[] result; public static int[] generatePrimes(int maxValue){ if(maxValue &lt; 2) reutrn new int[0]; else{ uncoressIntegersUpTo(maxValue); crossOutMultiples(); putUncressedIntegerIntoResult(); return result; } } private static void uncrossIntegersUpTo(int maxValue){ crossedOut = new boolean[maxValue + 1]; for(int i =2; i&lt; croessedOut.length ; i++) crossedOut[i] = false; } private static void coressOutMultiples(){ int limit = determineIterationLimit(); for(int i=2; i &lt;=limit; i++) if(notCrossed(i)) crossOutMultiplesOf(i); } private static int determineIterationLimit(){ // 배열에 있는 모든 배수는 배열의 크기의 제곱근보다 작은 소수의 인수다. // 따라서 이 제곱근보다 더 큰 숫자의 배수는 제거할 필요가 없다. double iterationLimit = Math.sqrt(crossedOut.length); return (int) iterationLimit; } private static void crossOutMultiplesOf(int i){ for(int multiple = 2*1;multiple &lt; crossedOut.length;mulitple +=i;) crossedOut[multiple] = true; } private static boolean notCrossed(int i){ return crossedOut[i] == false; } private static void putUncrossedIntegersIntoResult(){ for(int j=0, i=2; i&lt;crossedOut.length; i++) if(notCrossed(i)) result[j++] = i; } private static int numberOfUncrossedIntegers(){ int count =0; for(int i =2; i &lt; crossedOut.lenghth;i++) if (notCrossed(i)) count++; return count; } } . ",
    "url": "/chapter4-annotation.html#%EB%82%98%EC%81%9C-%EC%A3%BC%EC%84%9D",
    
    "relUrl": "/chapter4-annotation.html#나쁜-주석"
  },"110": {
    "doc": "4장 주석",
    "title": "요약",
    "content": ". | 주석은 프로그래머가 계속해서 유지하고 보수하기가 힘들기 때문에 잘못된 정보를 전달할 가능성이 높고, 외에도 가독성을 해치는 경우가 있을 수 있다. | 코드를 잘 작성한다면 대부분의 주석은 코드로 작성할 수 있기 때문에, 주석을 작성하는 것보다 코드를 수정하는 방향이 좋다. | 달아야하는 주석: 항상 유의해서 주석을 추가해야한다. | 법적인 주석 | 의미나 의도를 명료하게 알려주는 주석 | 놓칠 수 있는 부분을 강조하는 주석 | TODO 주석 | 공개 API의 javadocs | . | 삭제해야하는 주석 . | 소스 코드 관리 시스템으로 대체 가능한 주석 -&gt; 삭제 후 소스 코드 관리 시스템 이용 . | e.g. 저자 기록, 코드 수정 기록, 사용하지 않는 코드 등 | . | 주석으로써 필요한 정보가 아닌 주석 -&gt; 삭제 . | e.g. 코드와 같은 내용, 의무적인 javadocs, 비공개 코드의 javadocs, 전역 정보, 위치 표시, 너무 많은 정보, 닫는 괄호 주석, 너무 당연한 내용 등 | . | 코드로 작성할 주석 -&gt; 코드를 변경함으로써 주석을 사용하지 않음 . | e.g. 함수 헤더 등 | . | . | 주의점 . | 되도록이면 작성하지 말기 | 항상 주석을 작성할 때에는 의미를 빠르게 알 수 있도록, 필요한 내용만 명확하게 잘 작성하기 | 작성된 주석은 코드와 같이 항상 유지보수하기 | . | . ",
    "url": "/chapter4-annotation.html#%EC%9A%94%EC%95%BD",
    
    "relUrl": "/chapter4-annotation.html#요약"
  },"111": {
    "doc": "5장 형식 맞추기",
    "title": "5장 형식 맞추기",
    "content": " ",
    "url": "/chapter5-consistent-formatting%20.html",
    
    "relUrl": "/chapter5-consistent-formatting%20.html"
  },"112": {
    "doc": "5장 형식 맞추기",
    "title": "형식을 맞추는 목적",
    "content": "형식은 의사소통이다 . | 코드는 문서이며, 개발자 간의 의사소통 수단이다. | 오늘 구현한 코드는 내일 수정 될 수 있다. | → 가독성은 유지보수성과 직결된다. | . | . ",
    "url": "/chapter5-consistent-formatting%20.html#%ED%98%95%EC%8B%9D%EC%9D%84-%EB%A7%9E%EC%B6%94%EB%8A%94-%EB%AA%A9%EC%A0%81",
    
    "relUrl": "/chapter5-consistent-formatting%20.html#형식을-맞추는-목적"
  },"113": {
    "doc": "5장 형식 맞추기",
    "title": "적절한 행 길이를 유지하라",
    "content": "행 길이는 반드시 지킬 엄격한 규칙은 아니지만 일반적으로 큰 파일보다 작은 파일이 이해하기 쉽다. | 짧고 명확한 단위로 나눈다. | 일반적으로 한 파일은 200줄 이내가 바람직하다. | . 신문 기사처럼 작성하라 . 신문의 표제는 최상단에서 기사 내용을 몇 마디로 요약한다. 소스 파일도 신문 기사와 비슷하게 작성하는 것이 좋다. | 가장 중요한 내용 → 세부사항 순서. | 상단에는 고차원 개념, 아래로 갈수록 세부 구현. | . | 파일명과 클래스명만 보고 역할을 파악할 수 있어야 한다. | . 개념은 빈 행으로 분리하라 . 각 행은 수식이나 절을 나타내고, 일련의 행 묶음은 완결된 생각 하나를 표현한다. 관련된 코드끼리는 묶고, 서로 다른 개념은 빈 줄로 구분한다. 👍👍👍 . package fitnesse.wikitext.widgets; import java.util.regex.Matcher; import java.util.regex.Pattern; public class BoldWidget extends ParentWidget { public static final String REGEXP = \"'''.+?'''\"; private static final Pattern pattern = Pattern.compile(\"'''(.+?)'''\", Pattern.MULTILINE + Pattern.DOTALL ); public BoldWidget(ParentWidget parent, String text) throws Exception { super(parent); Matcher match = pattern.matcher(text); match.find(); addChildWidgets(match.group(1)); } } . 👎👎👎 . package fitnesse.wikitext.widgets; import java.util.regex.Matcher; import java.util.regex.Pattern; public class BoldWidget extends ParentWidget { public static final String REGEXP = \"'''.+?'''\"; private static final Pattern pattern = Pattern.compile(\"'''(.+?)'''\", Pattern.MULTILINE + Pattern.DOTALL); public BoldWidget(ParentWidget parent, String text) throws Exception { super(parent); Matcher match = pattern.matcher(text); match.find(); addChildWidgets(match.group(1));} } . 세로 밀집도(연관성) . 서로 밀접한 코드는 세로로 가까이 배치한다. 👍👍👍 . public class ReporterConfig { private String m_className; private List&lt;Property&gt; m_properties = new ArrayList&lt;Property&gt;(); public void addProperty(Property property) { m_properties.add(property); } . 👎👎👎 . public class ReporterConfig { /** * 리포터 리스너의 클래스 이름 */ private String m_className; /** * 리포터 리스너의 속성 */ private List&lt;Property&gt; m_properties = new ArrayList&lt;Property&gt;(); public void addProperty(Property property) { m_properties.add(property); } . 수직 거리 . 관련 있는 코드끼리는 물리적으로 가까워야 이해하기 쉽다. | 무엇을 하는지 이해하기 위해 탐색할 때 조각 조각들이 어디에 있는지 찾기 쉽다. | protected, 상속 관계..👎 | . | . 같은 파일에 속할 정도로 밀접한 두 개념은 세로 거리로 연관성을 표현한다. | 변수 선언 . | 변수는 사용하는 위치에 최대한 가까이 선언한다. | 지역 변수는 각 함수 맨 처음에 선언한다. private static void readPreferences() { InputStream is = null; try { is = new FileInputStream(getPreferencesFile()); setPreferences(new Properties(getPreferences())); getPreferences().load(is); } catch (IOException e) { try { if (is != null) is.close(); } catch (IOException e1) { } } } . | loop문 제어 변수는 loop문 내부에 선언 . public int countTestCases() { int count = 0; for (Test each : tests) count += each.countTestCases(); return count; } . | . | 인스턴스 변수 . | 인스턴스 변수를 선언하는 위치는 잘 알려진 위치여야 한다. | 클래스 맨 처음에 선언한다. | . | 메서드 중간에 숨겨두지 않는다. | . | 종속 함수 . | 한 함수가 다른 함수를 호출한다면 두 함수는 세로로 가까이 배치한다. | 호출하는 함수를 호출되는 함수보다 먼저 배치한다. | 이 규칙이 일관적으로 적용되면 독자는 방금 호출된 함수가 곧 정의될 거라 예측할 수 있고, 자연스럽게 코드를 읽을 수 있다. | . public class WikiPageResponder implements SecureResponder { protected WikiPage page; protected PageData pageData; protected String pageTitle; protected Request request; protected PageCrawler crawler; // 호출 → 정의 순서로 배치 public Response makeResponse(FitNesseContext context, Request request) throws Exception { String pageName = getPageNameOrDefault(request, \"FrontPage\"); loadPage(pageName, context); } private String getPageNameOrDefault(Request request, String defaultPageName) { String pageName = request.getResource(); if (StringUtil.isBlank(pageName)) pageName = defaultPageName; return pageName; } protected void loadPage(String resource, FitNesseContext context) throws Exception { WikiPagePath path = PathParser.parse(resource); crawler = context.root.getPageCrawler(); crawler.setDeadEndStrategy(new VirtualEnabledPageCrawler()); page = crawler.getPage(context.root, path); if (page != null) pageData = page.getData(); } ... | . | 개념적 유사성 . 비슷한 역할/이름/구조를 가진 함수는 근접 배치한다. | 친화도가 높은 요인 . | 다른 함수를 호출해 생기는 직접적인 종속성 | 변수와 그 변수를 사용하는 함수 | 비슷한 동작을 수행하는 함수 . class Assert { static public void assertTrue(String message, boolean condition) { if (!condition) fail(message); } static public void assertTrue(boolean condition) { assertTrue(null, condition); } static public void assertFalse(String message, boolean condition) { assertTrue(message, !condition); } static public void assertFalse(boolean condition) { assertFalse(null, condition); } ... // 명명법이 같고 기본 기능이 유사하다. | . | . | . | 개념 | 위치 기준 | . | 지역 변수 | 사용하는 코드와 최대한 가까이 | . | 루프 제어 변수 | 루프문 내부에서 선언 | . | 인스턴스 변수 | 클래스 맨 위에 모아서 선언 | . | 종속 함수 | 호출하는 함수 위에 배치 | . 세로 순서 . | 함수 호출 종속성은 아래 방향으로 유지한다. (고차원 추상화→ 저차원 추상화) | 표제, 가장 중요한 개념을 가장 먼저 표현한다. | 표제는 세세한 사항을 최대한 배제한다. | . | . ",
    "url": "/chapter5-consistent-formatting%20.html#%EC%A0%81%EC%A0%88%ED%95%9C-%ED%96%89-%EA%B8%B8%EC%9D%B4%EB%A5%BC-%EC%9C%A0%EC%A7%80%ED%95%98%EB%9D%BC",
    
    "relUrl": "/chapter5-consistent-formatting%20.html#적절한-행-길이를-유지하라"
  },"114": {
    "doc": "5장 형식 맞추기",
    "title": "가로 형식 맞추기",
    "content": "가급적 한 줄 80~120자 이내로 제한한다. → 긴 줄은 읽기 어렵고, 리뷰/디버깅 시 불편함. 가로 공백과 밀집도 . 밀집도는 가로 공백을 사용해서 느슨함을 표현한다. private void measureLine(String line) { lineCount++; // 공백으로 할당 연산자 강조 -&gt; 왼쪽과 오른쪽 구분이 분명해짐 int lineSize = line.length(); totalChars += lineSize; // 함수명과 괄호 사이에는 공백을 넣지 않는다. -&gt; 함수와 인수의 밀접함을 표현 // 공백으로 쉼표 강조 -&gt; 별개의 인수 강조 lineWidthHistogram.addLine(lineSize, lineCount); recordWidestLine(lineSize); } . 가로 정렬 . 과도한 정렬은 지양한다. | 가독성을 해치고, 작은 수정에도 정렬 전체가 깨짐. | 타입/변수명/할당 연산자 기준으로 줄맞춤을 시도하지 말 것. | . 👎👎👎 . public class FitNesseExpediter implements ResponseSender { // 변수 유형은 무시하고 이름만 읽게 됨 private Socket socket; private InputStream input; private OutputStream output; private Reques request; private Response response; private FitNesseContex context; protected long requestParsingTimeLimit; private long requestProgress; private long requestParsingDeadline; private boolean hasError; // 할당 연산자는 보이지 않고 오른쪽 피연산자만 보임 public FitNesseExpediter(Socket s ,FitNesseContext context) throws Exception { this.context = context; socket = s; input = s.getInputStream(); output = s.getOutputStream(); requestParsingTimeLimit = 10000; } . 위와 같은 정렬은 코드가 엉뚱한 부분을 강조해서 진짜 의도가 가려지기 때문에 유용하지 않다. 👍👍👍 . public class FitNesseExpediter implements ResponseSender { private Socket socket; private InputStream input; private OutputStream output; private Request request; private Response response; private FitNesseContex context; protected long requestParsingTimeLimit; private long requestProgress; private long requestParsingDeadline; private boolean hasError; public FitNesseExpediter(Socket s,FitNesseContext context) throws Exception { this.context = context; socket = s; input = s.getInputStream(); output = s.getOutputStream(); requestParsingTimeLimit = 10000; } . 들여쓰기 . 소스파일은 윤곽도와 계층이 비슷하다. | 파일 전체에 적용되는 정보 | 파일 내 개별 클래스에 적용되는 정보 | 클래스 내 각 메서드에 적용되는 정보 | 블록 내 블록에 재귀적으로 적용되는 정보 | . 계층에서 각 수준은 이름을 선언하는 범위이자 선언문과 실행문을 해석하는 범위이다. 이 범위(scope)를 표현하기 위해 들여쓰기를 사용한다. 들여쓰기를 통해 왼쪽으로 코드를 맞춰 코드가 속하는 범위를 시각적으로 표현한다. 👎👎👎 . public class CommentWidget extends TextWidget { public static final String REGEXP = \"^#[^\\r\\n]*(?:(?:\\r\\n)|\\n|\\r)?\"; public CommentWidget(ParentWidget parent, String text){super(parent, text);} public String render() throws Exception {return \"\"; } } . 👍👍👍 . public class CommentWidget extends TextWidget { public static final String REGEXP = \"^#[^\\r\\n]*(?:(?:\\r\\n)|\\n|\\r)?\"; public CommentWidget(ParentWidget parent, String text){ super(parent, text); } public String render() throws Exception { return \"\"; } } . 가짜 범위 . | if, while, for 뒤에 오는 아무 동작도 하지 않는 빈 문장(세미콜론 ;)이 오는 경우 | . 👎👎👎 . // while은 세미콜론 하나가 루프 본문처럼 동작 // → 루프는 실행되지만 아무 일도 안 함 while (inputStream.read() != -1); // for 뒤에 ;가 있어 루프 내부가 없음 // → 실제 블록은 루프 외부이며 단 한 번만 실행 for (int i = 0; i &lt; 10; i++); { System.out.println(\"This only runs once!\"); } . | ; 하나가 본문으로 처리됨 → 읽기 어렵고, 실수로 작성된 것처럼 보임 | . 👍👍👍 . while (inputStream.read() != -1) ; // intentionally empty // 예: 딜레이 (busy wait) CPU를 소모하면서 일정 시간 대기 for (long wait = 0; wait &lt; 1_000_000L; wait++) ; // intentional delay . | 주석으로 의도 명시 | 들여쓰기로 가독성 개선 | . | ❌ 삭제해야 할 경우 | ✅ 유지할 수 있는 경우 | . | 실수로 세미콜론이 들어간 경우 | 스트림을 소비하거나 busy-wait처럼 명확한 목적이 있는 경우 | . | 루프 내부에 실행 코드가 빠진 경우 | 동작이 없어야만 하는 루프일 때 (단, 주석 필수) | . ",
    "url": "/chapter5-consistent-formatting%20.html#%EA%B0%80%EB%A1%9C-%ED%98%95%EC%8B%9D-%EB%A7%9E%EC%B6%94%EA%B8%B0",
    
    "relUrl": "/chapter5-consistent-formatting%20.html#가로-형식-맞추기"
  },"115": {
    "doc": "5장 형식 맞추기",
    "title": "팀 규칙",
    "content": "각자 선호하는 규칙이 있겠지만 팀에 속해있다면 팀 규칙을 따라야 한다. 그래야 소프트웨어가 일관적인 스타일을 가질 수 있다. 스타일이 일관적이고 매끄러워야 독자에게 신뢰감을 줄 수 있다. ",
    "url": "/chapter5-consistent-formatting%20.html#%ED%8C%80-%EA%B7%9C%EC%B9%99",
    
    "relUrl": "/chapter5-consistent-formatting%20.html#팀-규칙"
  },"116": {
    "doc": "7장 오류 처리",
    "title": "7장 오류 처리",
    "content": "깨끗한 코드를 다루는 책에 오류 처리를 논하는 장이 있어 이상하게 여길지도 모르겠다. 하지만 깨끗한 코드와 오류 처리는 확실히 연관성이 있다. 만약 오류 처리 코드로 인해 프로그램 논리를 이해하기 어려워진다면 깨끗한 코드라 부르기 어렵다. 따라서 이 장에서는 깨끗하고 튼튼한 코드에 한걸음 더 다가가는 단계로 우아하고 고상하게 오류를 처리하는 기법과 고려 사항 몇 가지를 소개한다. ",
    "url": "/chapter7-error-handling.html",
    
    "relUrl": "/chapter7-error-handling.html"
  },"117": {
    "doc": "7장 오류 처리",
    "title": "오류 코드보다 예외를 사용하라",
    "content": "얼마 전까지만 해도 예외를 지원하지 않는 프로그래밍 언어가 많았다. 예외를 지원하지 않는 언어는 오류를 처리하고 보고하는 방법이 제한적이었다. 오류 플래그를 설정하거나 호출자에게 오류 코드를 반환하는 방법이 전부였다. 목록 7-1은 오류를 호출자 코드에서 처리한다. // 목록 7-1 DeviceController.java public class DeviceController { /*...*/ public void sendShutDown() { DeviceHandle handle = getHandle(DEV1); // 디바이스 상태를 점검한다. if (handle != DeviceHandle.INVALID) { // 레코드 필드에 디바이스 상태를 저장한다. retrieveDeviceRecord(handle); // 디바이스가 일시정지 상태가 아니라면 종료한다. if (record.getStatus() != DEVICE_SUSPENDED) { pauseDevice(handle); clearDeviceWorkQueue(handle); closeDevice(handle); } else { // 오류 처리 logger.log(\"Device suspended. Unable to shut down\"); } } else { // 오류 처리 logger.log(\"Invalid handle for: \" + DEV1.toString()); } } } . 위와 같은 방법을 사용하면 호출자 코드가 복잡해진다. 함수를 호출한 즉시 오류를 확인해야 하기 때문이다. 그래서 오류가 발생하면 예외를 던지는 편이 낫다. 그러면 논리와 오류 처리 코드가 분리되어, 호출자 코드가 더 깔끔해진다. 목록 7-2는 오류를 발견하면 예외를 던지는 코드다. // 목록 7-2 DeviceController.java (예외 사용) public class DeviceController { /*...*/ public void sendShutDown() { try { // 논리 처리 tryToShutDown(); } catch (DeviceShutDownError e) { // 오류 처리 logger.log(e); } } private void tryToShutDown() throws DeviceShutDownError { DeviceHandle handle = getHandle(DEV1); DeviceRecord record = retrieveDeviceRecord(handle); pauseDevice(handle); clearDeviceWorkQueue(handle); closeDevice(handle); } private DeviceHandle getHandle(DeviceID id) { /*...*/ throw new DeviceShutDownError(\"Invalid handle for: \" + id.toString()); /*...*/ } } . 코드가 확실히 깨끗해졌고, 품질도 나아졌다. 앞서 뒤섞였던 즉 디바이스를 종료하는 알고리즘과 오류를 처리하는 알고리즘을 분리했다. 이제는 각 개념을 독립적으로 살펴보고 이해할 수 있다. ",
    "url": "/chapter7-error-handling.html#%EC%98%A4%EB%A5%98-%EC%BD%94%EB%93%9C%EB%B3%B4%EB%8B%A4-%EC%98%88%EC%99%B8%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%9D%BC",
    
    "relUrl": "/chapter7-error-handling.html#오류-코드보다-예외를-사용하라"
  },"118": {
    "doc": "7장 오류 처리",
    "title": "Try-Catch-Finally 문부터 작성하라",
    "content": "try-catch-finally 문에서 try 블록에 들어가는 코드를 실행하면 어느 시점에서든 실행이 중단된 후 catch 블록으로 넘어갈 수 있다. 어떤 면에서 try 블록은 트랜잭션과 비슷하다. try 블록에서 무슨 일이 생기든 지 catch 블록은 프로그램 상태를 일관성 있게 유지해야 한다. 그러므로 예외가 발생할 코드를 짤 때는 try-catch-finally 문으로 시작하는 편이 낫다. 그러면 try 블록에서 무슨 일이 생기든지 호출자가 기대하는 상태를 정의하기 쉬워진다. 예제를 살펴보자. 최종적으로파일을 열어 직렬화된 객체 몇 개를 읽어 들이는 코드가 필요하다. 다음은 파일이 없으면 예외를 던지는지 알아보는 단위 테스트다. @Test(expected = StorageException.class) public void retrieveSectionShouldThrowOnInvalidFileName() { sectionStore.retrieveSection(\"invalid - file\"); } . 위의 단위 테스트에 맞춰 다음 코드를 구현했다. public List&lt;RecordedGrip&gt; retrieveSection(String sectionName) { // 실제로 구현할 때까지 비어 있는 더미를 반환한다. return new ArrayList&lt;RecordedGrip&gt;(); } . 그런데 코드는 예외를 던지지 않으므로 단위 테스트 또한 실패한다. 예외를 던지도록 try 블록과 catch 블록을 추가해보자. public List&lt;RecordedGrip&gt; retrieveSection(String sectionName) { try { FileInputStream stream = new FileInputStream(sectionName); } catch (Exception e) { throw new StorageException(\"retrieval error\", e); } return new ArrayList&lt;RecordedGrip&gt;(); } . 이제 코드는 예외를 던지므로 단위 테스트 또한 성공한다. 이 시점에서 리팩터링이 가능하다. catch 블록에서 예외 유형을 Exception 에서 FileNotFoundException으로 좁혀 FileInputStream 생성자가 던지는 FileNotFoundException을 잡아낸다. public List&lt;RecordedGrip&gt; retrieveSection(String sectionName) { try { FileInputStream stream = new FileInputStream(sectionName); stream.close(); } catch (FileNotFoundException e) { throw new StorageException(\"retrieval error\", e); } return new ArrayList&lt;RecordedGrip&gt;(); } . 이처럼 먼저 강제로 예외를 일으키는 테스트 케이스를 작성한 후 테스트를 통과하게 코드를 작성하는 방법을 권장한다. 그러면 자연스럽게 try 블록의 트랜잭션 범위부터 구현하게 되므로 범위 내에서 트랜잭션 본질을 유지하기 쉬워진다. ",
    "url": "/chapter7-error-handling.html#try-catch-finally-%EB%AC%B8%EB%B6%80%ED%84%B0-%EC%9E%91%EC%84%B1%ED%95%98%EB%9D%BC",
    
    "relUrl": "/chapter7-error-handling.html#try-catch-finally-문부터-작성하라"
  },"119": {
    "doc": "7장 오류 처리",
    "title": "미확인(unchecked)예외를 사용하라",
    "content": "자바 첫 버전이 확인된 예외를 선보였던 당시 확인된 예외는 멋진 아이디어로 여겨졌다. 메서드를 선언할 때는 메서드가 반환할 예외를 모두 열거했다. 게다가 메서드가 반환하는 예외는 메서드 유형의 일부였다. 코드가 메서드를 사용하는 방식이 메서드 선언과 일치하지 않으면 아예 컴파일도 못했다. 확인된 예외는 여러 장점을 제공하지만, 지금은 안정적인 소프트웨어를 제작하는 요소로 확인된 예외가 반드시 필요하지 않다는 사실이 분명해졌다. 그러므로 우리는 확인된 오류가 치르는 비용 대비 그에 상응하는 이익을 제공하는지 따져봐야한다. 확인된 예외는 OCP(“소프트웨어 요소는 확장에는 열려 있으나 변경에는 닫혀 있어야 한다”는 원칙)를 위반한다. 어떤 메서드에서 확인된 예외를 던졌는데 catch 블록이 세 단계 위에 있다면 그 사이 모든 메서드 선언부에 해당 예외를 정의해야한다. 즉, 하위 단계에서 코드 변경이 일어나면 상위 단계를 모두 고쳐야한다는 말이다. 이러한 상황이 대규모 시스템에서 어떻게 작용하는지 상상해보자. 최상위 함수부터 최하위 함수까지 단계를 내려갈수록 호출하는 함수 수는 늘어날 것이다. 만일 최하위 함수에서 확인된 예외를 던진다고 가정해보자. 그렇다면 해당 함수의 선언부에는 throw 절이 추가될 것이다. 그렇다면 이제 해당 최하위 함수를 호출하는 함수와 그 함수를 호출하는 함수 … 최상위 함수까지 함수 모두가 1) catch 블록에서 새로운 예외를 처리하거나 2) 선언부에 throw 절을 추가해야한다. 최하위 단계의 확인된 예외를 처리하기 위해 이 모든 연쇄 수정이 일어나는 것이다. 당연히 모든 함수가 최하위 함수에서 던지는 예외를 알아야 하므로 캡슐화 또한 깨지게 된다. ",
    "url": "/chapter7-error-handling.html#%EB%AF%B8%ED%99%95%EC%9D%B8unchecked%EC%98%88%EC%99%B8%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%9D%BC",
    
    "relUrl": "/chapter7-error-handling.html#미확인unchecked예외를-사용하라"
  },"120": {
    "doc": "7장 오류 처리",
    "title": "예외에 의미를 제공하라",
    "content": "예외를 던질 때는 전후 상황을 충분히 덧붙인다. 그러면 오류가 발생한 원인과 위치를 찾기가 쉬워진다. 자바는 모든 예외에 호출 스택을 제공하긴 하지만, 이것으로 실제 의도를 파악하기엔 부족하다. 오류 메시지에 정보를 담아 예외와 함께 던진다. 실패한 연산 이름과 실패 유형도 언급한다. 애플리케이션이 로깅 기능을 사용한다면 catch 블록에서 오류를 기록한다. ",
    "url": "/chapter7-error-handling.html#%EC%98%88%EC%99%B8%EC%97%90-%EC%9D%98%EB%AF%B8%EB%A5%BC-%EC%A0%9C%EA%B3%B5%ED%95%98%EB%9D%BC",
    
    "relUrl": "/chapter7-error-handling.html#예외에-의미를-제공하라"
  },"121": {
    "doc": "7장 오류 처리",
    "title": "호출자를 고려해 예외 클래스를 정의하라",
    "content": "오류를 분류하는 방법은 수없이 많을 수 있다. 애플리케이션에서 오류를 정의할 때 가장 중요한 관심사는 오류를 잡아내는 방법이 되어야한다. 다음은 오류를 형편없이 분류한 사례다. 외부 라이브러리를 호출하는데, 라이브러리가 던질 예외를 모두 잡아낸다. ACMEPort port = new ACMEPort(12); try { port.open(); } catch (DeviceResponseException e) { reportPortError(e); logger.log(\"Device response exception\", e); } catch (ATM1212UnlockedException e) { reportPortError(e); logger.log(\"Unlock exception\", e); } catch (GMXError e) { reportPortError(e); logger.log(\"device response exception\"); } finally { /*...*/ } . 대다수의 상황에서 오류를 처리하는 방식은 다음과 같이 비교적 일정하다. 1) 오류를 기록한다. 2) 프로그램을 계속 수행해도 좋은지 확인한다. 위 경우는 예외 유형과 무관하게 거의 동일하게 예외에 대응하는 방식이다. 그래서 코드를 간결하게 고치기 쉽다. 예외를 처리하는 역할을 하는 클래스로 외부 라이브러리를 감싸, 예외 유형 하나만 반환하게 한다. LocalPort port = new LocalPort(12); try { port.open(); } catch (PortDeviceFailure e) { reportError(e); logger.log(e.getMessage(), e); } finally { /*...*/ } . 여기서 LocalPort 클래스는 단순히 ACMEPort 클래스가 던지는 예외를 잡아변환하는 wrapper 클래스일 뿐이다. public class LocalPort { private ACMEPort innerPort; public LocalPort(int portNumber) { innerPort = new ACMEPort(portNumber); } public void open() { try { innerPort.open(); // 예외 처리 } catch (DeviceResponseException e) { throw new PortDeviceFailure(e); } catch (ATM1212UnlockedException e) { throw new PortDeviceFailure(e); } catch (GMXError e) { throw new PortDeviceFailure(e); } } } . 이러한 wrapper 클래스는 매우 유용하다. 실제로 외부 라이브러리를 사용할 때는 감싸기 기법이 최선이다. 외부 라이브러리와 프로그램의 의존성이 크게 줄어들기 때문이다. 또한 테스트하기 쉬워지는데, 외부 라이브러리르 직접 호출하는 대신 해당 wrapper 클래스에 테스트 코드를 넣어주면 되기 때문이다. 흔히 예외 클래스가 하나만 있어도 충분한 코드가 많다. 한 예외는 잡아내고 다른 예외는 무시해도 괜찮은 경우라면 여러 예외 클래스를 사용한다. ",
    "url": "/chapter7-error-handling.html#%ED%98%B8%EC%B6%9C%EC%9E%90%EB%A5%BC-%EA%B3%A0%EB%A0%A4%ED%95%B4-%EC%98%88%EC%99%B8-%ED%81%B4%EB%9E%98%EC%8A%A4%EB%A5%BC-%EC%A0%95%EC%9D%98%ED%95%98%EB%9D%BC",
    
    "relUrl": "/chapter7-error-handling.html#호출자를-고려해-예외-클래스를-정의하라"
  },"122": {
    "doc": "7장 오류 처리",
    "title": "정상 흐름을 정의하라",
    "content": "앞선 지침을 따른다면 비즈니스 논리와 오류 처리가 잘 분리된 깨끗한 코드가 나온다. 하지만 그러다 보면 오류 감지가 프로그램 언저리로 밀려난다. 외부 라이브러리를 감싸 독자적인 예외를 던지고, 코드 위에 처리기를 정의해 중단된 계산을 처리한다. 대개는 멋진 방법이지만, 어떨 때는 중단이 적합하지 않은 때도 있다. 다음 예제는 비용 청구 애플케이션에서 총계를 계산하는 허술한 코드이다. 해당 논리는 식비를 비용으로 청구 했다면 직원이 청구한 식비를 총계에 더하고, 청구하지 않았다면 일일 기본 식비를 총계에 더한다. try { MealExpenses expenses = expenseReportDAO.getMeals(employee.getID()); // 비용 청구 시 m_total += expenses.getTotal(); } catch(MealExpensesNotFound e) { // 청구하지 않았을 시, 일일 기본 식비 m_total += getMealPerDiem(); } . 하지만 예외 처리가 논리를 따라가기 더 어렵게 만든다. 예외가 발생하지 않게, 즉 특수한 상황을 처리할 필요가 없게 만든다면 더 좋지 않을 까? . 다음 예제를 살펴보자. expenseReportDAO를 고쳐 언제나 MealExpenses 객체를 반환토록 한다. 청구한 식비가 없다면 일일 기본 식비를 반환하는 MealExpenses 객체를 반환하면 된다. MealExpenses expenses = expenseReportDAO.getMeals(employee.getID()); m_total += expenses.getTotal(); . // 청구한 식비가 없을 때 반환될 객체 (특수 사례 객체) public class PerDiemMealExpenses implements MealExpenses { public int getTotal() { // 기본값으로 일일 기본 식비를 반환한다. } } . 위와 같은 코드를 특수 사례 패턴이라 부른다. 특수 사례 패턴(Special Case Pattern)은 예외적인 상황을 객체로 캡슐화하여 처리하는 디자인 패턴이다. 이 패턴은 null을 반환하거나 예외를 던지는 대신 특수한 상황을 나타내는 객체를 반환함으로써 클라이언트 코드를 단순화한다. 그러면 클라이언트 코드가 예외적인 상황을 처리할 필요가 없어진다. 클래스나 객체가 예외적인 상황을 캡슐화해서 처리하기 때문이다. ",
    "url": "/chapter7-error-handling.html#%EC%A0%95%EC%83%81-%ED%9D%90%EB%A6%84%EC%9D%84-%EC%A0%95%EC%9D%98%ED%95%98%EB%9D%BC",
    
    "relUrl": "/chapter7-error-handling.html#정상-흐름을-정의하라"
  },"123": {
    "doc": "7장 오류 처리",
    "title": "null을 반환하지 마라",
    "content": "오류 처리를 논하는 장이라면 우리가 흔히 저지르는 바람에 오류를 유발하는 행위도 언급해야 한다고 생각한다. 그 중 첫째가 null을 반환하는 습관이다. 다음은 한 예제이다. public void registerItem(Item item) { if (item != null) { ItemRegistry registry = persistentStore.getItemRegistry(); if (registry != null) { Item existing = registry.getItem(item.getID()); if (existing.getBillingPeriod().hasRetailOwner()) { existing.register(item); } } } } . 위 코드는 한줄 건너 하나씩 null을 체크하고있다. 이는 나쁜 코드이다. 누구 하나라도 null 확인을 빼먹는다면 애플리케이션이 통제 불능에 빠질지도 모른다. 위 코드에서 문제가 발생했다면 null 확인이 누락된 문제라 말하기 쉽다. 하지만 실상은 null 확인이 너무 많아 문제다. 메서드에서 null 을 반환하고 싶은 유혹이 든다면 그 대신 예외를 던지거나 특수 사례 객체를 반환한다. 많은 경우에 특수 사례 객체가 손쉬운 해결책이다. 다음 예제를 살펴보자. getEmployees() 는 null을 반환한다. List&lt;Employee&gt; employees = getEmployees(); if (employees != null) { for (Employee e : employees) { totalPay += e.getPay(); } } . 하지만 getEmployees()가 반드시 null을 반환할 필요가 있을까? 만약 데이터가 없을 때 빈 리스트를 반환하도록 변경한다면 코드는 깔끔해진다. List&lt;Employee&gt; employees = getEmployees(); for (Employee e : employees) { totalPay += e.getPay(); } . ",
    "url": "/chapter7-error-handling.html#null%EC%9D%84-%EB%B0%98%ED%99%98%ED%95%98%EC%A7%80-%EB%A7%88%EB%9D%BC",
    
    "relUrl": "/chapter7-error-handling.html#null을-반환하지-마라"
  },"124": {
    "doc": "7장 오류 처리",
    "title": "null을 전달하지 마라",
    "content": "메서드로 null을 전달하는 방식은 반환하는 것보다 훨씬 나쁘다. 예제를 살펴보면 이유가 드러난다. 다음은 두 지점 사이의 거리를 계산하는 간단한 메서드다. public class MetricsCalculator { public double Projection(Point p1, Point p2) { return (p2.x - p1.x) * 1.5; } } . 누군가 인수로 null을 전달하면 어떤 일이 벌어질까? 당연히 NullPointerException이 발생한다. 하나의 방법으로 다음과 같이 새로운 예외 유형을 만들어 던질수 있다. public class MetricsCalculator { public double Projection(Point p1, Point p2) { if (p1 == null || p2 == null) { // 새로운 예외 유형 throw new InvalidArgumentException( \"Invalid argument for MetricsCalculator.xProjection\"); } return (p2.x - p1.x) * 1.5; } } . 위 코드는 NullPointerException을 발생시키는 기존 코드보다 나을지 몰라도, InvalidArgumentException을 잡아내는 처리기가 필요하다. 다음은 또다른 방법이다. assert문을 사용한다. assert문은 프로그램의 논리적 오류를 감지하고 디버깅하기 위한 Java의 도구이다. public class MetricsCalculator { public double Projection(Point p1, Point p2) { assert p1 != null : \"p1 should not be null\"; assert p2 != null : \"p2 should not be null\"; return (p2.x - p1.x) * 1.5; } } . 이는 문서화가 잘 되어 코드를 읽기는 편하지만 본질적인 문제를 해결하지는 못한다. 여전히 누군가 null을 인수로 넘긴다면 실행 오류가 발생한다. 대다수 프로그래밍 언어는 호출자가 실수로 넘기는 null을 적절히 처리하는 방법이 없다. 즉, 인수로 null이 넘어오면 코드에 문제가 있다는 말이다. ",
    "url": "/chapter7-error-handling.html#null%EC%9D%84-%EC%A0%84%EB%8B%AC%ED%95%98%EC%A7%80-%EB%A7%88%EB%9D%BC",
    
    "relUrl": "/chapter7-error-handling.html#null을-전달하지-마라"
  },"125": {
    "doc": "7장 오류 처리",
    "title": "결론",
    "content": "깨끗한 코드는 읽기도 좋아야 하지만 안정성도 높아야한다. 오류 처리를 프로그램 논리와 분리해 독자적인 사안으로 고려하면 튼튼하고 깨끗한 코드를 작성할 수 있다. 오류 처리를 프로그램 논리와 분리하면 독립적인 추론이 가능해지며 코드 유지보수성도 크게 높아진다. ",
    "url": "/chapter7-error-handling.html#%EA%B2%B0%EB%A1%A0",
    
    "relUrl": "/chapter7-error-handling.html#결론"
  },"126": {
    "doc": "8장 경계",
    "title": "8장 경계",
    "content": "개발할 때 모든 부분을 직접 개발하는 경우는 드물고, 외부 코드(e.g. 오픈 소스, 외부 컴포넌트나 패키지 등)을 이용하는 경우가 많다. 이러한 외부 코드와 우리 코드에 깔끔하게 통합하는 기법과 기교를 살펴본다. | 주요 내용 . | 외부 코드 사용시, 문제가 생기는 이유 | 외부 코드 사용시, 학습 테스트를 이용하는 방법과 이점 | 아직 존재하지 않는 코드 사용시, 경계를 구분하는 방법과 변경에 대한 대응 방법 | . | . ",
    "url": "/chapter8-boundary.html",
    
    "relUrl": "/chapter8-boundary.html"
  },"127": {
    "doc": "8장 경계",
    "title": "외부 코드 사용하기",
    "content": ". | 외부 코드 사용시 문제가 생기는 이유: 제공자와 사용자는 서로 다른 목표를 추구 -&gt; 시스템 경계에서 문제가 생길 수 있음 . | 외부 코드 제공자: 적용성을 늘리려고 노력함 | 외부 코드 사용자: 자신의 요구에 집중하는 인터페이스를 바람 | . 패키지 제공자나 프레임워크 제공자는 적용성을 최대한 넓히려 애쓴다. 더 많은 환경에서 돌아가야 더 많은 고객이 구매하니까. 반면 사용자는 자신의 요구에 집중하는 인터페이스를 바란다. 이런 긴장으로 인해 시스템 경계에서 문제가 생길 소지가 많다. | 예시(java.util.Map): 제공자는 수많은 기능을 제공해 유연성을 높임, 그만큼 위험도 큼 . | case 1: 주고 받는 데이터로 map을 사용한다면, map을 이용하는 코드 어디서든 내용을 지울 수 있어(clear()) 위험 | case 2: 특정 객체만 map에 저장하기로 설계, 그렇지만 map을 이용하는 코드 어디서든 다른 객체 유형도 추가 가능해 위험 | 대안: map을 감싸는 wrapper class를 정의해 사용 -&gt; map과 유사한 인터페이스를 주고 받지 말라는 의미 public class Sensors{ private Map sensors = new HashMap(); public Sensor getById(String id){ return (Sensor) sensors.get(id); } ... } . Map 클래스를 사용할 때마다 위와 같이 캡슐화하라는 소리가 아니다. Map(혹은 유사한 경계 인터페이스를) 여기저기 넘기지 말라는 말이다. Map과 같은 경계 인터페이스를 이용할 때는 이를 이용하는 클래스나 클래스 계열 밖으로 노출되지 않도록 주의한다. Map 인스턴스를 공개 API의 인수로 넘기거나 반환값으로 사용하지 않는다. | . | . ",
    "url": "/chapter8-boundary.html#%EC%99%B8%EB%B6%80-%EC%BD%94%EB%93%9C-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0",
    
    "relUrl": "/chapter8-boundary.html#외부-코드-사용하기"
  },"128": {
    "doc": "8장 경계",
    "title": "경계 살피고 익히기",
    "content": ". | 외부 코드의 테스트를 함으로써 외부 코드의 사용법 익히고 외부 코드를 통합을 진행하자. | 짐 뉴커크의 학습 테스트 . | 바로 우리쪽 코드를 작성해 외부 코드를 호출하는 대신 먼저 간단한 테스트 케이스를 작성해 외부 코드를 익히는 방식 | 사용하려는 방식대로 외부 API를 호출해, 통제도니 환경에서 API를 제대로 이해하는지 확인 외부 코드를 익히기는 어렵다. 외부 코드를 통합하기도 어렵다. 두 가지를 동시에 하기는 두 배나 어렵다. 다르게 접근하면 어떨까? 곧바로 우리쪽 코드를 작성해 외부 코드를 호출하는 대신 먼저 간단한 테스트 케이스를 작성해 외부 코드를 익히면 어떨까? 짐 뉴커크는 이를 학습 테스트라 부른다. | . | . | . ",
    "url": "/chapter8-boundary.html#%EA%B2%BD%EA%B3%84-%EC%82%B4%ED%94%BC%EA%B3%A0-%EC%9D%B5%ED%9E%88%EA%B8%B0",
    
    "relUrl": "/chapter8-boundary.html#경계-살피고-익히기"
  },"129": {
    "doc": "8장 경계",
    "title": "log4j 익히기",
    "content": "학습 테스트의 예시: log4j 익히기 . | 사용하려는 방식으로 테스트 코드 작성 @Test public void testLogCreate(){ Logger logger = Logger.getLogger(\"MyLogger\"); logger.info(\"hello\"); } . | 발생한 오류에 대해 처리하는 코드 작성 @Test public void testLogCreate(){ Logger logger = Logger.getLogger(\"MyLogger\"); ConsoleAppender appender = new ConsoleAppender(); logger.addAppender(appender); logger.info(\"hello\"); } . @Test public void testLogCreate(){ Logger logger = Logger.getLogger(\"MyLogger\"); logger.removeAllAppenders(); logger.addAppender(new ConsoleAppender( new PatternLayout(\"%p %t %m%n\"), ConsoleAppender.SYSTEM_OUT )); ConsoleAppender appender = new ConsoleAppender(); logger.addAppender(appender); logger.info(\"hello\"); } . | 의심이 가는 코드에 대해 문서를 읽고, 수정 public class LogTest{ private Logger logger; @Before public void initialize(){ logger = Logger.getLogger(\"logger\"); logger.removeAllAppenders(); Logger.getRootLogger().removeAllAppenders(); } @Test public void basicLogger(){ BasicConfigurator.configure(); logger.info(\"basicLogger\"); } @Test public void addAppenderWithStream(){ logger.addAppender(new ConsoleAppender( new PatternLayout(\"%p %t %m%n\"), ConsoleAppender.SYSTEM_OUT )); logger.info(\"addAppenderWithStream\"); } @Test public void addAppenderWithoutStream(){ logger.addAppender(new ConsoleAppender( new PatternLayout(\"%p %t %m%n\") )); logger.info(\"addAppenderWithoutStream\"); } } . | 알게된 모든 지식을 클래스로 캡슐화한 뒤 이를 사용 | . ",
    "url": "/chapter8-boundary.html#log4j-%EC%9D%B5%ED%9E%88%EA%B8%B0",
    
    "relUrl": "/chapter8-boundary.html#log4j-익히기"
  },"130": {
    "doc": "8장 경계",
    "title": "학습 테스트는 공짜 이상이다",
    "content": ". | 학습 테스트가 주는 이점 . | 비용없이 필요한 지식만 확보하는 방법 | 패키지가 예상대로 동작하는지 확인 | 새 버전이 출시했을 때, 우리 코드와 호환되는지 미리 확인 가능 | . 학습테스트는 공짜 이상이다. 학습테스트는 이해도를 높여주는 정확한 실험이다. 학습 테스트는 패키지가 예상대로 도는지 검증한다. 패키지 새 버전이 나올 때마다 새로운 위험이 생긴다. 새 버전이 우리 코드와 호환되지 않으면 학습 테스트가 이 사실을 곧바로 밝혀낸다. | . ",
    "url": "/chapter8-boundary.html#%ED%95%99%EC%8A%B5-%ED%85%8C%EC%8A%A4%ED%8A%B8%EB%8A%94-%EA%B3%B5%EC%A7%9C-%EC%9D%B4%EC%83%81%EC%9D%B4%EB%8B%A4",
    
    "relUrl": "/chapter8-boundary.html#학습-테스트는-공짜-이상이다"
  },"131": {
    "doc": "8장 경계",
    "title": "아직 존재하지 않는 코드를 사용하기",
    "content": "존재하지 않는(혹은 모르는) 코드를 사용해야한다면, 이 부분에 대한 내용을 분리해 임의로 작성(작업에 필요한 내용을 작성)한 뒤 작업을 진행한다. 그리고 실제 연동시에 Adapter패턴으로 API 사용을 캡슐화해 바뀔 때 수정할 코드를 한 곳으로 모은다. 경계와 관련해 또 다른 유형은 아는 코드와 모르는 코드를 분리하는 경계다. 저쪽 팀이 아직 API를 설계하지 않았으므로 구체적인 방법은 몰랐다. 이쪽 코드를 진행하고자 우리는 자체적으로 인터페이스를 정의했다. 우리가 바라는 인터페이스를 구현하면 우리가 인터페이스를 전적으로 통제한다는 장점이 생긴다. 또한 코드 가독성도 높아지고 코드 의도도 분명해진다. 우리는 (우리가 통제하지 못하며 정의되지도 않은) 송신기 API에서 CommunicationsController를 분리했다. ADAPTER 패턴으로 API사용을 캡슐화해 API가 바뀔 때 수정할 코드를 한 곳으로 모았다. ",
    "url": "/chapter8-boundary.html#%EC%95%84%EC%A7%81-%EC%A1%B4%EC%9E%AC%ED%95%98%EC%A7%80-%EC%95%8A%EB%8A%94-%EC%BD%94%EB%93%9C%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0",
    
    "relUrl": "/chapter8-boundary.html#아직-존재하지-않는-코드를-사용하기"
  },"132": {
    "doc": "8장 경계",
    "title": "깨끗한 경계",
    "content": ". | 통제하지 못하는 코드를 사용할 때는 너무 많은 투자를 하거나 향후 변경 비용이 지나치게 커지지 않도록 각별히 주의해야 한다. | 경계에 위치하는 코드는 깔끔히 분리한다. | 외부 패키지를 호출하는 코드를 가능한 줄여 경계를 관리하자. | 어느 방법이든 코드 가독성이 높아지며, 경계 인터페이스를 사용하는 일관성도 높아지며, 외부 패키지가 변했을 때 변경할 코드도 줄어든다. | . ",
    "url": "/chapter8-boundary.html#%EA%B9%A8%EB%81%97%ED%95%9C-%EA%B2%BD%EA%B3%84",
    
    "relUrl": "/chapter8-boundary.html#깨끗한-경계"
  },"133": {
    "doc": "9장 단위 테스트",
    "title": "9장 단위 테스트",
    "content": "TDD라는 개념이 생소하던 시절, 우리들 대다수에게 단위 테스트란 자기 프로그램이 돌아간다는 사실만 확인하는 일회성 코드에 불과했다. 하지만 10년 동안 우리 분야는 눈부신 성장을 이뤘다. 애자일과 TDD 덕택에 단위 테스트를 자동화하는 프로그래머들이 이미 많아졌으며 점점 더 늘어나는 추세다. 하지만 우리 분야에 테스트를 추가하려고 급하게 서두르는 와중에 많은 프로그래머들이 제대로 된 테스트 케이스를 작성해야 한다는 좀 더 미묘한(그리고 더욱 중요한) 사실을 놓쳐버렸다. ",
    "url": "/chapter9-unit-test.html",
    
    "relUrl": "/chapter9-unit-test.html"
  },"134": {
    "doc": "9장 단위 테스트",
    "title": "TDD 법칙 세 가지",
    "content": ". | 첫째 법칙 : 실패하는 단위 테스트를 작성할 때까지 실제 코드를 작성하지 않는다. | 둘째 법칙 : 컴파일은 실패하지 않으면서 실행이 실패하는 정도로만 단위 테스트를 작성한다. | 셋째 법칙 : 현재 실패하는 테스트를 통과할 정도로만 실제 코드를 작성한다. | . 위 세 가지 규칙을 따르면 개발과 테스트가 대략 30초 주기로 묶이며, 매일 수십 개, 매달 수백 개, 매년 수천 개에 달하는 테스트 케이스가 나온다. 이러한 방대한 테스트 코드는 심각한 관리 문제를 유발하기도 한다. ",
    "url": "/chapter9-unit-test.html#tdd-%EB%B2%95%EC%B9%99-%EC%84%B8-%EA%B0%80%EC%A7%80",
    
    "relUrl": "/chapter9-unit-test.html#tdd-법칙-세-가지"
  },"135": {
    "doc": "9장 단위 테스트",
    "title": "깨끗한 테스트 코드 유지하기",
    "content": "몇 년전, 테스트 코드의 품질에 신경 쓰지않고, “지저분해도 빨리“라는 주 제어하에 테스트를 진행하는 팀의 코치를 맡은 경험이 있다. 실제 코드에 변경이 생기면, 테스트 코드도 변해야 한다. 그런데 만일 테스트 코드가 지저분하다면, 변경하기 어려워진다. 테스트 코드가 복잡할수록 실제 코드를 짜는 시간보다 테스트 케이스를 추가하는 시간이 더 걸리기 십상이다. 실제 코드를 변경해 기존 테스트 케이스가 실패하기 시작하면, 지저분한 테스트코드로 인해, 실패하는 테스트 케이스를 점점 더 통과시키기 어려워진다. 그래서 테스트 코드는 계속해서 늘어나는 부담이 되버린다. 새 버전을 출시할 때마다 팀이 테스트 케이스를 유지하고 보수하는 비용도 점차 늘어난다. 이제 점차 테스트 코드는 개발자 사이에서 불만으로 자리잡는다. 따라서 테스트 슈트를 폐기하지 않으면 안 되는 상황에 처한다. 테스트 슈트는 테스트 케이스들의 집합으로, 특정 테스트 목표나 기능 단위로 관련된 테스트 케이스들을 그룹화한 것을 뜻한다. 하지만 테스트 슈트가 없으면 개발자는 자신이 수정한 코드가 제대로 동작하는지 확인할 방법이 없다. 그래서 결함율이 높아지고, 변경에 대해 주저하게 된다. 결국 테스트 슈트도 없고, 코드는 뒤섞이고, 테스트에 쏟아 부은 노력이 허사였다는 실망감만 남는다. 이 이야기가 전하는 교훈은 “테스트 코드는 실제 코드 못지 않게 중요하다” 는 점이다. 테스트는 유연성, 유지보수성, 재사용성을 제공한다 . 코드에 유연성, 유지보수성, 재사용성을 제공하는 버팀목이 바로 단위 테스트다. 테스트 케이스가 있으면 변경이 두렵지 않고, 변경이 쉬워진다. 아무리 아키텍쳐가 유연하고, 설계를 잘 나눴더라도 테스트 케이스가 없으면 잠정적인 버그를 두려워해 변경을 주저하게 된다. 하지만 반대로 테스트 케이스가 있다면 그러한 주저함은 사라진다. 오히려 아키텍처가 부실하더라도 별다른 우려없이 코드를 변경할 수 있다. 그러므로 실제 코드를 점검하는 자동화된 단위 테스트 슈트는 설계와 아키텍처를 최대한 깨끗하게 보존하는 열쇠다. ",
    "url": "/chapter9-unit-test.html#%EA%B9%A8%EB%81%97%ED%95%9C-%ED%85%8C%EC%8A%A4%ED%8A%B8-%EC%BD%94%EB%93%9C-%EC%9C%A0%EC%A7%80%ED%95%98%EA%B8%B0",
    
    "relUrl": "/chapter9-unit-test.html#깨끗한-테스트-코드-유지하기"
  },"136": {
    "doc": "9장 단위 테스트",
    "title": "깨끗한 테스트 코드",
    "content": "깨끗한 테스트 코드를 만들기 위해 가장 중요한 것은 가독성이다. 그렇다면 가독성을 높이기 위해 필요한 것은 명료성, 단순성, 풍부한 표현력이다. 테스트 코드는 최소한의 표현으로 많은 것을 나타내야 한다. 목록 9-1은 FitNess에서 가져온 코드다. 세 개의 테스트 케이스는 이해하기 어렵기에 개선할 여지가 있다. 첫째, addPage와 assertSubString을 부르느라 중복된 코드가 매우 많다. 좀 더 중요하게는 자질구레한 사항이 너무 많아 테스트 코드의 표현력이 떨어진다. // 목록 9-1 SerializedPageResponderTest.java public void testGetPageHierarchyAsXml() throws Exception { crawler.addPage(root, PathParser.parse(\"PageOne\")); crawler.addPage(root, PathParser.parse(\"PageOne.ChildOne\")); crawler.addPage(root, PathParser.parse(\"PageTwo\")); request.setResource(\"root\"); request.addInput(\"type\", \"pages\"); Responder responder = new SerializedPageResponder(); SimpleResponse response = (SimpleResponse) responder.makeResponse(new FitNesseContext(root), request); String xml = response.getContent(); assertEquals(\"text/xml\", response.getContentType()); assertSubString(\"&lt;name&gt;PageOne&lt;/name&gt;\", xml); assertSubString(\"&lt;name&gt;PageTwo&lt;/name&gt;\", xml); assertSubString(\"&lt;name&gt;ChildOne&lt;/name&gt;\", xml); } public void testGetPageHierarchyAsXmlDoesntContainSymbolicLinks() throws Exception { WikiPage pageOne = crawler.addPage(root, PathParser.parse(\"PageOne\")); crawler.addPage(root, PathParser.parse(\"PageOne.ChildOne\")); crawler.addPage(root, PathParser.parse(\"PageTwo\")); PageData data = pageOne.getData(); WikiPageProperties properties = data.getProperties(); WikiPageProperty symLinks = properties.set(SymbolicPage.PROPERTY_NAME); symLinks.set(\"SymPage\", \"PageTwo\"); pageOne.commit(data); request.setResource(\"root\"); request.addInput(\"type\", \"pages\"); Responder responder = new SerializedPageResponder(); SimpleResponse response = (SimpleResponse) responder.makeResponse(new FitNesseContext(root), request); String xml = response.getContent(); assertEquals(\"text/xml\", response.getContentType()); assertSubString(\"&lt;name&gt;PageOne&lt;/name&gt;\", xml); assertSubString(\"&lt;name&gt;PageTwo&lt;/name&gt;\", xml); assertSubString(\"&lt;name&gt;ChildOne&lt;/name&gt;\", xml); assertNotSubString(\"SymPage\", xml); } public void testGetDataAsHtml() throws Exception { crawler.addPage(root, PathParser.parse(\"TestPageOne\"), \"test page\"); request.setResource(\"TestPageOne\"); request.addInput(\"type\", \"data\"); Responder responder = new SerializedPageResponder(); SimpleResponse response = (SimpleResponse) responder.makeResponse(new FitNesseContext(root), request); String xml = response.getContent(); assertEquals(\"text/xml\", response.getContentType()); assertSubString(\"test page\", xml); assertSubString(\"&lt;Test\", xml); } . 예를 들어, PathParser 호출을 살펴보자. PathParser는 문자열을 pagePath 인스턴스로 변환한다. 이는 웹 크롤러가 사용하는 객체로 테스트에 무관하며 테스트 코드의 의도를 흐린다. crawler.addPage(root, PathParser.parse(\"PageOne\")); crawler.addPage(root, PathParser.parse(\"PageOne.ChildOne\")); crawler.addPage(root, PathParser.parse(\"PageTwo\")); . responsder객체를 생성하는 코드와 response를 수집해 변환하는 코드 역시 잡음에 불과하다. Responder responder = new SerializedPageResponder(); SimpleResponse response = (SimpleResponse) responder.makeResponse(new FitNesseContext(root), request); String xml = response.getContent(); . 이 코드는 읽는 사람을 고려하지 않는다. 테스트와 무관한 코드가 도처에 남발되어있어, 정작 중요한 테스트 케이스를 이해하는데 방해된다. 이제 목록 9-2를 살펴보자. 목록 9-1을 개선한 코드로, 목록 9-1과 정확히 동일한 테스트를 수행한다. 하지만 좀 더 깨끗하고 이해하기 쉽다. // 목록 9-2 SerializedPageResponderTest.java (리팩터링한 코드) public void testGetPageHierarchyAsXml() throws Exception { // BUILD makePages(\"PageOne\", \"PageOne.ChildOne\", \"PageTwo\"); // OPERATE submitRequest(\"root\", \"type:pages\"); // CHECK assertResponseIsXML(); assertResponseContains( \"&lt;name&gt;PageOne&lt;/name&gt;\", \"&lt;name&gt;PageTwo&lt;/name&gt;\", \"&lt;name&gt;ChildOne&lt;/name&gt;\" ); } public void testSymbolicLinksAreNotInXmlPageHierarchy() throws Exception { // BUILD WikiPage page = makePage(\"PageOne\"); makePages(\"PageOne.ChildOne\", \"PageTwo\"); // OPERATE addLinkTo(page, \"PageTwo\", \"SymPage\"); submitRequest(\"root\", \"type:pages\"); // CHECK assertResponseIsXML(); assertResponseContains( \"&lt;name&gt;PageOne&lt;/name&gt;\", \"&lt;name&gt;PageTwo&lt;/name&gt;\", \"&lt;name&gt;ChildOne&lt;/name&gt;\" ); assertResponseDoesNotContain(\"SymPage\"); } public void testGetDataAsXml() throws Exception { // BUILD makePageWithContent(\"TestPageOne\", \"test page\"); // OPERATE submitRequest(\"TestPageOne\", \"type:data\"); // CHECK assertResponseIsXML(); assertResponseContains(\"test page\", \"&lt;Test\"); } . BUILD-OPERATE-CHECK 패턴이 위와 같은 테스트 구조에 적합하다. BUILD-OPERATE-CHECK 패턴은 테스트 코드 작성 시 가독성을 높이기 위한 구조화된 접근 이다. 이 패턴은 테스트를 세 가지 명확한 단계로 나누어 진행한다. | BUILD 단계 : 테스트에 필요한 자료와 환경을 구성하는 단계. Given 단계와 유사한 개념으로, 입력 데이터를 준비한다. | OPERATE 단계 : 준비된 테스트 자료를 실제로 조작하는 단계. When 단계와 유사하게, 실제 코드를 실행하는 과정. | CHECK 단계 : OPERATE 단계의 결과를 검증하는 단계. 이 단계에서 assert 문을 사용하여 테스트 결과를 판단한다. Then 단계와 유사한 개념이다. | . 또한 잡다하고 세세한 코드를 거의 다 없앴다는 사실에 주목해야 한다. 그러므로 읽는 사람은 필요없는 코드에 헷갈릴 필요가 없고, 코드가 수행하는 기능에 집중할 수 있게 된다. 도메인에 특화된 테스트 언어 . 목록 9-2는 도메인에 특화된 언어(DSL)로 테스트 코드를 구현하는 기법을 보여준다. 흔히 쓰는 시스템 조작 API를 사용하는 대신, API위에 함수와 유틸리티를 구현한다. 즉, 이러한 함수와 유틸리티는 당사자와 나중에 테스트를 읽을 사람을 도와주는 테스트 언어가 된다. 이런 테스트 API는 처음부터 설계된 API가 아니다. 계속 리팩터링한 결과이며, 숙련된 개발자라면 자기 코드를 좀 더 간결하고 표현력이 풍부한 코드로 리팩터링해야 한다. 이중 표준 . 테스트 API코드에 적용하는 표준과 실제 코드에 적용하는 표준은 다르다. 단순하고, 간결하고, 표현력이 풍부해야 하지만, 실제 코드만큼 효율적인 필요는 없다. 실제 환경이 아닌 테스트 환경에서 돌아가는 코드이기 때문이다. 목록 9-3을 살펴보자. 환경 제어 시스템에 속한 테스트 코드다. 세세하게 설명하지 않더라도 온도가 “급격하게 떨어지면” 경보, 온풍기, 송풍기가 모두 가동되는지 확인하는 코드라는 사실이 드러난다. // 목록 9-3 EnvironmentControllerTest.java @Test public void turnOnLoTempAlarmAtThreshold() throws Exception { hw.setTemp(WAY_TOO_COLD); controller.tic(); assertTrue(hw.heaterState()); assertTrue(hw.blowerState()); assertFalse(hw.coolerState()); assertFalse(hw.hiTempAlarm()); assertTrue(hw.loTempAlarm()); } . 목록 9-3을 읽다보면 눈길이 이리저리 흩어져, 읽기 어렵다. 그래서 목록 9-4로 변홚해 코드 가독성을 크게 높였다. // 목록 9-4 EnvironmentControllerTest.java (리팩터링) @Test public void turnOnLoTempAlarmAtThreshold() throws Exception { wayTooCold(); assertEquals(\"HBchL\", hw.getState()) ; } . 목록 9-3의 tic 함수는 wayTooColod라는 함수 내부에 숨겼다. 그런데 assertEquals에 들어있는 이상한 문자열(“HBchL”)은 무엇일까? . 이는 대문자는 “켜짐”이고 소문자는 “꺼짐”임을 뜻하며, 문자의 순서는 {heater, blower, cooler, hi-temp-alarm, lo-temp-alarm} 이다. 즉 “HBchL” 이라는 문자열은 heater, blower, lo-temp-alarm 이 “켜짐” 상태이고, cooler, hi-temp-alarm 은 “꺼짐” 상태임을 나타낸다. 위의 방식이 그릇된 정보를 피하라(코드에 코드의 의미를 흐리는 단어를 남기는)는 규칙의 위반에 가깝지만, 여기서는 적절해보인다. 앞서 말했듯, 테스트 코드와 실제 코드의 환경은 다르다. 일단 의미만 안다면, 코드를 이하는 것은 훨씬 쉬워질 것이다. 이는 목록 9-5를 보면 알수 있다. // 목록 9-5 EnvironmentControllerTest.java (더 복잡한 선택) @Test public void turnOnCoolerAndBlowerIfTooHot() throws Exception { tooHot(); assertEquals(\"hBChl\", hw.getState()); } @Test public void turnOnHeaterAndBlowerIfTooCold() throws Exception { tooCold(); assertEquals(\"HBchl\", hw.getState()); } @Test public void turnOnHiTempAlarmAtThreshold() throws Exception { wayTooHot(); assertEquals(\"hBCHL\", hw.getState()); } @Test public void turnOnLoTempAlarmAtThreshold() throws Exception { wayTooCold(); assertEquals(\"HBchL\", hw.getState()); } . 목록 9-6은 getState함수를 보여준다. 코드가 그리 효율적이지 못하며, 효율을 높이려면 StringBuffer가 더 적합하다. 하지만, 실제로 StringBuffuer를 사용하지 않아 치르는 대가는 미미하다. 이는 테스트 환경과 실제 애플리케이션 환경은 다름을 시사한다. 이것이 이중 표준의 본질이다. 실제 환경에서는 절대로 안 되지만 테스트 환경에서는 전혀 문제없는 방식이 있다. 대게 메모리나 CPU 효율과 관련 있는 경우다. 코드의 깨끗함과는 철저히 무관하다. ",
    "url": "/chapter9-unit-test.html#%EA%B9%A8%EB%81%97%ED%95%9C-%ED%85%8C%EC%8A%A4%ED%8A%B8-%EC%BD%94%EB%93%9C",
    
    "relUrl": "/chapter9-unit-test.html#깨끗한-테스트-코드"
  },"137": {
    "doc": "9장 단위 테스트",
    "title": "테스트 당 assert 하나",
    "content": "assert 문이 단 하나인 함수는 결론이 하나라서 코드를 이해하기 쉽고 빠르다. 하지만 목록 9-2는 어떨까? “출력이 XML이다”라는 assert 문과 “특정 문자열을 포함한다”는 assert 문을 하나로 병합하는 방식이 불합리해 보인다. 하지만 목록 9-7에서 보듯이 테스트를 두 개로 쪼개 각자가 assert를 수행하게 된다. // 목록 9-7 SerializedPageResponderTest.java (단일 assert) public void testGetPageHierarchyAsXml() throws Exception { givenPages(\"PageOne\", \"PageOne.ChildOne\", \"PageTwo\"); whenRequestIsIssued(\"root\", \"type:pages\"); thenResponseShouldBeXML(); } public void testGetPageHierarchyHasRightTags() throws Exception { givenPages(\"PageOne\", \"PageOne.ChildOne\", \"PageTwo\"); whenRequestIsIssued(\"root\", \"type:pages\"); thenResponseShouldContain( \"&lt;name&gt;PageOne&lt;/name&gt;\", \"&lt;name&gt;PageTwo&lt;/name&gt;\", \"&lt;name&gt;ChildOne&lt;/name&gt;\" ); } . 위에서 함수 이름을 바꿔 given-when-then이라는 관례를 사용했다는 사실에 주목한다. 그러면 테스트 코드를 읽기가 쉬워진다. 하지만 불행하게도, 위에서 보듯이, 테스트를 분리하면 중복되는 코드가 많아진다. TEMPLATE METHOD 패턴을 사용하면 중복을 제거할 수 있다. given/when 부분을 부모 클래스에 두고 then 부분을 자식 클래스에 두면된다. 템플릿 메소드(Template Method) 패턴은 알고리즘의 구조를 정의하고 일부 단계를 서브클래스에서 구현할 수 있도록 하는 행동 디자인 패턴이다. 혹은, 완전히 독자적인 테스트 클래스를 만들어 @Before 함수에 given.when 부분을 넣고 @Test 함수에 then 부분을 넣어도 된다. 하지만 모두가 배보다 배꼽이 더 크다. 결국 목록 9-2 처럼 assert 문을 여럿 사용하는 편이 좋다고 생각한다. ‘단일 assert 문’이라는 규칙이 훌륭한 지침이라고 생각한다. 하지만 때로는 주저 없이 함수 하나에 여러 assert 문을 넣기도 한다. 단지 assert 문 개수를 최대한 줄여야 좋다는 생각이다. 테스트 당 개념 하나 . 어쩌면 “테스트 함수마다 한 개념만 테스트하라“는 규칙이 더 낫겠다. 목록 9-8은 바람직하지 못한 테스트 함수다. 독자적인 개념 세 개를 테스트 하므로, 독자적인 테스트 함수 세 개로 쪼개야 마땅하다. /** * 목록 9-8 * addMonths() 메서드를 테스트하는 장황한 코드 */ public void testAddMonths() { SerialDate d1 = SerialDate.createInstance(31, 5, 2004); SerialDate d2 = SerialDate.addMonths(1, d1); assertEquals(30, d2.getDayOfMonth()); assertEquals(6, d2.getMonth()); assertEquals(2004, d2.getYY()); SerialDate d3 = SerialDate.addMonths(2, d1); assertEquals(31, d3.getDayOfMonth()); assertEquals(7, d3.getMonth()); assertEquals(2004, d3.getYY()); SerialDate d4 = SerialDate.addMonths(1, SerialDate.addMonths(1, d1)); assertEquals(30, d4.getDayOfMonth()); assertEquals(7, d4.getMonth()); assertEquals(2004, d4.getYY()); } . 셋으로 분리한 테스트 함수는 각각 다음 기능을 수행한다. | (5월처럼) 31일로 끝나는 달의 마지막 날짜가 주어지는 경우 . | (6월처럼) 30일로 끝나는 한 달을 더하면 날짜는 30일이 되어야지 31일이 되어서는 안된다. | 두 달을 더하면 그리고 두 번째 달이 31일로 끝나면 날짜는 31일이 되어야 한다. | . | (6월처럼) 30일로 끝나는 달의 마지막 날짜가 주어지는 경우 . | 31일로 끝나는 한 달을 더하면 날짜는 30일이 되어야지 31일이 되면 안된다. | . | . 이렇게 표현하면 일반적인 규칙이 보인다. 즉, 목록 9-8의 문제는 assert 문이 여럿이라는 점이 아니라는 것이다. 한 테스트 함수에서 여러 개념을 테스트한다는 사실이 문제다. 그러므로 가장 좋은 규칙은 “개념 당 assert 문 수를 최소로 줄여라”와 “테스트 함수 하나는 개념 하나만 테스트하라”라 할 수 있겠다. ",
    "url": "/chapter9-unit-test.html#%ED%85%8C%EC%8A%A4%ED%8A%B8-%EB%8B%B9-assert-%ED%95%98%EB%82%98",
    
    "relUrl": "/chapter9-unit-test.html#테스트-당-assert-하나"
  },"138": {
    "doc": "9장 단위 테스트",
    "title": "F.I.R.S.T",
    "content": "깨끗한 테스트는 다음 다섯 가지 규칙을 따른다. | 빠르게(Fast) : 테스트는 빠른 주기로 돌려야 한다. 자주 돌리지 않으면 문제를 찾아내거나, 코드를 정리하기 어렵다. | 독립적으로(Independent) : 각 테스트는 서로 의존하면 안 된다. 한 테스트가 다음 테스트가 실행될 환경을 준비해서는 안된다. 테스트들이 서로 의존하면 결과가 서로 영향을 미쳐 원인을 파악하기 어려워 진다. | 반복가능하게(Repeatable) : 테스트는 어떤 환경에서도 반복 가능해야한다. 테스트가 돌아가지 않는 환경이 하나라도 있다면 테스트가 실패한 이유를 둘러댈 변명이 생긴다. | 자가검증하는(Self-Validating) : 테스트는 부울 값으로 결과를 내야 한다. 예를 들어 통과 여부를 알려고 로그 파일을 읽게 해서는 안된다. 테스트 스스로 성공과 실패를 가늠하지 못한다면, 판단은 주관적이 된다. | 적시에(Timely) : 테스트는 적시에 작성해야 한다. 단위 테스트는 테스트하려는 실제 코드를 구현하기 직전에 구현한다. | . ",
    "url": "/chapter9-unit-test.html#first",
    
    "relUrl": "/chapter9-unit-test.html#first"
  },"139": {
    "doc": "9장 단위 테스트",
    "title": "결론",
    "content": "테스트 코드는 실제 코드만큼이나 프로젝트 건강에 중요하다. 테스트 코드는 실제 코드의 유연성, 유지보수성, 재사용성을 보존하고 강화하기 때문이다. 그러므로 테스트 코드는 지속적으로 깨끗하게 관리하자. 표현력을 높이고 간결하게 정리하자. 테스트 API를 따로 구현해 도메인 특화 언어로 만들자. 테스트 코드가 방치되어 망가지면 실제 코드도 망가진다. 테스트 코드를 깨끗하게 유지하자. ",
    "url": "/chapter9-unit-test.html#%EA%B2%B0%EB%A1%A0",
    
    "relUrl": "/chapter9-unit-test.html#결론"
  },"140": {
    "doc": "6장 객체와 자료구조",
    "title": "6장 객체와 자료구조",
    "content": "변수를 비공개(private)로 정의하는 이유는 남들이 변수에 의존하지 않게 만들고 싶어서이다. 하지만, 어째서인지 수많은 프로그래머들은 조회(get)함수 와 설정(set)함수를 당연하게 공개해 비공개 변수를 외부에 노출한다. ",
    "url": "/chpater6-obejct-and-data-structure.html",
    
    "relUrl": "/chpater6-obejct-and-data-structure.html"
  },"141": {
    "doc": "6장 객체와 자료구조",
    "title": "자료 추상화",
    "content": "다음 목록 6-1, 6-2 클래스를 살펴보자. 두 클래스 모두 2차원 점을 표현하지만 한 클래스는 구현을 외부로 노출하고, 다른 클래스는 구현을 완전히 숨긴다. // 목록 6-1 구체적인 Point 클래스 public class Point { public double x; public double y; } . // 목록 6-2 추상적인 Point 클래스 public class Point { double getX(); double getY(); void setCartesian(double x, double y); double getR(); double getTheta(); void setPolar(double r, double theta); } . 6-2는 점이 직표좌표계를 사용하는지, 극좌표계를 사용하는지 알 길이 없다. 하지만, 점을 표현하는 자료 구조라는 점은 명확하게 안다. 직교좌표계와 극좌표계는 2차원 평면상의 점을 표현하는 두 가지 다른 방식. 직교좌표계는 점을 두 개의 직선 거리(x, y)로 표현하고, 극좌표계는 거리(r)와 각도(θ)로 표현한다. 즉, 인터페이스를 통해 자료구조는 알지만 어떤 방식으로 구현했는 지 내부 동작에 관련해서는 알수 없도록 숨긴 것이다. 사실 6-2 는 자료 구조 그 이상을 표현한다. 클래스 메서드가 접근 정책을 강제한다. 예를 들면, 좌표를 읽을 때는 각 값을 개별적으로 읽어야하지만 좌표를 설정할 때는 두 값을 한거번에 설정해야 한다. 반면 6-1은 확실히 직교좌표계를 사용한다는 것을 알 수 있다. 구현을 노출하는 것이다. 또한 개별적으로 좌표값을 읽고 설정하게 강제한다. 만약 변수를 private하게 바꾸더라도, 각 값마다 조회/설정함수를 제공한다면 구현을 외부로 노출하는 셈이다. 이처럼 변수 사이에 함수라는 계층을 넣는다고 구현이 저절로 감춰지지 않는다. 구현을 감추기 위해 필요한 것은 추상화이다. 추상 인터페이스를 통해 사용자가 구현을 모른 채 자료 구조의 핵심을 조작할 수 있어야 진정한 의미의 클래스다. 마지막으로 목록 6-3과 목록 6-4를 살펴보자. 목록 6-3은 자동차 연료 상태를 구체적인 숫자 값으로 알려준다. 해당 값이 변수값을 읽어 반환한 값이라는 사실이 거의 확실하다. 반면, 목록 6-4는 자동차 연료 상태를 백분율이라는 추상적인 개념으로 알려준다. 이 정보는 어디서 오는지 전혀 드러나지 않는다. // 목록 6-3 구체적인 Vehicle 클래스 public interface Vehicle { double getFuelTankCapacityInCallons(); double getGallonsOfGasoline(); } . // 목록 6-4 추상적인 Vehicle 클래스 public interface Vehicle { double getPercentFuelRemaining(); } . 목록 6-1과 목록 6-2에서는 목록 6-2가, 목록 6-3과 목록 6-4에서는 목록 6-4가 더 좋다. 자료를 세세하게 공개하지않고 추상적인 개념으로 표현하기 때문이다. 인터페이스나 조회/설정 함수만으로는 추상화가 이뤄지지 않는다. 개발자는 객체가 포함하는 자료를 표현할 가장 좋은 방법을 심각하게 고민해야한다. 아무 생각 없이 조회/설정 함수를 추가하는 방법이 가장 나쁘다. ",
    "url": "/chpater6-obejct-and-data-structure.html#%EC%9E%90%EB%A3%8C-%EC%B6%94%EC%83%81%ED%99%94",
    
    "relUrl": "/chpater6-obejct-and-data-structure.html#자료-추상화"
  },"142": {
    "doc": "6장 객체와 자료구조",
    "title": "자료/객체 비대칭",
    "content": "앞선 두 가지 예제(목록 6-1/목록 6-2, 목록 6-3/목록 6-4)는 객체와 자료 구조 사이에 벌어진 차이를 보여준다. | 객체는 추상화 뒤로 자료를 숨긴 채 자료를 다루는 함수만 공개한다. | 자료구조는 자료를 그대로 공개하며 별다른 함수는 제공하지 않는다. | . 두 정의는 본질적으로 상반되며, 차이를 만든다. 절차적인 코드인 6-5와 객체지향 코드인 목록 6-5의 예제를 통해 살펴보자. 목록 6-5는 절차적인 도형클래스이다. Geometry 클래스는 세 가지 도형 클래스를 다룬다. 각 도형 클래스는 간단한 자료구조다. 즉, 아무 메서드도 제공하지 않는다. 도형이 동작하는 방식은 Geometry 클래스에서 구현한다. // 목록 6-5 절차적인 도형 클래스 public class Square { public Point topLeft; public double side; } public class Rectangle { public Point topLeft; public double height; public double width; } public class Circle { public Point center; public double radius; } public class Geometry { public final double PI = 3.141592653589793; public double area(Object shape) throws NoSuchShapeException { if (shape instanceof Square) { Square s = (Square) shape; return s.side * s.side; } else if (shape instanceof Rectangle) { Rectangle r = (Rectangle) shape; return r.height * r.width; } else if (shape instanceof Circle) { Circle c = (Circle) shape; return PI * c.radius * c.radius; } throw new NoSuchShapeException(); } } . 객체 지향 프로그래머가 위 코드를 본다면 클래스가 절차적이라고 비판할수도 있다. 하지만 그것이 100% 옳다고 말하긴 어렵다. 만약 Geometry 클래스에 둘레 길이를 구하는 perimeter() 라는 함수를 추가한다고 치자. 이때 세개의 도형 클래스들은 아무런 영향을 받지 않는다. 도형 클래스에 의존하는 다른 클래스도 마찬가지이다. /*...*/ public class Geometry { public double area(Object shape) throws NoSuchShapeException { /* ... */ } public double perimeter(Object shape) throws NoSuchShapeException { /*...*/ } } . 하지만 반면 새 도형 클래스를 추가하고 싶다면, Geometry 클래스에 속한 함수를 모두 고쳐야 한다. /*...*/ // 새 도형 클래스 추가 public class Pentagon { /*...*/ } public class Geometry { public double area(Object shape) throws NoSuchShapeException { /*...*/ // 함수 수정 else if (shape instance of Pentagon){ /*...*/ } } public double perimeter(Object shape) throws NoSuchShapeException { /*...*/ else if (shape instance of Pentagon){ /*...*/ } } } . 이번에는 객체 지향적인 코드인 목록 6-6을 살펴보자. area()는 다형 메서드다. // 목록 6-6 다형적인 도형 public class Square implements Shape { private Point topLeft; private double side; public double area() { return side * side; } } public class Rectangle implements Shape { private Point topLeft; private double height; private double width; public double area() { return height * width; } } public class Circle implements Shape { private Point center; private double radius; public final double PI = 3.141592653589793; public double area() { return PI * radius * radius; } } . area()는 다형 메서드이므로 Geometry 클래스는 필요없다. 따라서 새 도형 클래스를 추가해도 기존 함수에 아무런 영향을 미치지 않는다. public class Square implements Shape { /*...*/ } /** . */ public class Pentagon implements Shape { public double area() { /*...*/ } } . 하지만 반면 새 함수를 추가하고 싶다면 도형 클래스 전부를 고쳐야한다. public class Square implements Shape { /*...*/ public double perimeter(){ /*...*/ } } public class Rectangle implements Shape { /*...*/ public double perimeter(){ /*...*/ } } public class Circle implements Shape { /*...*/ public double perimeter(){ /*...*/ } } . 앞서도 말했듯이, 목록 6-5와 목록 6-6은 객체와 자료구조 사이의 양분되는 특질을 보여준다. | (자료구조를 사용하는) 절차적인 코드는 기존 자료 구조를 변경하지 않으면서 새 함수를 추가하기 쉽다. 반면, 객체 지향 코드는 기존 함수를 변경하지 않으면서 새 클래스를 추가하기 쉽다. | 절차적인 코드는 새로운 자료 구조를 추가하기 어렵다. 그러려면 모든 함수를 고쳐야 하기 한다. 객체 지향 코드는 새로운 함수를 추가하기 어렵다. 그러려면 모든 클래스를 고쳐야한다. | . 다시 말해, 객체 지향 코드(객체 중심의)에서 어려운 변경은 절차적인 코드(자료 구조 중심의)에서 쉬우며, 절차적인 코드에서 어려운 변경은 객체 지향 코드에서 쉽다. 분별 있는 프로그래머라면 모든 것이 객체라는 생각이 미신임을 잘 안다. 때로는 단순한 자료 구조와 절차적인 코드가, 때로는 객체 지향 코드가 적합한 경우들이 존재한다. ",
    "url": "/chpater6-obejct-and-data-structure.html#%EC%9E%90%EB%A3%8C%EA%B0%9D%EC%B2%B4-%EB%B9%84%EB%8C%80%EC%B9%AD",
    
    "relUrl": "/chpater6-obejct-and-data-structure.html#자료객체-비대칭"
  },"143": {
    "doc": "6장 객체와 자료구조",
    "title": "디미터 법칙",
    "content": "디미터 법칙은 잘 알려진 휴리스틱으로, 모듈은 자신이 조작하는 객체의 속사정을 몰라야 한다는 법칙이다. 앞 절에서 봤듯이, 객체는 자료를 숨기고 함수를 공개한다. 즉, 객체는 조회 함수로 내부 구조를 공개하면 안된다는 의미다. 디미터 법칙은 좀 더 정확히 표현하자면, “클래스 C의 메서드 f는 다음과 같은 객체의 메서드만 호출해야 한다” 고 주장한다. | 클래스 C | f가 생성한 객체 | f 인수로 넘어온 객체 | C 인스턴스 변수에 저장된 객체 | . 하지만 위 객체에서 허용된 메서드가 반환하는 객체의 메서드는 호출하면 안된다. 다음 코드는 디미터 법칙을 어기는 듯 보인다. 객체 ctxt의 함수인 getOptions() 함수가 반환하는 객체의 getScratchDir() 함수를 호출한 후, 또 그 함수가 반환하는 객체의 getAbsolutePath() 함수를 호출하기 때문이다. // 임시 디렉터리의 절대 경로를 얻는 코드 final String outputDir = ctxt.getOptions().getScratchDir().getAbsolutePath(); . 기차 충돌 . 위와 같은 코드를 기차 충돌이라 부른다. 여러 객차가 한 줄로 이어진 기차처럼 보이기 때문이다. 일반적으로 조잡하다 여겨지는 방식이므로 피하는 편이 좋다. 따라서 위 코드는 다음과 같이 나누는 편이 좋다. Options opts = ctxt.getOptions(); File scratchDir = opts.getScratchDir(); final String outputDir = scratchDir.getAbsolutePath(); . 이로써 기차 충돌 문제는 해결했지만, 디미터 법칙을 여전히 위반하는지 알 수없다. 그 여부는 ctxt, options, scratchDir이 객체인지 아니면 자료 구조인지에 달렸다. 객체라면 내부 구조를 숨겨야 하기에 디미터 법칙을 위반하게 되고, 자료 구조라면 내부 구조를 노출하므로 디미터 법칙이 적용되지 않는다. 그런데 위 예제는 조회 함수(get)를 사용하는 바람에 혼란을 일으킨다. 위 예제를 다음과 같이 구현했다면 디미터 법칙을 거론할 필요가 없어진다. final String ouputDir = ctxt.options.scratchDir.absolutePath; . 자료 구조는 무조건 함수 없이 공개 변수만 포함하고 객체는 비공개 변수와 공개 함수를 포함하면 훨씬 간단해진다. 잡종 구조 . 위와 같은 혼란은 때때로 절반은 객체, 절반은 자료 구조인 잡종 구조를 야기한다. 잡종 구조에는 중요한 기능을 수행하는 함수도 있고, 공개 변수나 공개 조회/설정 함수도 있다. 이런 잡종 구조는 새로운 함수는 물론, 새로운 자료 구조도 추가하기 어렵다. 그러므로 잡종 구조는 되도록 피하는 편이 좋다. 잡종 구조는 프로그래머가 함수나 타입을 보호할지 공개할지 확신하지 못해(더 나쁘게는 무지해) 어중간하게 내놓은 설계에 불과하다. 구조체 감추기 . 만약 ctxt, options, scratchDir이 진짜 객체라면 내부 구조를 감춰야 하기 때문에, 앞선 코드 예제처럼 줄줄이 사탕으로 엮어서는 안된다. 그렇다면 어떤 방식으로 임시 디렉터리의 절대 경로를 얻는 이 코드를 변경할 수 있을까? . 다음 두 코드를 살펴보자. ctxt.getAbsolutePathOfScratchDirectoryOption(); ctxt.getScratchDirectoryOption().getAbsolutePath(); . 첫 번째 방법은 ctxt 객체에 공개해야하는 메서드가 너무 많아진다. 두 번째 방법은 getScratchDirectoryOption()이 객체가 아닌, 자료 구조를 반환한다고 가정한다. 두 변경 방법 모두 내부 구조를 드러내는 방향이기에 디미터 법칙을 위반하게된다. 객체의 메서드에게는 뭔가를 하라고 말해야지 속을 드러내라고 말하면 안된다. 다음은 같은 모듈에서 가져온 코드이다. 이는 절대 경로를 가져오는 이유가 임시 파일을 생성하기 위한 목적이라는 사실이 드러난다. String outFile = outputDir + \"/\" + className.replace('•', '/') + \"-class\"; FileOutputStream fout = new FileOutputStream(outFile); BufferedOutputStream bos = new BufferedOutputStream(fout); . 그렇다면 ctxt 객체에 임시 파일을 생성하라고 시키면 어떨까? . BufferedOutputStream bos = ctxt.createScratchFileStream(classFileName); . 이로써 ctxt는 내부 구조를 드러내지 않으며. 모듈에서 해당 함수는 자신이 몰라야하는 여러 객체(디미터의 법칙)를 탐색할 필요가 없다. ",
    "url": "/chpater6-obejct-and-data-structure.html#%EB%94%94%EB%AF%B8%ED%84%B0-%EB%B2%95%EC%B9%99",
    
    "relUrl": "/chpater6-obejct-and-data-structure.html#디미터-법칙"
  },"144": {
    "doc": "6장 객체와 자료구조",
    "title": "자료 전달 객체",
    "content": "자료 구조체의 전형적인 형태는 공개 변수만 있고 함수가 없는 클래스다. 이런 자료 구조체를 때로는 자료 전달 객체(Data Transfer Object, DTO)라 한다. DTO는 굉장히 유용한 구조체다. 특히 데이터베이스와 통신하거나 소켓에서 받은 메시지의 구문을 분석할 때 유용하다. 흔히 DTO는 데이터베이스에 저장된 가공되지 않은 정보를 애플리케이션 코드에서 사용할 객체로 변환하는 일련의 단계에서 가장 처음으로 사용하는 구조체다. 좀 더 일반적인 형태는 ‘bean’ 구조다. bean은 비공개(private) 변수를 조회/설정 함수로 조작한다. 이는 일종의 사이비 캡슐화 로 간주되며, 별다른 이익을 제공하지 않는다. // 목록 6-7 address.java public class Address { private String street; private String streetExtra; private String city; private String state; private String zip; public Address (String street, String streetExtra, String city, String state, String zip) { this.street = street; this.streetExtra = streetExtra; this.city = city; this.state = state; this.zip = zip; } public String getStreet() { return street; } public String getStreetExtra () { return streetExtra; } public String getCity() { return city; } public String getState() { return state; } public String getZip() { return zip; } } . 활성 레코드 . 활성 레코드는 DTO의 특수한 형태다. 공개 변수가 있거나 비공개 변수에 조회/설정 함수가 있는 자료 구조지만, 대개 save나 find와 같은 탐색 함수도 제공한다. 활성 레코드는 데이터베이스 테이블이나 다른 소스에서 자료를 직접 변환한 결과다. 활성 레코드에 비즈니스 규칙 메서드를 추가해 자료 구조를 객체로 취급하는 것은 바람직하지 않다. 그러면 자료 구조도 아니고 객체도 아닌 잡종 구조가 나오기 때문이다. 해결책은 당연하다. 활성 레코드는 자료 구조로 취급한다. 비즈니스 규칙을 담으면서 내부 자료를 숨기는 객체는 따로 생성한다. (여기서 내부 자료는 활성 레코드의 인스턴스일 가능성이 높다.) . ",
    "url": "/chpater6-obejct-and-data-structure.html#%EC%9E%90%EB%A3%8C-%EC%A0%84%EB%8B%AC-%EA%B0%9D%EC%B2%B4",
    
    "relUrl": "/chpater6-obejct-and-data-structure.html#자료-전달-객체"
  },"145": {
    "doc": "6장 객체와 자료구조",
    "title": "결론",
    "content": "객체는 동작을 공개하고 자료를 숨긴다. 그래서 기존 동작을 변경하지 않으면서 새 객체 타입을 추가하기는 쉬운 반면, 기존 객체에 새 동작(함수)을 추가하기는 어렵다. 자료 구조는 별다른 동작 없이 자료를 노출한다. 그래서 기존 자료 구조에 새 동작을 추가하기는 쉬우나, 기존 함수에 새 자료 구조를 추가하기는 어렵다. 시스템을 구현할 때, 새로운 자료 타입을 추가하는 유연성이 필요하면 객체가 더 적합하다. 다른 경우로 새로운 동작을 추가하는 유연성이 필요하면 자료 구조와 절차적인 코드가 더 적합하다. 우수한 소프트웨어 개발자는 편견 없이 이 사실을 이해해 직면한 문제에 최적인 해결책을 선택한다. ",
    "url": "/chpater6-obejct-and-data-structure.html#%EA%B2%B0%EB%A1%A0",
    
    "relUrl": "/chpater6-obejct-and-data-structure.html#결론"
  },"146": {
    "doc": "Clean Code Study",
    "title": "Clean Code",
    "content": "Clean Code(클린 코드) (로버트 C. 마틴 저자(글)) 도서의 내용을 정리합니다. ",
    "url": "/#clean-code",
    
    "relUrl": "/#clean-code"
  },"147": {
    "doc": "Clean Code Study",
    "title": "목차",
    "content": ". | 1장 - 깨끗한 코드 | 2장 - 의미있는 이름 | 3장 - 함수 | 4장 - 주석 | 5장 - 형식 맞추기 | 6장 - 객체와 자료 구조 | 7장 - 오류 처리 | 8장 - 경계 | 9장 - 단위 테스트 | 10장 - 클래스 | 11장 - 시스템 | 12장 - 창발성 | 13장 - 동시성 | 14장 - 점진적인 개선 | 15장 - JUnit | 16장 - SerialDate 리팩토링 | 17장 - 냄새와 휴리스틱 | . Just the Docs 테마로 제작되었습니다. ",
    "url": "/#%EB%AA%A9%EC%B0%A8",
    
    "relUrl": "/#목차"
  },"148": {
    "doc": "Clean Code Study",
    "title": "Clean Code Study",
    "content": " ",
    "url": "/",
    
    "relUrl": "/"
  }
}
